<?xml version="1.0" encoding="UTF-8"?>
<!--
/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
-->
<book
  version="5.0"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:xi="http://www.w3.org/2001/XInclude"
  xmlns:svg="http://www.w3.org/2000/svg"
  xmlns:m="http://www.w3.org/1998/Math/MathML"
  xmlns:html="http://www.w3.org/1999/xhtml"
  xmlns:db="http://docbook.org/ns/docbook"
  xml:id="book">
  <info>

    <title><link
        xlink:href="http://www.hbase.org"> The Apache HBase&#153; 参考指南 </link></title>
    <subtitle><link
        xlink:href="http://www.hbase.org">
        <inlinemediaobject>
          <imageobject>
            <imagedata
              fileref="hbase_logo.png" />
          </imageobject>
        </inlinemediaobject>
      </link><link
            xlink:href="http://www.hbase.org">HBase</link>
        官方文档中文版
    </subtitle>
    <authorgroup>
        <author>
            <contrib>中文译者：山瑞峰，邮箱：shanruifeng@gmail.com，QQ:839894344; &#160;&#160;李展，邮箱：lizhanwhu@gmail.com，QQ:609377620</contrib>
        </author>
    </authorgroup>

    <releaseinfo>译者注：当前HBase英文版的用户指南相比较之前的版本更新了很多内容。而之前其他人翻译的版本因为某些原因已经中断，所以，重新翻译了最新版的HBase英文版参考指南。由于涉及的概念和术语较多，许多概念和术语尚没有公认的中文译法，加上译者水平有限，若译文中有不妥之处，还请批评指正。</releaseinfo>
    <copyright>
      <year>2014</year>
      <holder>Apache软件基金会。保留所有权利。Apache Hadoop、Hadoop、MapReduce、
        HDFS、Zookeeper、HBase和HBase项目的logo是Apache软件基金会的商标。 </holder>
    </copyright>

    <abstract>
        <info>
            <title>摘要</title>
        </info>
      <para>这是 <link
          xlink:href="http://www.hbase.org">Apache HBase&#153;</link>的官方文档， HBase是一个分布式的、多版本的、面向列的，建立在<link
          xlink:href="http://hadoop.apache.org/">Apache Hadoop&#153;</link> 和 <link
          xlink:href="http://zookeeper.apache.org/">Apache ZooKeeper&#153;</link>之上的大数据存储平台。 </para>
    </abstract>

    <revhistory>
      <revision>
        <revnumber>
          <?eval ${project.version}?>
        </revnumber>
        <date>
          <?eval ${buildDate}?>
        </date>
      </revision>
    </revhistory>
  </info>

  <!--XInclude some chapters-->
  <xi:include
    xmlns:xi="http://www.w3.org/2001/XInclude"
    href="preface.xml" />
  <xi:include
    xmlns:xi="http://www.w3.org/2001/XInclude"
    href="getting_started.xml" />
  <xi:include
    xmlns:xi="http://www.w3.org/2001/XInclude"
    href="configuration.xml" />
  <xi:include
    xmlns:xi="http://www.w3.org/2001/XInclude"
    href="upgrading.xml" />
  <xi:include
    xmlns:xi="http://www.w3.org/2001/XInclude"
    href="shell.xml" />

  <chapter
    xml:id="datamodel">
    <title>数据模型</title>
    <para>
        在HBase中，数据被存储在表中。表包含行和列。这个术语和关系型数据库(RDBMSs)的有些重叠，但是它们是不同的。你可以将HBase的表看做是一个多维的map。</para>
    <variablelist>
      <title>HBase数据模型术语</title>
      <varlistentry>
        <term>表(Table)</term>
        <listitem>
          <para>一个HBase表包含多行。</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>行(Row)</term>
        <listitem>
          <para>
              HBase中的一行包含一个行键和一个或多个列。行按照行键的字母序进行排序存储。因为这个原因，行键的设计就非常重要。
              设计的目标是让那些彼此相近的行存在一起。一个通用的行键模式是网址。如果你的行键是域名，你可以需要对他们进行逆序(org.apache.www,
              org.apache.mail, org.apache.jira).在这方式中，所有Apache的网址会在表中存储在一起，而不是基于字母序被分开存储。
              </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>列(Column)</term>
        <listitem>
          <para>HBase中的列由一个列族和一个列限定符组成，它们之间使用分隔符<literal>:</literal>分割。</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>列族(Column Family)</term>
        <listitem>
          <para>
              在物理上，一个的列族成员在文件系统上都被存储在一起。因为存储优化都是针对列族级别的，这就意味着，一个列族的所有成员的使用相同的方式被访问。
             每一个列族有一系列存储属性，例如是否值应该被缓存到内存，它的数据是否被压缩或者它的行键是否被编码等等。表中的每一行有相同的列族，尽管一个给定的行可能在一个给定的列簇上没有存储任何数据。</para>
          <para>
              列族在创建表的时候指定，并且影响你的数据在文件系统中被存储的方式。因此，在模式设计时，应该仔细考虑如何设计列族。
              </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>列限定符(Column Qualifier)</term>
        <listitem>
          <para>
              列族加上列限定符就可以给一块数据提供索引。给定一个列族<literal>content</literal>，一个列限定符可能是<literal>content:html</literal>，另一个可能是
              <literal>content:pdf</literal>。尽管列族在表创建的时候是固定的，但列限定符是可变的，并且不同行的列限定符可以不同。
              </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>单元格(Cell)</term>
        <listitem>
          <para>
		一个单元格由行、列族和列限定符还有一个值和一个代表该值版本的时间戳组成。
		</para>
          <para>一个单元格的值是一个字节数组。</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>时间戳(Timestamp)</term>
        <listitem>
          <para>时间戳和值一起被写入，并且指定了该值的版本。默认情况下，时间戳的值是数据被写入时RegionServer的时间，
		但是你可以在你插入(put)数据进入一个单元格时，可以自己指定一个时间戳。
		</para>
          <caution>
            <para>
		直接操作时间戳是HBase的高级特性，只有在需要和HBase深度集成的特定情况下才被使用，一般情况下不鼓励这样做。
                在应用层直接编码一个时间戳应该成为首选。
		</para>
          </caution>
          <para>
              你可以对HBase保留的每一个列族的某一个值指定一个最大的版本数。当版本数目达到了该最大版本数目，最早的那些版本最终将会被删除。默认情况下，只保留最新的一个版本。
              </para>
        </listitem>
      </varlistentry>
    </variablelist>

    <section
      xml:id="conceptual.view">
      <title>概念视图</title>
      <para>Jim R. Wilson的文章 <link
          xlink:href="http://jimbojw.com/wiki/index.php?title=Understanding_Hbase_and_BigTable">Understanding
          HBase and BigTable</link> 中对HBase数据模型做出了一个非常容易理解的一个解释。 Amandeep Khurana也写了一个pdf <link
              xlink:href="http://0b4af6cdc2f0c5998459-c0245c5c937c5dedcca3f1764ecc9b2f.r43.cf2.rackcdn.com/9353-login1210_khurana.pdf">Introduction
          to Basic Schema Design</link>，对HBase数据模型做出了很好的解释。它可以帮助你从不同的观点来获取一个对HBase模式设计的扎实的理解。
          链接里的文章包含了在本节中讲到的内容。
          </para>
      <para>
          下面的例子对<link
              xlink:href="http://research.google.com/archive/bigtable.html">BigTable</link>论文第二页的例子做了一个简单的修改。
          表<varname>webtable</varname>包含了两行(<literal>com.cnn.www</literal>
          和<literal>com.example.www</literal>)，三个列族(<varname>contents</varname>、<varname>anchor</varname>和 <varname>people</varname>)。
          在这个例子中，第一行(<literal>com.cnn.www</literal>)的列族<varname>anchor</varname>包含了两列(<varname>anchor:cssnsi.com</varname>和
          <varname>anchor:my.look.ca</varname>)，列族<varname>contents</varname>包含了一列(<varname>contents:html</varname>)。
          这个例子中行键为<literal>com.cnn.www</literal>的行包含了5个版本，行键为<literal>com.example.www</literal>的行包含1个版本。列限定符<varname>contents:html</varname>包含了一个给定web站点的所有html内容。列簇<varname>anchor</varname>的每一个列限定符
          包含了行键指定的网站指向的其他站点的相关信息。 列族<varname>people</varname>表示与该网站有关的一些人。
      </para>
        <note>
          <title>列名</title>
        <para> 按照惯例，列名由列族和一个<emphasis>列限定符</emphasis>组成。例如，列<emphasis>contents:html</emphasis>由列族<varname>contents</varname>
            和列限定符<varname>html</varname>组成。冒号(<literal>:</literal>)用来分隔列族和<emphasis>列限定符</emphasis>。
            </para>
        </note>
        <table
          frame="all">
          <title>表<varname>webtable</varname></title>
          <tgroup
            cols="5"
            align="left"
            colsep="1"
            rowsep="1">
            <colspec
              colname="c1" />
            <colspec
              colname="c2" />
            <colspec
              colname="c3" />
            <colspec
              colname="c4" />
            <colspec
              colname="c5" />
            <thead>
              <row>
                <entry>Row Key</entry>
                <entry>Time Stamp</entry>
                <entry>ColumnFamily <varname>contents</varname></entry>
                <entry>ColumnFamily <varname>anchor</varname></entry>
                <entry>ColumnFamily <varname>people</varname></entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>"com.cnn.www"</entry>
                <entry>t9</entry>
                <entry />
                <entry><varname>anchor:cnnsi.com</varname> = "CNN"</entry>
                <entry />
              </row>
              <row>
                <entry>"com.cnn.www"</entry>
                <entry>t8</entry>
                <entry />
                <entry><varname>anchor:my.look.ca</varname> = "CNN.com"</entry>
                <entry />
              </row>
              <row>
                <entry>"com.cnn.www"</entry>
                <entry>t6</entry>
                <entry><varname>contents:html</varname> = "&lt;html&gt;..."</entry>
                <entry />
                <entry />
              </row>
              <row>
                <entry>"com.cnn.www"</entry>
                <entry>t5</entry>
                <entry><varname>contents:html</varname> = "&lt;html&gt;..."</entry>
                <entry />
                <entry />
              </row>
              <row>
                <entry>"com.cnn.www"</entry>
                <entry>t3</entry>
                <entry><varname>contents:html</varname> = "&lt;html&gt;..."</entry>
                <entry />
                <entry />
              </row>
              <row>
                <entry>"com.example.www"</entry>
                <entry>t5</entry>
                <entry><varname>contents:html</varname> = "&lt;html&gt;..."</entry>
                <entry></entry>
                <entry>people:author = "John Doe"</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      <para>表中为空的单元格不会在HBase中占用空间或者实际存在。
          这就是HBase中“疏”的含义。表格视图并不是在HBase查看数据的唯一方式，或者说最精确的方式。下面使用多维映射(map)展示了相同的信息。
          这仅仅用于解释说明，可能并不是严格准确。
          </para>
      <programlisting><![CDATA[
{
	"com.cnn.www": {
		contents: {
			t6: contents:html: "<html>..."
			t5: contents:html: "<html>..."
			t3: contents:html: "<html>..."
		}
		anchor: {
			t9: anchor:cnnsi.com = "CNN"
			t8: anchor:my.look.ca = "CNN.com"
		}
		people: {}
	}
	"com.example.www": {
		contents: {
			t5: contents:html: "<html>..."
		}
		anchor: {}
		people: {
			t5: people:author: "John Doe"
		}
	}
}        
        ]]></programlisting>

    </section>
    <section
      xml:id="physical.view">
      <title>物理视图</title>
      <para>
          虽然概念视图中表被看做是一个稀疏行的集合，它们在物理上是被按列族存储的。一个新的列限定符（column_family：column_qualifier）可以在任何时候被添加到一个存在的列族中。
          </para>
      <table
        frame="all">
        <title>列族<varname>anchor</varname></title>
        <tgroup
          cols="3"
          align="left"
          colsep="1"
          rowsep="1">
          <colspec
            colname="c1" />
          <colspec
            colname="c2" />
          <colspec
            colname="c3" />
          <thead>
            <row>
              <entry>Row Key</entry>
              <entry>Time Stamp</entry>
              <entry>Column Family <varname>anchor</varname></entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>"com.cnn.www"</entry>
              <entry>t9</entry>
              <entry><varname>anchor:cnnsi.com</varname> = "CNN"</entry>
            </row>
            <row>
              <entry>"com.cnn.www"</entry>
              <entry>t8</entry>
              <entry><varname>anchor:my.look.ca</varname> = "CNN.com"</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <table
        frame="all">
        <title>列族<varname>contents</varname></title>
        <tgroup
          cols="3"
          align="left"
          colsep="1"
          rowsep="1">
          <colspec
            colname="c1" />
          <colspec
            colname="c2" />
          <colspec
            colname="c3" />
          <thead>
            <row>
              <entry>Row Key</entry>
              <entry>Time Stamp</entry>
              <entry>ColumnFamily "contents:"</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>"com.cnn.www"</entry>
              <entry>t6</entry>
              <entry><varname>contents:html</varname> = "&lt;html&gt;..."</entry>
            </row>
            <row>
              <entry>"com.cnn.www"</entry>
              <entry>t5</entry>
              <entry><varname>contents:html</varname> = "&lt;html&gt;..."</entry>
            </row>
            <row>
              <entry>"com.cnn.www"</entry>
              <entry>t3</entry>
              <entry><varname>contents:html</varname> = "&lt;html&gt;..."</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>
          在概念视图中展示的空单元格是不会被存储的。因此对于列<varname>contents:html</varname>在时间戳<literal>t8</literal>的值的请求将不会返回任何值。
          同样的，对于列<varname>anchor:my.look.ca</varname>在时间戳<literal>t9</literal>的值的请求也不会返回任何值。然而，如果没有对应的时间戳，特定咧的最新版本的值将会被返回。给定的多个版本，最新的版本会最先被找到，因为数据是按照时间戳降序存储的。因此一个对行<varname>com.cnn.www</varname>的所有列的值的请求，如果不指定时间戳，那么列<varname>contents:html</varname>将会返回时间戳<literal>t6</literal>对应的值，列<varname>anchor:cnnsi.com</varname>将会返回时间戳<literal>t9</literal>对应的值，列<varname>anchor:my.look.ca</varname>将会返回时间戳<literal>t8</literal>对应的值。
           </para>
      <para>更多关于HBase内部如何存储数据的信息，请参考 <xref
          linkend="regions.arch" />。 </para>
    </section>

    <section
      xml:id="namespace">
      <title>命名空间</title>
      <para>
          在关系数据库系统中，命名空间(namespace)指的是一个表的逻辑分组，同一组中的表有类似的用途。这种抽象是即将到来的多用户相关的特性的基础：
           <itemizedlist>
          <listitem>
            <para>配额(Quota)管理 (HBASE-8410) - 限定命名空间可以使用的资源 (例如 regions、table等
              ) 量。</para>
          </listitem>
          <listitem>
            <para>命名空间安全管理 (HBASE-9206) - 提供对于另一个层面的多用户的安全管理。</para>
          </listitem>
          <listitem>
            <para>Region server组 (HBASE-6721) - 一个命名空间/表可以被固定到一组regionserver上，从而保证了数据隔离性。</para>
          </listitem>
        </itemizedlist>
      </para>
      <section
        xml:id="namespace_creation">
        <title>命名空间管理</title>
        <para> 命名空间可以被创建、移除或更改。表和命名空间的隶属关系在在创建表时决定，通过以下格式指定：
            </para>

        <programlisting language="xml"><![CDATA[<table namespace>:<table qualifier>]]></programlisting>


        <example>
          <title>示例</title>

          <programlisting language="bourne">
#Create a namespace
create_namespace 'my_ns'
            </programlisting>
          <programlisting language="bourne">
#create my_table in my_ns namespace
create 'my_ns:my_table', 'fam'
          </programlisting>
          <programlisting language="bourne">
#drop namespace
drop_namespace 'my_ns'
          </programlisting>
          <programlisting language="bourne">
#alter namespace
alter_namespace 'my_ns', {METHOD => 'set', 'PROPERTY_NAME' => 'PROPERTY_VALUE'}
        </programlisting>
        </example>
      </section>
      <section
        xml:id="namespace_special">
        <title>预定义的命名空间</title>
        <para> 有两个系统内置的预定义的特殊命名空间： </para>
        <itemizedlist>
          <listitem>
            <para>hbase - 系统命名空间，用于包含hbase的内部表</para>
          </listitem>
          <listitem>
            <para>default - 所有未指定命名空间的表都自动进入该命名空间</para>
          </listitem>
        </itemizedlist>
        <example>
          <title>示例</title>

          <programlisting language="bourne">
#namespace=foo and table qualifier=bar
create 'foo:bar', 'fam'

#namespace=default and table qualifier=bar
create 'bar', 'fam'
</programlisting>
        </example>
      </section>
    </section>

    <section
      xml:id="table">
      <title>表</title>
      <para> 表是在schema声明的时候定义的。 </para>
    </section>

    <section
      xml:id="row">
      <title>行</title>
      <para>
          行键是不可分割的字节数组。行按字典排序，由低到高存储在表中。一个空的字节数组被用来表示某张表命名空间的起始和结束。
          </para>
    </section>

    <section
      xml:id="columnfamily">
      <title>列族<indexterm><primary>列族</primary></indexterm></title>
      <para>
         Apache HBase按照<emphasis>列族</emphasis>来组织列。 同一个列族的所有列有相同的前缀。例如，列<emphasis>courses:history</emphasis>和 <emphasis>courses:math</emphasis>都是列族<emphasis>courses</emphasis>的成员。冒号(<literal>:</literal>)用来分隔列族和列限定符。列的前缀（列族）必须由可打印的字符组成。
          剩下的部分（列限定符）可以由任意的字节数组组成。列族必须在创建表的时候声明，列限定符就不用了，随时可以进行添加。
          </para>
      <para>在物理上，一个列族的所有成员在文件系统上被存储在一起。因为所有针对存储的优化都是列族级别的，所有的列族成员有相同的访问模式和规模特性。
          </para>

    </section>
    <section
      xml:id="cells">
      <title>单元格<indexterm><primary>Cells</primary></indexterm></title>
      <para>一个 <emphasis>{row, column, version} </emphasis>元组指定了HBase中的一个
          <literal>cell</literal>。 单元格内容是一个不可分割的字节数组。</para>
    </section>
    <section
      xml:id="data_model_operations">
      <title>数据模型操作</title>
      <para>有四个主要的数据模式：Get、Put、Scan和Delete. 通过 <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html">HTable</link>
        实例来进行操作。 </para>
      <section
        xml:id="get">
        <title>Get</title>
        <para><link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html">Get</link>
          返回特定行的属性。 Get通过 <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#get%28org.apache.hadoop.hbase.client.Get%29">
            HTable.get</link>来执行。 </para>
      </section>
      <section
        xml:id="put">
        <title>Put</title>
        <para><link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Put.html">Put</link>
          要么给表添加新的行(如果是新的行键)，要么更新一个存在的行(如果行键已经存在)。 Put通过 <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#put%28org.apache.hadoop.hbase.client.Put%29">
            HTable.put</link> (写缓冲区)或者 <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#batch%28java.util.List%29">
            HTable.batch</link> (不写缓冲区)来执行。 </para>
      </section>
      <section
        xml:id="scan">
        <title>Scans</title>
        <para><link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html">Scan</link>
          允许遍历多行指定的属性。 </para>
        <para>
            下面是一个表的HTable的例子。假设一个表有几个使用行键"row1"、"row2"和"row3"的行，还有其他一些使用行键"abc1"、"abc2"和"abc3"的行。下面的例子展示了
            如何在Scan中应用起始行键和结束行键来返回行键以"row"开始的那些行。
            </para>
        <programlisting language="java">
public static final byte[] CF = "cf".getBytes();
public static final byte[] ATTR = "attr".getBytes();
...

HTable htable = ...      // instantiate HTable

Scan scan = new Scan();
scan.addColumn(CF, ATTR);
scan.setStartRow(Bytes.toBytes("row")); // start key is inclusive
scan.setStopRow(Bytes.toBytes("rox"));  // stop key is exclusive
ResultScanner rs = htable.getScanner(scan);
try {
  for (Result r = rs.next(); r != null; r = rs.next()) {
  // process result...
} finally {
  rs.close();  // always close the ResultScanner!
}
</programlisting>
        <para>
            注意：通过最容易的方式是使用<link
                xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/InclusiveStopFilter.html">InclusiveStopFilter</link>类对scan指定一个特殊的结束点。 </para>
      </section>
      <section
        xml:id="delete">
        <title>Delete</title>
        <para><link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Delete.html">Delete</link>
          从一个表中删除一行。 Delete通过 <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#delete%28org.apache.hadoop.hbase.client.Delete%29">
            HTable.delete</link>来执行。 </para>
        <para>HBase不会直接在数据保存的地方修改数据，因此它通过创建一个被称为<emphasis>墓碑(tombstones)</emphasis>的标记来标识数据的删除。
            这些墓碑和那些被删除的值，会在major压缩的时候进行彻底清除。 </para>
        <para>查看 <xref
            linkend="version.delete" /> 以便获取更多关于删除列的某一版本的信息，查看<xref
            linkend="compaction" /> 可以获取更多关于压缩的信息。 </para>

      </section>

    </section>


    <section
      xml:id="versions">
      <title>版本<indexterm><primary>版本</primary></indexterm></title>

      <para>一个 <emphasis>{row, column, version} </emphasis>元组指定了一个HBase
          <literal>cell</literal> 。 可能会有一些单元格的行和列都是相同的，它们仅有的不同就是它们的版本。</para>

      <para>
          行和列用字节数组表示，版本号用长整型表示。这个长整型使用<code>java.util.Date.getTime()</code>或者<code>System.currentTimeMillis()</code>来获取。
          也就是说，<quote>是当前时间和
          January 1, 1970 UTC 的时间差，单位是毫秒</quote>。
          </para>

      <para>HBase版本按照降序存储。因此当读取一个store file文件，最新的值将最先被找到。</para>

      <para>有些人可能会对HBase中 <literal>cell</literal> 版本的含义有疑惑。一些常见的问题如下：</para>
      <itemizedlist>
        <listitem>
          <para>如果对一个单元格有相同版本的多次写入，是所有的版本都被保留还是只保留最后的那个？<footnote>
              <para>目前，仅仅最后的写入可以被获取。</para>
            </footnote></para>
        </listitem>

        <listitem>
          <para>可以以非递增的版本顺序对单元格写入数据吗？<footnote>
              <para>可以</para>
            </footnote></para>
        </listitem>
      </itemizedlist>

      <para>下面我们将描述HBase当前的版本是如何工作的。<footnote>
          <para>参考 <link
              xlink:href="https://issues.apache.org/jira/browse/HBASE-2406">HBASE-2406</link> 对HBase版本的讨论。 <link
              xlink:href="http://outerthought.org/blog/417-ot.html">Bending time in HBase</link>
            也对HBase中的版本或者时间戳做了一个很好的论述。它提供了比这里更多的有关版本的细节信息。截止本文撰写时，文章中提及的关于HBase的 <emphasis>覆盖已经存在版本的值</emphasis> 的问题已经不存在了。本节是Bruno Dumon文章的一个基本概要。 </para>
        </footnote>.</para>

      <section
        xml:id="versions.ops">
        <title>版本和HBase操作</title>

        <para>在本节中我们看一下每一个HBase核心操作中有关版本的行为。</para>

        <section>
          <title>Get/Scan</title>

          <para>Get在Scan的基础上实现。下面关于 <link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html">Get</link>
            的讨论同样适用于 <link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html">Scans</link>。</para>

          <para>默认情况下，例如，如果你没有显示的指定版本，当你执行一个
              <literal>get</literal>操作， 那个最近的版本的值将会被返回（是不是最后被写入的，请看后面）。默认的行为可以按如下方式修改：</para>

          <itemizedlist>
            <listitem>
              <para>为了返回不止一个版本，请参考 <link
                  xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html#setMaxVersions()">Get.setMaxVersions()</link></para>
            </listitem>

            <listitem>
              <para>为了返回非最近的版本，请参考 <link
                  xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html#setTimeRange(long, long)">Get.setTimeRange()</link></para>

              <para>
                  为了查询小于或等于给定的值的最新版本，需要给定一个确定的时间点的记录的“最新”的状态​​，只需要将范围设置成0～你期望版本，并将最大版本设置为1。在，只是使用范围从0到期望的版本，并设置最大版本为1。
                  </para>
            </listitem>
          </itemizedlist>

        </section>
        <section
          xml:id="default_get_example">
          <title>默认的Get示例</title>
          <para>下面的Get操作将仅仅检索某一行的当前版本。</para>
          <programlisting language="java">
public static final byte[] CF = "cf".getBytes();
public static final byte[] ATTR = "attr".getBytes();
...
Get get = new Get(Bytes.toBytes("row1"));
Result r = htable.get(get);
byte[] b = r.getValue(CF, ATTR);  // returns current version of value
</programlisting>
        </section>
        <section
          xml:id="versioned_get_example">
          <title>有版本的Get示例</title>
          <para>西面的Get操作将返回某一行的最近的3个版本。</para>
          <programlisting language="java">
public static final byte[] CF = "cf".getBytes();
public static final byte[] ATTR = "attr".getBytes();
...
Get get = new Get(Bytes.toBytes("row1"));
get.setMaxVersions(3);  // will return last 3 versions of row
Result r = htable.get(get);
byte[] b = r.getValue(CF, ATTR);  // returns current version of value
List&lt;KeyValue&gt; kv = r.getColumn(CF, ATTR);  // returns all versions of this column
</programlisting>
        </section>

        <section>
          <title>Put</title>

          <para>执行Put操作总是会在一个确定的时间戳创建一个<literal>cell</literal>的新版本。系统默认使用服务器的<literal>currentTimeMillis</literal>，
              但是你可以在每一个列级别指定你自己的版本（=长整型）。这意味着你可以分配一个过去或未来的时间，或者使用一个长整型数值。</para>

          <para>为了覆盖一个已经存在的值，你只需要在put操作时将你想覆盖的单元格的行键和列，以及版本号保持和原来相同即可。</para>
          <section
            xml:id="implicit_version_example">
            <title>不指明版本的例子</title>
            <para>下面的Put操作将不指明版本号，而是使用系统的当前时间。</para>
            <programlisting language="java">
public static final byte[] CF = "cf".getBytes();
public static final byte[] ATTR = "attr".getBytes();
...
Put put = new Put(Bytes.toBytes(row));
put.add(CF, ATTR, Bytes.toBytes( data));
htable.put(put);
</programlisting>
          </section>
          <section
            xml:id="explicit_version_example">
            <title>指明版本号的例子</title>
            <para>下面的Put操作将指明版本号。</para>
            <programlisting language="java">
public static final byte[] CF = "cf".getBytes();
public static final byte[] ATTR = "attr".getBytes();
...
Put put = new Put( Bytes.toBytes(row));
long explicitTimeInMs = 555;  // just an example
put.add(CF, ATTR, explicitTimeInMs, Bytes.toBytes(data));
htable.put(put);
</programlisting>
            <para>
                注意：HBase内部使用的版本时间戳是实时计算的。最好避免自己设置时间戳。请选择使用该行的独立的时间戳属性，或者将时间戳作为行键的一部分，或者两个一起选择。
                </para>
          </section>

        </section>

        <section
          xml:id="version.delete">
          <title>Delete</title>

          <para>
              有三种不同类型的内部删除标记<footnote>参考Lars Hofhansl博客中关于它尝试添加另一个的讨论<link
                  xlink:href="http://hadoop-hbase.blogspot.com/2012/01/scanning-in-hbase.html">Scanning
              in HBase: Prefix Delete Marker</link>。</footnote>： </para>
          <itemizedlist>
            <listitem>
              <para>Delete: 删除列的指定版本。</para>
            </listitem>
            <listitem>
              <para>Delete column: 删除列的所有版本。</para>
            </listitem>
            <listitem>
              <para>Delete family: 删除特定列族的所有列。</para>
            </listitem>
          </itemizedlist>
          <para>
              当删除整行时，HBase将会在内部创建一个所有列族（不是每一个单独的列）的墓碑标记。
               </para>
          <para>
              删除操作通过创建一个<emphasis>tombstone</emphasis>标记来实现。例如，假设我们想要删除某一行，你可以指定一个版本，
              或者使用默认的<literal>currentTimeMillis</literal>。这就意味着<quote>删除所有单元格的小于或等于该版本的所有版本的数据</quote>。
              HBase不会直接在数据保存的地方修改数据，因此一个删除操作不会立刻删除文件中那些需要删除（或者标记为删除）的数据。它会写入一个被称为<emphasis>墓碑</emphasis>
              的标记，以此来屏蔽掉那些被删除的值
              <footnote>
              <para>当HBase执行major压缩时，那些有墓碑标记的死亡的值和墓碑标记一起被真正删除。</para>
            </footnote>。
              如果你指定的版本比当前行中所有的版本值都大，那么该行的所有数据都会被删除。</para>
          <para>
              关于如何删除和版本化交互的讨论，可以参考用户邮件列表中的内容 <link
              xlink:href="http://comments.gmane.org/gmane.comp.java.hadoop.hbase.user/28421">Put w/
              timestamp -> Deleteall -> Put w/ timestamp fails</link> 。</para>
          <para>也可以查看 <xref
              linkend="keyvalue" /> 了解更多的关于内部KeyValue格式的信息。 </para>
          <para>
              删除标记在下一次store file文件的major压缩过程中会被完全移除，除非<option>KEEP_DELETED_CELLS</option>选项在列族中被设置。
              为了保证在一个可配置的时间删除数据，你可以通过设置<filename>hbase-site.xml</filename>文件中的<option>hbase.hstore.time.to.purge.deletes</option>属性来设置删除的TTL。该属性如果不设置或者设置为0，那么在major合并期间，含有删除标记的记录将会被完全删除。否则，在major合并期间，那些含有删除标记的记录会在时间（删除标记的时间戳加上<option>hbase.hstore.time.to.purge.deletes</option>值）才会被完全删除。
         </para>
          <note>
            <para>这种行为在HBase 0.94中被引入，之后修复了一些Bug，修复在 <link
                xlink:href="https://issues.apache.org/jira/browse/HBASE-10118">HBASE-10118</link>可以看到。
                这个改变已经在包括在HBase 0.94之后的版本以及它新的分支中。
              </para>
          </note>
        </section>
      </section>

      <section>
        <title>现在的限制</title>

        <section>
          <title>错误的进行了标记删除的操作</title>

          <para>
              标记删除的操作可能会将之后插入(put)的数据也标记上
              <footnote>
              <para><link
              xlink:href="https://issues.apache.org/jira/browse/HBASE-2256">HBASE-2256</link></para>
            </footnote>。当写下一个墓碑标记后，之后在下一个major压缩操作执行期间才会将墓碑标记删除。假设你做了一个删除&lt;= T的时间的数据的操作。然后，你又执行了一个新的Put操作。
              该操作指定的时间戳&lt;= T。那么，即使这个Put发生在之前的删除操作之后，那么它也会被打上墓碑标记。put操作将不会执行失败，但是当你做Get操作的时候，会发现你的Put操作没造成任何影响（即你获取不到你之后Put的那个数据）。只有在major压缩之后，它才会正常。因此，如果你使用一个增加的版本号，那么这个问题不会对你有任何影响。但是即使你不关心时间，该情况也可以会出现。只需要你在删除之后立刻进行了插入操作，那么它们可能在同一毫秒中完成，也就有可能出现这种情况。
              </para>
        </section>

        <section
          xml:id="major.compactions.change.query.results">
          <title>主压缩改变了查询的结果</title>
          
          <para><quote>使用最大的版本数2创建三个单元格的版本t1、t2和t3.因此，当你获取所有的版本时，只有t2和t3的数据能被返回。但是如果你删除了版本t2和t3，t1的数据将会再次出现。显然，
              一旦major压缩被执行，这种行为将不会再次出现。
              <footnote>
              <para>参考文章 <link
                xlink:href="http://outerthought.org/blog/417-ot.html">Bending time in
                HBase</link> 中提到的<emphasis>垃圾收集</emphasis>。
              </para>
            </footnote></quote></para>
        </section>
      </section>
    </section>
    <section xml:id="dm.sort">
      <title>排序</title>
      <para>
          所有HBase的数据模型操作会返回排好序的数据。先是按行，再是按列族，然后是按列限定符(column qualifier), 最后是按时间戳(反向排序,所以最新的记录在最前面被返回)。
      </para>
    </section>
    <section xml:id="dm.column.metadata">
      <title>列的元数据</title>
      <para>
          列族没有保存内部的KeyValue之外的元数据。因此，HBase不仅在一行中支持很多列，而且支持行之间不同的列。跟踪列名由你自己负责。
      </para>
      <para>唯一获取列族的完整列名的方法是处理所有行。关于HBase存储数据的更多信息，请参考 <xref linkend="keyvalue" />。
	  </para>
    </section>
    <section xml:id="joins"><title>Joins</title>
      <para>
          HBase是否支持联合(join)操作是一个常问问题。简单来说 : 不支持。至少不像传统RDBMS那样支持(如SQL中包含equi-join或outer-join)。
          正如本章描述的那样，HBase中通过Get和Scan操作读取数据。
      </para>
      <para>
          但并不表示等价联合(join)不能在你的应用程序中被支持，只是你必须自己实现。 有两种方法，要么指示要写到HBase的数据，
          要么查询表并在你的应用或MapReduce代码(如RDBMS所展示的那样,有几种策略来实现，如嵌套循环(nested loops)和哈希联合(hash-joins)，这依赖于表的大小)做联合操作。 那哪个更好呢？这依赖于你准备做什么，所以没有一个适合所有实例的答案。
      </para>
    </section>
    <section xml:id="acid"><title>ACID</title>
        <para>参考 <link xlink:href="http://hbase.apache.org/acid-semantics.html">ACID Semantics</link>。
            Lars Hofhansl也写了一篇相关的文章
            <link xlink:href="http://hadoop-hbase.blogspot.com/2012/03/acid-in-hbase.html">ACID in HBase</link>。</para>
    </section>
  </chapter>  <!-- data model -->

  <!--  schema design -->
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="schema_design.xml"/>

  <chapter
    xml:id="mapreduce">
    <title>HBase和MapReduce</title>
    <para>Apache MapReduce是一个用来分析大数据的框架，并且最常用的是<link
            xlink:href="http://hadoop.apache.org/">Apache Hadoop</link> 。 MapReduce本身超出了本文档的范围。有一个开始学习MapReduce的好地方
         <link
        xlink:href="http://hadoop.apache.org/docs/r1.2.1/mapred_tutorial.html" />。 MapReduce 第二版
      (MR2)现在是 <link
        xlink:href="http://hadoop.apache.org/docs/r2.3.0/hadoop-yarn/hadoop-yarn-site/">YARN</link> 的一部分。 </para>

    <para> 本章讨论你在HBase存储的数据上使用MapReduce的一些特定的配置步骤。另外，还讨论其他HBase和MapReduce任务的交互和问题。
      <note> 
      <title>mapred和mapreduce</title>
      <para>HBase中有两个自己的mapreduce包： <filename>org.apache.hadoop.hbase.mapred</filename>
      和 <filename>org.apache.hadoop.hbase.mapreduce</filename>。 前者基于旧风格的API，后者基于新风格的API。 虽然你可以在旧包中找到一些和新包相同的功能，但是新报中包含更多的功能。
          选一个和你部署的mapreduce相同的包。如果有疑问或者重新开始，选择<filename>org.apache.hadoop.hbase.mapreduce</filename>。
          在下面的说明中，我们选择o.a.h.h.mapreduce，但是如果你在用o.a.h.h.mapred，也可以用o.a.h.h.mapred进行替换。
      </para>
      </note> 
    </para>

    <section
      xml:id="hbase.mapreduce.classpath">
      <title>HBase、MapReduce和CLASSPATH</title>
      <para>默认情况下，部署在MapReduce集群上的MapReduce任务急不能访问HBase在<envar>$HBASE_CONF_DIR</envar>目录下的配置文件还有HBase的类文件。</para>
      <para>
          为了给MapReduce任务它们需要的访问权限，你应该将 <filename>hbase-site.xml</filename>文件添加到 <filename><replaceable>$HADOOP_HOME</replaceable>/conf/</filename> 目录中并且将HBase的jar文件拷贝到 <filename><replaceable>$HADOOP_HOME</replaceable>/conf/</filename> 目录中，然后在整个集群的所有机器上执行这一操作。 你可以添加hbase-site.xml文件到你的$HADOOP_HOME/conf
          ，将HBase的jar文件添加到$HADOOP_HOME/lib目录中，或者在<filename><replaceable>$HADOOP_HOME</replaceable>conf/hadoop-env.sh</filename>文件中添加那些文件的路径到<envar>HADOOP_CLASSPATH</envar>变量。你需要在集群的所有机器上执行这一操作。然而，不推荐这种方法，因为它会污染你的Hadoop的安装与HBase的引用。它还要求你在Hadoop使用HBase的数据前重新启动Hadoop集群。
    </para>
      <para>
          从HBase 0.90.x开始，HBase自己会添加作业依赖的jar文件。只需要将这些依赖放在本地CLASSPATH中。下面的例子在名为<systemitem>usertable</systemitem>的表上运行HBase提供的名为
          <link
                  xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/RowCounter.html">RowCounter</link> 的MapReduce任务。
          如果你还没有设置需要的那些环境变量（由<literal>$</literal>符号和大括号组成的前缀部分），你可以用真实的系统路径替代。请务必在你的系统中使用HBase的JAR文件的正确版本，
          反引号(<literal>`</literal> 符号)括起来的部分是一个执行的shel命令的子命令，设置CLASSPATH作为命令的一部分。本示例假定你使用与bash兼容的shell。
           </para>
      <screen language="bourne">$ <userinput>HADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase classpath` ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-0.90.0.jar rowcounter usertable</userinput></screen>
      <para>
          当命令运行时，在内部，HBase的JAR通过 <envar>HADOOP_CLASSPATH</envar> 找到它需要的zookeeper，guava，以及其他依赖包，并且将这些依赖包增加到MapReduce配置中。可以查看TableMapReduceUtil#addDependencyJars(org.apache.hadoop.mapreduce.Job)的源文件，了解这一切是如何完成的。
     </para>
      <note>
        <para>
            如果你是从构建目录而不是安装位置运行HBase的化，这个例子可能无法正常工作。你可能会看到类似下面的错误：
            </para>
        <screen>java.lang.RuntimeException: java.lang.ClassNotFoundException: org.apache.hadoop.hbase.mapreduce.RowCounter$RowCounterMapper</screen>
        <para>
            如果发生这种情况，请尝试对命令做如下修改，以便它可以使用生成环境中的<filename>target/</filename>目录下HBase的JAR文件。
        </para>
        <screen language="bourne">$ <userinput>HADOOP_CLASSPATH=${HBASE_HOME}/target/hbase-0.90.0-SNAPSHOT.jar:`${HBASE_HOME}/bin/hbase classpath` ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/target/hbase-0.90.0-SNAPSHOT.jar rowcounter usertable</userinput></screen>
      </note>
      <caution>
        <title>注意Mapreduce使用HBase 0.96.1和更高版本</title>
        <para>
            使用HBase的一些MapReduce任务无法启动。出现了类似以下内容的异常：
            </para>
        <screen>
Exception in thread "main" java.lang.IllegalAccessError: class
    com.google.protobuf.ZeroCopyLiteralByteString cannot access its superclass
    com.google.protobuf.LiteralByteString
    at java.lang.ClassLoader.defineClass1(Native Method)
    at java.lang.ClassLoader.defineClass(ClassLoader.java:792)
    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
    at java.net.URLClassLoader.defineClass(URLClassLoader.java:449)
    at java.net.URLClassLoader.access$100(URLClassLoader.java:71)
    at java.net.URLClassLoader$1.run(URLClassLoader.java:361)
    at java.net.URLClassLoader$1.run(URLClassLoader.java:355)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.net.URLClassLoader.findClass(URLClassLoader.java:354)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
    at
    org.apache.hadoop.hbase.protobuf.ProtobufUtil.toScan(ProtobufUtil.java:818)
    at
    org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.convertScanToString(TableMapReduceUtil.java:433)
    at
    org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.initTableMapperJob(TableMapReduceUtil.java:186)
    at
    org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.initTableMapperJob(TableMapReduceUtil.java:147)
    at
    org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.initTableMapperJob(TableMapReduceUtil.java:270)
    at
    org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.initTableMapperJob(TableMapReduceUtil.java:100)
...
</screen>
        <para>
            这是因为一个优化操作 <link
                xlink:href="https://issues.apache.org/jira/browse/HBASE-9867">HBASE-9867</link> 引入的bug，它在不经意间引入了一个类加载器依赖。
             </para>
        <para>
            这会影响同时使用-libjars选项和"fat jar"的那些任务，那些包在运行时依赖于<code>lib</code>文件夹中的嵌套文件。
        </para>
        <para>
            为了满足新的类加载器的要求， 必须在Hadoop的类路径(classpath)中引入hbase-protocol.jar文件。可以参考<xref
                linkend="hbase.mapreduce.classpath" /> 来查看针对一些类路径错误的一些推荐的解决方案。紧接着是因为历史目的才包含在内的。
        </para>
        <para>
            可以通过在hadoop的lib目录下建立hbase-protocol.jar的引用或者拷贝hbase-protocol.jar文件到新目录来解决这个问题。
            </para>
        <para>
            也可以在每一个任务启动时在它的<code>HADOOP_CLASSPATH</code>环境变量中加入hbase-protocol.jar文件文件来解决该问题。
            当需要启动的任务包含了自己的依赖，有3种命令可以解决这个需求：
            </para>
        <screen language="bourne">
$ <userinput>HADOOP_CLASSPATH=/path/to/hbase-protocol.jar:/path/to/hbase/conf hadoop jar MyJob.jar MyJobMainClass</userinput>
$ <userinput>HADOOP_CLASSPATH=$(hbase mapredcp):/path/to/hbase/conf hadoop jar MyJob.jar MyJobMainClass</userinput>
$ <userinput>HADOOP_CLASSPATH=$(hbase classpath) hadoop jar MyJob.jar MyJobMainClass</userinput>
        </screen>
        <para>
            对于那些jar文件中没包含需要依赖的，下面的命令是必须的：
            </para>
        <screen language="bourne">
$ <userinput>HADOOP_CLASSPATH=$(hbase mapredcp):/etc/hbase/conf hadoop jar MyApp.jar MyJobMainClass -libjars $(hbase mapredcp | tr ':' ',')</userinput> ...
        </screen>
        <para>可以参考 <link
            xlink:href="https://issues.apache.org/jira/browse/HBASE-10304">HBASE-10304</link> 来查看关于这些问题的更多讨论。</para>
      </caution>
    </section>


    <section>
      <title>HBase自带的MapReduce任务</title>
      <para>The HBase JAR also serves as a Driver for some bundled mapreduce jobs. To learn about
        the bundled MapReduce jobs, run the following command.</para>

      <screen language="bourne">$ <userinput>${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-0.90.0-SNAPSHOT.jar</userinput>
<computeroutput>An example program must be given as the first argument.
Valid program names are:
  copytable: Export a table from local cluster to peer cluster
  completebulkload: Complete a bulk data load.
  export: Write table data to HDFS.
  import: Import data written by Export.
  importtsv: Import data in TSV format.
  rowcounter: Count rows in HBase table</computeroutput>
    </screen>
      <para>Each of the valid program names are bundled MapReduce jobs. To run one of the jobs,
        model your command after the following example.</para>
      <screen language="bourne">$ <userinput>${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-0.90.0-SNAPSHOT.jar rowcounter myTable</userinput></screen>
    </section>

    <section>
      <title>HBase as a MapReduce Job Data Source and Data Sink</title>
      <para>HBase can be used as a data source, <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableInputFormat.html">TableInputFormat</link>,
        and data sink, <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableOutputFormat.html">TableOutputFormat</link>
        or <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/MultiTableOutputFormat.html">MultiTableOutputFormat</link>,
        for MapReduce jobs. Writing MapReduce jobs that read or write HBase, it is advisable to
        subclass <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableMapper.html">TableMapper</link>
        and/or <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableReducer.html">TableReducer</link>.
        See the do-nothing pass-through classes <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/IdentityTableMapper.html">IdentityTableMapper</link>
        and <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/IdentityTableReducer.html">IdentityTableReducer</link>
        for basic usage. For a more involved example, see <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/RowCounter.html">RowCounter</link>
        or review the <code>org.apache.hadoop.hbase.mapreduce.TestTableMapReduce</code> unit test. </para>
      <para>If you run MapReduce jobs that use HBase as source or sink, need to specify source and
        sink table and column names in your configuration.</para>

      <para>When you read from HBase, the <code>TableInputFormat</code> requests the list of regions
        from HBase and makes a map, which is either a <code>map-per-region</code> or
          <code>mapreduce.job.maps</code> map, whichever is smaller. If your job only has two maps,
        raise <code>mapreduce.job.maps</code> to a number greater than the number of regions. Maps
        will run on the adjacent TaskTracker if you are running a TaskTracer and RegionServer per
        node. When writing to HBase, it may make sense to avoid the Reduce step and write back into
        HBase from within your map. This approach works when your job does not need the sort and
        collation that MapReduce does on the map-emitted data. On insert, HBase 'sorts' so there is
        no point double-sorting (and shuffling data around your MapReduce cluster) unless you need
        to. If you do not need the Reduce, you myour map might emit counts of records processed for
        reporting at the end of the jobj, or set the number of Reduces to zero and use
        TableOutputFormat. If running the Reduce step makes sense in your case, you should typically
        use multiple reducers so that load is spread across the HBase cluster.</para>

      <para>A new HBase partitioner, the <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/HRegionPartitioner.html">HRegionPartitioner</link>,
        can run as many reducers the number of existing regions. The HRegionPartitioner is suitable
        when your table is large and your upload will not greatly alter the number of existing
        regions upon completion. Otherwise use the default partitioner. </para>
    </section>

    <section>
      <title>Writing HFiles Directly During Bulk Import</title>
      <para>If you are importing into a new table, you can bypass the HBase API and write your
        content directly to the filesystem, formatted into HBase data files (HFiles). Your import
        will run faster, perhaps an order of magnitude faster. For more on how this mechanism works,
        see <xref
          linkend="arch.bulk.load" />.</para>
    </section>

    <section>
      <title>RowCounter Example</title>
      <para>The included <link
        xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/RowCounter.html">RowCounter</link>
        MapReduce job uses <code>TableInputFormat</code> and does a count of all rows in the specified
        table. To run it, use the following command: </para>
      <screen language="bourne">$ <userinput>./bin/hadoop jar hbase-X.X.X.jar</userinput></screen> 
      <para>This will
        invoke the HBase MapReduce Driver class. Select <literal>rowcounter</literal> from the choice of jobs
        offered. This will print rowcouner usage advice to standard output. Specify the tablename,
        column to count, and output
        directory. If you have classpath errors, see <xref linkend="hbase.mapreduce.classpath" />.</para>
    </section>

    <section
      xml:id="splitter">
      <title>Map-Task Splitting</title>
      <section
        xml:id="splitter.default">
        <title>The Default HBase MapReduce Splitter</title>
        <para>When <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableInputFormat.html">TableInputFormat</link>
          is used to source an HBase table in a MapReduce job, its splitter will make a map task for
          each region of the table. Thus, if there are 100 regions in the table, there will be 100
          map-tasks for the job - regardless of how many column families are selected in the
          Scan.</para>
      </section>
      <section
        xml:id="splitter.custom">
        <title>Custom Splitters</title>
        <para>For those interested in implementing custom splitters, see the method
            <code>getSplits</code> in <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableInputFormatBase.html">TableInputFormatBase</link>.
          That is where the logic for map-task assignment resides. </para>
      </section>
    </section>
    <section
      xml:id="mapreduce.example">
      <title>HBase MapReduce Examples</title>
      <section
        xml:id="mapreduce.example.read">
        <title>HBase MapReduce Read Example</title>
        <para>The following is an example of using HBase as a MapReduce source in read-only manner.
          Specifically, there is a Mapper instance but no Reducer, and nothing is being emitted from
          the Mapper. There job would be defined as follows...</para>
        <programlisting language="java">
Configuration config = HBaseConfiguration.create();
Job job = new Job(config, "ExampleRead");
job.setJarByClass(MyReadJob.class);     // class that contains mapper

Scan scan = new Scan();
scan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs
scan.setCacheBlocks(false);  // don't set to true for MR jobs
// set other scan attrs
...

TableMapReduceUtil.initTableMapperJob(
  tableName,        // input HBase table name
  scan,             // Scan instance to control CF and attribute selection
  MyMapper.class,   // mapper
  null,             // mapper output key
  null,             // mapper output value
  job);
job.setOutputFormatClass(NullOutputFormat.class);   // because we aren't emitting anything from mapper

boolean b = job.waitForCompletion(true);
if (!b) {
  throw new IOException("error with job!");
}
  </programlisting>
        <para>...and the mapper instance would extend <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableMapper.html">TableMapper</link>...</para>
        <programlisting language="java">
public static class MyMapper extends TableMapper&lt;Text, Text&gt; {

  public void map(ImmutableBytesWritable row, Result value, Context context) throws InterruptedException, IOException {
    // process data for the row from the Result instance.
   }
}
    </programlisting>
      </section>
      <section
        xml:id="mapreduce.example.readwrite">
        <title>HBase MapReduce Read/Write Example</title>
        <para>The following is an example of using HBase both as a source and as a sink with
          MapReduce. This example will simply copy data from one table to another.</para>
        <programlisting language="java">
Configuration config = HBaseConfiguration.create();
Job job = new Job(config,"ExampleReadWrite");
job.setJarByClass(MyReadWriteJob.class);    // class that contains mapper

Scan scan = new Scan();
scan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs
scan.setCacheBlocks(false);  // don't set to true for MR jobs
// set other scan attrs

TableMapReduceUtil.initTableMapperJob(
	sourceTable,      // input table
	scan,	          // Scan instance to control CF and attribute selection
	MyMapper.class,   // mapper class
	null,	          // mapper output key
	null,	          // mapper output value
	job);
TableMapReduceUtil.initTableReducerJob(
	targetTable,      // output table
	null,             // reducer class
	job);
job.setNumReduceTasks(0);

boolean b = job.waitForCompletion(true);
if (!b) {
    throw new IOException("error with job!");
}
    </programlisting>
        <para>An explanation is required of what <classname>TableMapReduceUtil</classname> is doing,
          especially with the reducer. <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableOutputFormat.html">TableOutputFormat</link>
          is being used as the outputFormat class, and several parameters are being set on the
          config (e.g., TableOutputFormat.OUTPUT_TABLE), as well as setting the reducer output key
          to <classname>ImmutableBytesWritable</classname> and reducer value to
            <classname>Writable</classname>. These could be set by the programmer on the job and
          conf, but <classname>TableMapReduceUtil</classname> tries to make things easier.</para>
        <para>The following is the example mapper, which will create a <classname>Put</classname>
          and matching the input <classname>Result</classname> and emit it. Note: this is what the
          CopyTable utility does. </para>
        <programlisting language="java">
public static class MyMapper extends TableMapper&lt;ImmutableBytesWritable, Put&gt;  {

	public void map(ImmutableBytesWritable row, Result value, Context context) throws IOException, InterruptedException {
		// this example is just copying the data from the source table...
   		context.write(row, resultToPut(row,value));
   	}

  	private static Put resultToPut(ImmutableBytesWritable key, Result result) throws IOException {
  		Put put = new Put(key.get());
 		for (KeyValue kv : result.raw()) {
			put.add(kv);
		}
		return put;
   	}
}
    </programlisting>
        <para>There isn't actually a reducer step, so <classname>TableOutputFormat</classname> takes
          care of sending the <classname>Put</classname> to the target table. </para>
        <para>This is just an example, developers could choose not to use
            <classname>TableOutputFormat</classname> and connect to the target table themselves.
        </para>
      </section>
      <section
        xml:id="mapreduce.example.readwrite.multi">
        <title>HBase MapReduce Read/Write Example With Multi-Table Output</title>
        <para>TODO: example for <classname>MultiTableOutputFormat</classname>. </para>
      </section>
      <section
        xml:id="mapreduce.example.summary">
        <title>HBase MapReduce Summary to HBase Example</title>
        <para>The following example uses HBase as a MapReduce source and sink with a summarization
          step. This example will count the number of distinct instances of a value in a table and
          write those summarized counts in another table.
          <programlisting language="java">
Configuration config = HBaseConfiguration.create();
Job job = new Job(config,"ExampleSummary");
job.setJarByClass(MySummaryJob.class);     // class that contains mapper and reducer

Scan scan = new Scan();
scan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs
scan.setCacheBlocks(false);  // don't set to true for MR jobs
// set other scan attrs

TableMapReduceUtil.initTableMapperJob(
	sourceTable,        // input table
	scan,               // Scan instance to control CF and attribute selection
	MyMapper.class,     // mapper class
	Text.class,         // mapper output key
	IntWritable.class,  // mapper output value
	job);
TableMapReduceUtil.initTableReducerJob(
	targetTable,        // output table
	MyTableReducer.class,    // reducer class
	job);
job.setNumReduceTasks(1);   // at least one, adjust as required

boolean b = job.waitForCompletion(true);
if (!b) {
	throw new IOException("error with job!");
}
    </programlisting>
          In this example mapper a column with a String-value is chosen as the value to summarize
          upon. This value is used as the key to emit from the mapper, and an
            <classname>IntWritable</classname> represents an instance counter.
          <programlisting language="java">
public static class MyMapper extends TableMapper&lt;Text, IntWritable&gt;  {
	public static final byte[] CF = "cf".getBytes();
	public static final byte[] ATTR1 = "attr1".getBytes();

	private final IntWritable ONE = new IntWritable(1);
   	private Text text = new Text();

   	public void map(ImmutableBytesWritable row, Result value, Context context) throws IOException, InterruptedException {
        	String val = new String(value.getValue(CF, ATTR1));
          	text.set(val);     // we can only emit Writables...

        	context.write(text, ONE);
   	}
}
    </programlisting>
          In the reducer, the "ones" are counted (just like any other MR example that does this),
          and then emits a <classname>Put</classname>.
          <programlisting language="java">
public static class MyTableReducer extends TableReducer&lt;Text, IntWritable, ImmutableBytesWritable&gt;  {
	public static final byte[] CF = "cf".getBytes();
	public static final byte[] COUNT = "count".getBytes();

 	public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException {
    		int i = 0;
    		for (IntWritable val : values) {
    			i += val.get();
    		}
    		Put put = new Put(Bytes.toBytes(key.toString()));
    		put.add(CF, COUNT, Bytes.toBytes(i));

    		context.write(null, put);
   	}
}
    </programlisting>
        </para>
      </section>
      <section
        xml:id="mapreduce.example.summary.file">
        <title>HBase MapReduce Summary to File Example</title>
        <para>This very similar to the summary example above, with exception that this is using
          HBase as a MapReduce source but HDFS as the sink. The differences are in the job setup and
          in the reducer. The mapper remains the same. </para>
        <programlisting language="java">
Configuration config = HBaseConfiguration.create();
Job job = new Job(config,"ExampleSummaryToFile");
job.setJarByClass(MySummaryFileJob.class);     // class that contains mapper and reducer

Scan scan = new Scan();
scan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs
scan.setCacheBlocks(false);  // don't set to true for MR jobs
// set other scan attrs

TableMapReduceUtil.initTableMapperJob(
	sourceTable,        // input table
	scan,               // Scan instance to control CF and attribute selection
	MyMapper.class,     // mapper class
	Text.class,         // mapper output key
	IntWritable.class,  // mapper output value
	job);
job.setReducerClass(MyReducer.class);    // reducer class
job.setNumReduceTasks(1);    // at least one, adjust as required
FileOutputFormat.setOutputPath(job, new Path("/tmp/mr/mySummaryFile"));  // adjust directories as required

boolean b = job.waitForCompletion(true);
if (!b) {
	throw new IOException("error with job!");
}
    </programlisting>
        <para>As stated above, the previous Mapper can run unchanged with this example. As for the
          Reducer, it is a "generic" Reducer instead of extending TableMapper and emitting
          Puts.</para>
        <programlisting language="java">
 public static class MyReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;  {

	public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException {
		int i = 0;
		for (IntWritable val : values) {
			i += val.get();
		}
		context.write(key, new IntWritable(i));
	}
}
    </programlisting>
      </section>
      <section
        xml:id="mapreduce.example.summary.noreducer">
        <title>HBase MapReduce Summary to HBase Without Reducer</title>
        <para>It is also possible to perform summaries without a reducer - if you use HBase as the
          reducer. </para>
        <para>An HBase target table would need to exist for the job summary. The HTable method
            <code>incrementColumnValue</code> would be used to atomically increment values. From a
          performance perspective, it might make sense to keep a Map of values with their values to
          be incremeneted for each map-task, and make one update per key at during the <code>
            cleanup</code> method of the mapper. However, your milage may vary depending on the
          number of rows to be processed and unique keys. </para>
        <para>In the end, the summary results are in HBase. </para>
      </section>
      <section
        xml:id="mapreduce.example.summary.rdbms">
        <title>HBase MapReduce Summary to RDBMS</title>
        <para>Sometimes it is more appropriate to generate summaries to an RDBMS. For these cases,
          it is possible to generate summaries directly to an RDBMS via a custom reducer. The
            <code>setup</code> method can connect to an RDBMS (the connection information can be
          passed via custom parameters in the context) and the cleanup method can close the
          connection. </para>
        <para>It is critical to understand that number of reducers for the job affects the
          summarization implementation, and you'll have to design this into your reducer.
          Specifically, whether it is designed to run as a singleton (one reducer) or multiple
          reducers. Neither is right or wrong, it depends on your use-case. Recognize that the more
          reducers that are assigned to the job, the more simultaneous connections to the RDBMS will
          be created - this will scale, but only to a point. </para>
        <programlisting language="java">
 public static class MyRdbmsReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;  {

	private Connection c = null;

	public void setup(Context context) {
  		// create DB connection...
  	}

	public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException {
		// do summarization
		// in this example the keys are Text, but this is just an example
	}

	public void cleanup(Context context) {
  		// close db connection
  	}

}
    </programlisting>
        <para>In the end, the summary results are written to your RDBMS table/s. </para>
      </section>

    </section>
    <!--  mr examples -->
    <section
      xml:id="mapreduce.htable.access">
      <title>Accessing Other HBase Tables in a MapReduce Job</title>
      <para>Although the framework currently allows one HBase table as input to a MapReduce job,
        other HBase tables can be accessed as lookup tables, etc., in a MapReduce job via creating
        an HTable instance in the setup method of the Mapper.
        <programlisting language="java">public class MyMapper extends TableMapper&lt;Text, LongWritable&gt; {
  private HTable myOtherTable;

  public void setup(Context context) {
    myOtherTable = new HTable("myOtherTable");
  }

  public void map(ImmutableBytesWritable row, Result value, Context context) throws IOException, InterruptedException {
	// process Result...
	// use 'myOtherTable' for lookups
  }

  </programlisting>
      </para>
    </section>
    <section
      xml:id="mapreduce.specex">
      <title>Speculative Execution</title>
      <para>It is generally advisable to turn off speculative execution for MapReduce jobs that use
        HBase as a source. This can either be done on a per-Job basis through properties, on on the
        entire cluster. Especially for longer running jobs, speculative execution will create
        duplicate map-tasks which will double-write your data to HBase; this is probably not what
        you want. </para>
      <para>See <xref
          linkend="spec.ex" /> for more information. </para>
    </section>
  </chapter>  <!--  mapreduce -->

  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="security.xml" />

  <chapter xml:id="architecture">
    <title>Architecture</title>
	<section xml:id="arch.overview">
	<title>Overview</title>
	  <section xml:id="arch.overview.nosql">
	  <title>NoSQL?</title>
	  <para>HBase is a type of "NoSQL" database.  "NoSQL" is a general term meaning that the database isn't an RDBMS which
	  supports SQL as its primary access language, but there are many types of NoSQL databases:  BerkeleyDB is an
	  example of a local NoSQL database, whereas HBase is very much a distributed database.  Technically speaking,
	  HBase is really more a "Data Store" than "Data Base" because it lacks many of the features you find in an RDBMS,
	  such as typed columns, secondary indexes, triggers, and advanced query languages, etc.
	  </para>
	  <para>However, HBase has many features which supports both linear and modular scaling.  HBase clusters expand
	  by adding RegionServers that are hosted on commodity class servers. If a cluster expands from 10 to 20
	  RegionServers, for example, it doubles both in terms of storage and as well as processing capacity.
	  RDBMS can scale well, but only up to a point - specifically, the size of a single database server - and for the best
	  performance requires specialized hardware and storage devices.  HBase features of note are:
	        <itemizedlist>
              <listitem><para>Strongly consistent reads/writes:  HBase is not an "eventually consistent" DataStore.  This
              makes it very suitable for tasks such as high-speed counter aggregation.</para>  </listitem>
              <listitem><para>Automatic sharding:  HBase tables are distributed on the cluster via regions, and regions are
              automatically split and re-distributed as your data grows.</para></listitem>
              <listitem><para>Automatic RegionServer failover</para></listitem>
              <listitem><para>Hadoop/HDFS Integration:  HBase supports HDFS out of the box as its distributed file system.</para></listitem>
              <listitem><para>MapReduce:  HBase supports massively parallelized processing via MapReduce for using HBase as both
              source and sink.</para></listitem>
              <listitem><para>Java Client API:  HBase supports an easy to use Java API for programmatic access.</para></listitem>
              <listitem><para>Thrift/REST API:  HBase also supports Thrift and REST for non-Java front-ends.</para></listitem>
              <listitem><para>Block Cache and Bloom Filters:  HBase supports a Block Cache and Bloom Filters for high volume query optimization.</para></listitem>
              <listitem><para>Operational Management:  HBase provides build-in web-pages for operational insight as well as JMX metrics.</para></listitem>
            </itemizedlist>
	  </para>
      </section>

	  <section xml:id="arch.overview.when">
	    <title>When Should I Use HBase?</title>
	    	  <para>HBase isn't suitable for every problem.</para>
	          <para>First, make sure you have enough data.  If you have hundreds of millions or billions of rows, then
	            HBase is a good candidate.  If you only have a few thousand/million rows, then using a traditional RDBMS
	            might be a better choice due to the fact that all of your data might wind up on a single node (or two) and
	            the rest of the cluster may be sitting idle.
	          </para>
	          <para>Second, make sure you can live without all the extra features that an RDBMS provides (e.g., typed columns,
	          secondary indexes, transactions, advanced query languages, etc.)  An application built against an RDBMS cannot be
	          "ported" to HBase by simply changing a JDBC driver, for example.  Consider moving from an RDBMS to HBase as a
	          complete redesign as opposed to a port.
              </para>
	          <para>Third, make sure you have enough hardware.  Even HDFS doesn't do well with anything less than
                5 DataNodes (due to things such as HDFS block replication which has a default of 3), plus a NameNode.
                </para>
                <para>HBase can run quite well stand-alone on a laptop - but this should be considered a development
                configuration only.
                </para>
      </section>
      <section xml:id="arch.overview.hbasehdfs">
        <title>What Is The Difference Between HBase and Hadoop/HDFS?</title>
          <para><link xlink:href="http://hadoop.apache.org/hdfs/">HDFS</link> is a distributed file system that is well suited for the storage of large files.
          Its documentation states that it is not, however, a general purpose file system, and does not provide fast individual record lookups in files.
          HBase, on the other hand, is built on top of HDFS and provides fast record lookups (and updates) for large tables.
          This can sometimes be a point of conceptual confusion.  HBase internally puts your data in indexed "StoreFiles" that exist
          on HDFS for high-speed lookups.  See the <xref linkend="datamodel" /> and the rest of this chapter for more information on how HBase achieves its goals.
         </para>
      </section>
	</section>

    <section
      xml:id="arch.catalog">
      <title>Catalog Tables</title>
      <para>The catalog table <code>hbase:meta</code> exists as an HBase table and is filtered out of the HBase
        shell's <code>list</code> command, but is in fact a table just like any other. </para>
      <section
        xml:id="arch.catalog.root">
        <title>-ROOT-</title>
        <note>
          <para>The <code>-ROOT-</code> table was removed in HBase 0.96.0. Information here should
            be considered historical.</para>
        </note>
        <para>The <code>-ROOT-</code> table kept track of the location of the
            <code>.META</code> table (the previous name for the table now called <code>hbase:meta</code>) prior to HBase
          0.96. The <code>-ROOT-</code> table structure was as follows: </para>
        <itemizedlist>
          <title>Key</title>
          <listitem>
            <para>.META. region key (<code>.META.,,1</code>)</para>
          </listitem>
        </itemizedlist>

        <itemizedlist>
          <title>Values</title>
          <listitem>
            <para><code>info:regioninfo</code> (serialized <link
                xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HRegionInfo.html">HRegionInfo</link>
              instance of hbase:meta)</para>
          </listitem>
          <listitem>
            <para><code>info:server</code> (server:port of the RegionServer holding
              hbase:meta)</para>
          </listitem>
          <listitem>
            <para><code>info:serverstartcode</code> (start-time of the RegionServer process holding
              hbase:meta)</para>
          </listitem>
        </itemizedlist>
      </section>
      <section
        xml:id="arch.catalog.meta">
        <title>hbase:meta</title>
        <para>The <code>hbase:meta</code> table (previously called <code>.META.</code>) keeps a list
          of all regions in the system. The location of <code>hbase:meta</code> was previously
          tracked within the <code>-ROOT-</code> table, but is now stored in Zookeeper.</para>
        <para>The <code>hbase:meta</code> table structure is as follows: </para>
        <itemizedlist>
          <title>Key</title>
          <listitem>
            <para>Region key of the format (<code>[table],[region start key],[region
              id]</code>)</para>
          </listitem>
        </itemizedlist>
        <itemizedlist>
          <title>Values</title>
          <listitem>
            <para><code>info:regioninfo</code> (serialized <link
                xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HRegionInfo.html">
                HRegionInfo</link> instance for this region)</para>
          </listitem>
          <listitem>
            <para><code>info:server</code> (server:port of the RegionServer containing this
              region)</para>
          </listitem>
          <listitem>
            <para><code>info:serverstartcode</code> (start-time of the RegionServer process
              containing this region)</para>
          </listitem>
        </itemizedlist>
        <para>When a table is in the process of splitting, two other columns will be created, called
            <code>info:splitA</code> and <code>info:splitB</code>. These columns represent the two
          daughter regions. The values for these columns are also serialized HRegionInfo instances.
          After the region has been split, eventually this row will be deleted. </para>
        <note>
          <title>Note on HRegionInfo</title>
          <para>The empty key is used to denote table start and table end. A region with an empty
            start key is the first region in a table. If a region has both an empty start and an
            empty end key, it is the only region in the table </para>
        </note>
        <para>In the (hopefully unlikely) event that programmatic processing of catalog metadata is
          required, see the <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/util/Writables.html#getHRegionInfo%28byte[]%29">Writables</link>
          utility. </para>
      </section>
      <section
        xml:id="arch.catalog.startup">
        <title>Startup Sequencing</title>
        <para>First, the location of <code>hbase:meta</code> is looked up in Zookeeper. Next,
          <code>hbase:meta</code> is updated with server and startcode values.</para>  
        <para>For information on region-RegionServer assignment, see <xref
            linkend="regions.arch.assignment" />. </para>
      </section>
    </section>  <!--  catalog -->

    <section
      xml:id="client">
      <title>Client</title>
      <para>The HBase client <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html">HTable</link>
        is responsible for finding RegionServers that are serving the particular row range of
        interest. It does this by querying the <code>hbase:meta</code> table. See <xref
          linkend="arch.catalog.meta" /> for details. After locating the required region(s), the
        client contacts the RegionServer serving that region, rather than going through the master,
        and issues the read or write request. This information is cached in the client so that
        subsequent requests need not go through the lookup process. Should a region be reassigned
        either by the master load balancer or because a RegionServer has died, the client will
        requery the catalog tables to determine the new location of the user region. </para>
      <para>See <xref
          linkend="master.runtime" /> for more information about the impact of the Master on HBase
        Client communication. </para>
      <para>Administrative functions are handled through <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HBaseAdmin.html">HBaseAdmin</link>
      </para>
      <section
        xml:id="client.connections">
        <title>Connections</title>
        <para>For connection configuration information, see <xref
            linkend="client_dependencies" />. </para>
        <para><emphasis><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html">HTable</link>
            instances are not thread-safe</emphasis>. Only one thread use an instance of HTable at
          any given time. When creating HTable instances, it is advisable to use the same <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HBaseConfiguration">HBaseConfiguration</link>
          instance. This will ensure sharing of ZooKeeper and socket instances to the RegionServers
          which is usually what you want. For example, this is preferred:</para>
          <programlisting language="java">HBaseConfiguration conf = HBaseConfiguration.create();
HTable table1 = new HTable(conf, "myTable");
HTable table2 = new HTable(conf, "myTable");</programlisting>
          <para>as opposed to this:</para>
          <programlisting language="java">HBaseConfiguration conf1 = HBaseConfiguration.create();
HTable table1 = new HTable(conf1, "myTable");
HBaseConfiguration conf2 = HBaseConfiguration.create();
HTable table2 = new HTable(conf2, "myTable");</programlisting>

        <para>For more information about how connections are handled in the HBase client,
        see <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HConnectionManager.html">HConnectionManager</link>.
          </para>
          <section xml:id="client.connection.pooling"><title>Connection Pooling</title>
            <para>For applications which require high-end multithreaded access (e.g., web-servers or application servers that may serve many application threads
            in a single JVM), you can pre-create an <classname>HConnection</classname>, as shown in
              the following example:</para>
            <example>
              <title>Pre-Creating a <code>HConnection</code></title>
              <programlisting language="java">// Create a connection to the cluster.
HConnection connection = HConnectionManager.createConnection(Configuration);
HTableInterface table = connection.getTable("myTable");
// use table as needed, the table returned is lightweight
table.close();
// use the connection for other access to the cluster
connection.close();</programlisting>
            </example>
          <para>Constructing HTableInterface implementation is very lightweight and resources are
            controlled.</para>
            <warning>
              <title><code>HTablePool</code> is Deprecated</title>
              <para>Previous versions of this guide discussed <code>HTablePool</code>, which was
                deprecated in HBase 0.94, 0.95, and 0.96, and removed in 0.98.1, by <link
                  xlink:href="https://issues.apache.org/jira/browse/HBASE-6580">HBASE-6500</link>.
                Please use <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HConnection.html"><code>HConnection</code></link> instead.</para>
            </warning>
          </section>
   	  </section>
	   <section xml:id="client.writebuffer"><title>WriteBuffer and Batch Methods</title>
           <para>If <xref linkend="perf.hbase.client.autoflush" /> is turned off on
               <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html">HTable</link>,
               <classname>Put</classname>s are sent to RegionServers when the writebuffer
               is filled.  The writebuffer is 2MB by default.  Before an HTable instance is
               discarded, either <methodname>close()</methodname> or
               <methodname>flushCommits()</methodname> should be invoked so Puts
               will not be lost.
	      </para>
	      <para>Note: <code>htable.delete(Delete);</code> does not go in the writebuffer!  This only applies to Puts.
	      </para>
	      <para>For additional information on write durability, review the <link xlink:href="../acid-semantics.html">ACID semantics</link> page.
	      </para>
       <para>For fine-grained control of batching of
           <classname>Put</classname>s or <classname>Delete</classname>s,
           see the <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#batch%28java.util.List%29">batch</link> methods on HTable.
	   </para>
	   </section>
	   <section xml:id="client.external"><title>External Clients</title>
           <para>Information on non-Java clients and custom protocols is covered in <xref linkend="external_apis" />
           </para>
		</section>
	</section>

    <section xml:id="client.filter"><title>Client Request Filters</title>
      <para><link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html">Get</link> and <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html">Scan</link> instances can be
       optionally configured with <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/Filter.html">filters</link> which are applied on the RegionServer.
      </para>
      <para>Filters can be confusing because there are many different types, and it is best to approach them by understanding the groups
      of Filter functionality.
      </para>
      <section xml:id="client.filter.structural"><title>Structural</title>
        <para>Structural Filters contain other Filters.</para>
        <section xml:id="client.filter.structural.fl"><title>FilterList</title>
          <para><link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/FilterList.html">FilterList</link>
          represents a list of Filters with a relationship of <code>FilterList.Operator.MUST_PASS_ALL</code> or
          <code>FilterList.Operator.MUST_PASS_ONE</code> between the Filters.  The following example shows an 'or' between two
          Filters (checking for either 'my value' or 'my other value' on the same attribute).</para>
<programlisting language="java">
FilterList list = new FilterList(FilterList.Operator.MUST_PASS_ONE);
SingleColumnValueFilter filter1 = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	Bytes.toBytes("my value")
	);
list.add(filter1);
SingleColumnValueFilter filter2 = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	Bytes.toBytes("my other value")
	);
list.add(filter2);
scan.setFilter(list);
</programlisting>
        </section>
      </section>
      <section
        xml:id="client.filter.cv">
        <title>Column Value</title>
        <section
          xml:id="client.filter.cv.scvf">
          <title>SingleColumnValueFilter</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/SingleColumnValueFilter.html">SingleColumnValueFilter</link>
            can be used to test column values for equivalence (<code><link
                xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/CompareFilter.CompareOp.html">CompareOp.EQUAL</link>
            </code>), inequality (<code>CompareOp.NOT_EQUAL</code>), or ranges (e.g.,
              <code>CompareOp.GREATER</code>). The following is example of testing equivalence a
            column to a String value "my value"...</para>
          <programlisting language="java">
SingleColumnValueFilter filter = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	Bytes.toBytes("my value")
	);
scan.setFilter(filter);
</programlisting>
        </section>
      </section>
      <section
        xml:id="client.filter.cvp">
        <title>Column Value Comparators</title>
        <para>There are several Comparator classes in the Filter package that deserve special
          mention. These Comparators are used in concert with other Filters, such as <xref
            linkend="client.filter.cv.scvf" />. </para>
        <section
          xml:id="client.filter.cvp.rcs">
          <title>RegexStringComparator</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/RegexStringComparator.html">RegexStringComparator</link>
            supports regular expressions for value comparisons.</para>
          <programlisting language="java">
RegexStringComparator comp = new RegexStringComparator("my.");   // any value that starts with 'my'
SingleColumnValueFilter filter = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	comp
	);
scan.setFilter(filter);
</programlisting>
          <para>See the Oracle JavaDoc for <link
              xlink:href="http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html">supported
              RegEx patterns in Java</link>. </para>
        </section>
        <section
          xml:id="client.filter.cvp.SubStringComparator">
          <title>SubstringComparator</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/SubstringComparator.html">SubstringComparator</link>
            can be used to determine if a given substring exists in a value. The comparison is
            case-insensitive. </para>
          <programlisting language="java">
SubstringComparator comp = new SubstringComparator("y val");   // looking for 'my value'
SingleColumnValueFilter filter = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	comp
	);
scan.setFilter(filter);
</programlisting>
        </section>
        <section
          xml:id="client.filter.cvp.bfp">
          <title>BinaryPrefixComparator</title>
          <para>See <link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/BinaryPrefixComparator.html">BinaryPrefixComparator</link>.</para>
        </section>
        <section
          xml:id="client.filter.cvp.bc">
          <title>BinaryComparator</title>
          <para>See <link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/BinaryComparator.html">BinaryComparator</link>.</para>
        </section>
      </section>
      <section
        xml:id="client.filter.kvm">
        <title>KeyValue Metadata</title>
        <para>As HBase stores data internally as KeyValue pairs, KeyValue Metadata Filters evaluate
          the existence of keys (i.e., ColumnFamily:Column qualifiers) for a row, as opposed to
          values the previous section. </para>
        <section
          xml:id="client.filter.kvm.ff">
          <title>FamilyFilter</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/FamilyFilter.html">FamilyFilter</link>
            can be used to filter on the ColumnFamily. It is generally a better idea to select
            ColumnFamilies in the Scan than to do it with a Filter.</para>
        </section>
        <section
          xml:id="client.filter.kvm.qf">
          <title>QualifierFilter</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/QualifierFilter.html">QualifierFilter</link>
            can be used to filter based on Column (aka Qualifier) name. </para>
        </section>
        <section
          xml:id="client.filter.kvm.cpf">
          <title>ColumnPrefixFilter</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/ColumnPrefixFilter.html">ColumnPrefixFilter</link>
            can be used to filter based on the lead portion of Column (aka Qualifier) names. </para>
          <para>A ColumnPrefixFilter seeks ahead to the first column matching the prefix in each row
            and for each involved column family. It can be used to efficiently get a subset of the
            columns in very wide rows. </para>
          <para>Note: The same column qualifier can be used in different column families. This
            filter returns all matching columns. </para>
          <para>Example: Find all columns in a row and family that start with "abc"</para>
          <programlisting language="java">
HTableInterface t = ...;
byte[] row = ...;
byte[] family = ...;
byte[] prefix = Bytes.toBytes("abc");
Scan scan = new Scan(row, row); // (optional) limit to one row
scan.addFamily(family); // (optional) limit to one family
Filter f = new ColumnPrefixFilter(prefix);
scan.setFilter(f);
scan.setBatch(10); // set this if there could be many columns returned
ResultScanner rs = t.getScanner(scan);
for (Result r = rs.next(); r != null; r = rs.next()) {
  for (KeyValue kv : r.raw()) {
    // each kv represents a column
  }
}
rs.close();
</programlisting>
        </section>
        <section
          xml:id="client.filter.kvm.mcpf">
          <title>MultipleColumnPrefixFilter</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/MultipleColumnPrefixFilter.html">MultipleColumnPrefixFilter</link>
            behaves like ColumnPrefixFilter but allows specifying multiple prefixes. </para>
          <para>Like ColumnPrefixFilter, MultipleColumnPrefixFilter efficiently seeks ahead to the
            first column matching the lowest prefix and also seeks past ranges of columns between
            prefixes. It can be used to efficiently get discontinuous sets of columns from very wide
            rows. </para>
          <para>Example: Find all columns in a row and family that start with "abc" or "xyz"</para>
          <programlisting language="java">
HTableInterface t = ...;
byte[] row = ...;
byte[] family = ...;
byte[][] prefixes = new byte[][] {Bytes.toBytes("abc"), Bytes.toBytes("xyz")};
Scan scan = new Scan(row, row); // (optional) limit to one row
scan.addFamily(family); // (optional) limit to one family
Filter f = new MultipleColumnPrefixFilter(prefixes);
scan.setFilter(f);
scan.setBatch(10); // set this if there could be many columns returned
ResultScanner rs = t.getScanner(scan);
for (Result r = rs.next(); r != null; r = rs.next()) {
  for (KeyValue kv : r.raw()) {
    // each kv represents a column
  }
}
rs.close();
</programlisting>
        </section>
        <section
          xml:id="client.filter.kvm.crf ">
          <title>ColumnRangeFilter</title>
          <para>A <link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/ColumnRangeFilter.html">ColumnRangeFilter</link>
            allows efficient intra row scanning. </para>
          <para>A ColumnRangeFilter can seek ahead to the first matching column for each involved
            column family. It can be used to efficiently get a 'slice' of the columns of a very wide
            row. i.e. you have a million columns in a row but you only want to look at columns
            bbbb-bbdd. </para>
          <para>Note: The same column qualifier can be used in different column families. This
            filter returns all matching columns. </para>
          <para>Example: Find all columns in a row and family between "bbbb" (inclusive) and "bbdd"
            (inclusive)</para>
          <programlisting language="java">
HTableInterface t = ...;
byte[] row = ...;
byte[] family = ...;
byte[] startColumn = Bytes.toBytes("bbbb");
byte[] endColumn = Bytes.toBytes("bbdd");
Scan scan = new Scan(row, row); // (optional) limit to one row
scan.addFamily(family); // (optional) limit to one family
Filter f = new ColumnRangeFilter(startColumn, true, endColumn, true);
scan.setFilter(f);
scan.setBatch(10); // set this if there could be many columns returned
ResultScanner rs = t.getScanner(scan);
for (Result r = rs.next(); r != null; r = rs.next()) {
  for (KeyValue kv : r.raw()) {
    // each kv represents a column
  }
}
rs.close();
</programlisting>
            <para>Note:  Introduced in HBase 0.92</para>
        </section>
      </section>
      <section xml:id="client.filter.row"><title>RowKey</title>
        <section xml:id="client.filter.row.rf"><title>RowFilter</title>
          <para>It is generally a better idea to use the startRow/stopRow methods on Scan for row selection, however
          <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/RowFilter.html">RowFilter</link> can also be used.</para>
        </section>
      </section>
      <section xml:id="client.filter.utility"><title>Utility</title>
        <section xml:id="client.filter.utility.fkof"><title>FirstKeyOnlyFilter</title>
          <para>This is primarily used for rowcount jobs.
          See <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/FirstKeyOnlyFilter.html">FirstKeyOnlyFilter</link>.</para>
        </section>
      </section>
	</section>  <!--  client.filter -->

    <section xml:id="master"><title>Master</title>
       <para><code>HMaster</code> is the implementation of the Master Server.  The Master server
       is responsible for monitoring all RegionServer instances in the cluster, and is
       the interface for all metadata changes.  In a distributed cluster, the Master typically runs on the <xref linkend="arch.hdfs.nn" /><footnote>
            <para>J Mohamed Zahoor goes into some more detail on the Master Architecture in this blog posting, <link
            xlink:href="http://blog.zahoor.in/2012/08/hbase-hmaster-architecture/">HBase HMaster Architecture
            </link>.</para>
          </footnote>
       </para>
       <section xml:id="master.startup"><title>Startup Behavior</title>
         <para>If run in a multi-Master environment, all Masters compete to run the cluster.  If the active
         Master loses its lease in ZooKeeper (or the Master shuts down), then then the remaining Masters jostle to
         take over the Master role.
         </para>
       </section>
      <section
        xml:id="master.runtime">
        <title>Runtime Impact</title>
        <para>A common dist-list question involves what happens to an HBase cluster when the Master
          goes down. Because the HBase client talks directly to the RegionServers, the cluster can
          still function in a "steady state." Additionally, per <xref
            linkend="arch.catalog" />, <code>hbase:meta</code> exists as an HBase table and is not
          resident in the Master. However, the Master controls critical functions such as
          RegionServer failover and completing region splits. So while the cluster can still run for
          a short time without the Master, the Master should be restarted as soon as possible.
        </para>
      </section>
       <section xml:id="master.api"><title>Interface</title>
         <para>The methods exposed by <code>HMasterInterface</code> are primarily metadata-oriented methods:
         <itemizedlist>
            <listitem><para>Table (createTable, modifyTable, removeTable, enable, disable)
            </para></listitem>
            <listitem><para>ColumnFamily (addColumn, modifyColumn, removeColumn)
            </para></listitem>
            <listitem><para>Region (move, assign, unassign)
            </para></listitem>
         </itemizedlist>
         For example, when the <code>HBaseAdmin</code> method <code>disableTable</code> is invoked, it is serviced by the Master server.
         </para>
       </section>
       <section xml:id="master.processes"><title>Processes</title>
         <para>The Master runs several background threads:
         </para>
         <section xml:id="master.processes.loadbalancer"><title>LoadBalancer</title>
           <para>Periodically, and when there are no regions in transition,
             a load balancer will run and move regions around to balance the cluster's load.
             See <xref linkend="balancer_config" /> for configuring this property.</para>
             <para>See <xref linkend="regions.arch.assignment"/> for more information on region assignment.
             </para>
         </section>
         <section xml:id="master.processes.catalog"><title>CatalogJanitor</title>
           <para>Periodically checks and cleans up the hbase:meta table.  See <xref linkend="arch.catalog.meta" /> for more information on META.</para>
         </section>
       </section>

     </section>
    <section
      xml:id="regionserver.arch">
      <title>RegionServer</title>
      <para><code>HRegionServer</code> is the RegionServer implementation. It is responsible for
        serving and managing regions. In a distributed cluster, a RegionServer runs on a <xref
          linkend="arch.hdfs.dn" />. </para>
      <section
        xml:id="regionserver.arch.api">
        <title>Interface</title>
        <para>The methods exposed by <code>HRegionRegionInterface</code> contain both data-oriented
          and region-maintenance methods: <itemizedlist>
            <listitem>
              <para>Data (get, put, delete, next, etc.)</para>
            </listitem>
            <listitem>
              <para>Region (splitRegion, compactRegion, etc.)</para>
            </listitem>
          </itemizedlist> For example, when the <code>HBaseAdmin</code> method
            <code>majorCompact</code> is invoked on a table, the client is actually iterating
          through all regions for the specified table and requesting a major compaction directly to
          each region. </para>
      </section>
      <section
        xml:id="regionserver.arch.processes">
        <title>Processes</title>
        <para>The RegionServer runs a variety of background threads:</para>
        <section
          xml:id="regionserver.arch.processes.compactsplit">
          <title>CompactSplitThread</title>
          <para>Checks for splits and handle minor compactions.</para>
        </section>
        <section
          xml:id="regionserver.arch.processes.majorcompact">
          <title>MajorCompactionChecker</title>
          <para>Checks for major compactions.</para>
        </section>
        <section
          xml:id="regionserver.arch.processes.memstore">
          <title>MemStoreFlusher</title>
          <para>Periodically flushes in-memory writes in the MemStore to StoreFiles.</para>
        </section>
        <section
          xml:id="regionserver.arch.processes.log">
          <title>LogRoller</title>
          <para>Periodically checks the RegionServer's HLog.</para>
        </section>
      </section>

      <section
        xml:id="coprocessors">
        <title>Coprocessors</title>
        <para>Coprocessors were added in 0.92. There is a thorough <link
            xlink:href="https://blogs.apache.org/hbase/entry/coprocessor_introduction">Blog Overview
            of CoProcessors</link> posted. Documentation will eventually move to this reference
          guide, but the blog is the most current information available at this time. </para>
      </section>

      <section
        xml:id="block.cache">
        <title>Block Cache</title>

        <para>HBase provides two different BlockCache implementations: the default onheap
          LruBlockCache and BucketCache, which is (usually) offheap. This section
          discusses benefits and drawbacks of each implementation, how to choose the appropriate
          option, and configuration options for each.</para>

      <note><title>Block Cache Reporting: UI</title>
      <para>See the RegionServer UI for detail on caching deploy.  Since HBase-0.98.4, the
          Block Cache detail has been significantly extended showing configurations,
          sizings, current usage, and even detail on block counts and types.</para>
  </note>

        <section>

          <title>Cache Choices</title>
          <para><classname>LruBlockCache</classname> is the original implementation, and is
              entirely within the Java heap. <classname>BucketCache</classname> is mainly
              intended for keeping blockcache data offheap, although BucketCache can also
              keep data onheap and serve from a file-backed cache.
          </para>

          <para>Fetching will always be slower when fetching from BucketCache,
              as compared to the native onheap LruBlockCache. However, latencies tend to be
              less erratic across time, because there is less garbage collection when you use
              BucketCache since it is managing BlockCache allocations, not the GC. If the
              BucketCache is deployed in offheap mode, this memory is not managed by the
              GC at all. This is why you'd use BucketCache, so your latencies are less erratic and to mitigate GCs
              and heap fragmentation.  See Nick Dimiduk's <link
              xlink:href="http://www.n10k.com/blog/blockcache-101/">BlockCache 101</link> for
            comparisons running onheap vs offheap tests. Also see
            <link xlink:href="http://people.apache.org/~stack/bc/">Comparing BlockCache Deploys</link>
            which finds that if your dataset fits inside your LruBlockCache deploy, use it otherwise
            if you are experiencing cache churn (or you want your cache to exist beyond the
            vagaries of java GC), use BucketCache.
              </para>

              <para>When you enable BucketCache, you are enabling a two tier caching
              system, an L1 cache which is implemented by an instance of LruBlockCache and
              an offheap L2 cache which is implemented by BucketCache.  Management of these
              two tiers and the policy that dictates how blocks move between them is done by
              <classname>CombinedBlockCache</classname>. It keeps all DATA blocks in the L2
              BucketCache and meta blocks -- INDEX and BLOOM blocks --
              onheap in the L1 <classname>LruBlockCache</classname>.
              See <xref linkend="offheap.blockcache" /> for more detail on going offheap.</para>
        </section>

        <section xml:id="cache.configurations">
            <title>General Cache Configurations</title>
            <para>Apart from the cache implementaiton itself, you can set some general
                configuration options to control how the cache performs.
               See <link
                xlink:href="http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/hfile/CacheConfig.html" />.
              After setting any of these options, restart or rolling restart your cluster for the
              configuration to take effect. Check logs for errors or unexpected behavior.</para>
      </section>

        <section
          xml:id="block.cache.design">
          <title>LruBlockCache Design</title>
          <para>The LruBlockCache is an LRU cache that contains three levels of block priority to
            allow for scan-resistance and in-memory ColumnFamilies: </para>
          <itemizedlist>
            <listitem>
              <para>Single access priority: The first time a block is loaded from HDFS it normally
                has this priority and it will be part of the first group to be considered during
                evictions. The advantage is that scanned blocks are more likely to get evicted than
                blocks that are getting more usage.</para>
            </listitem>
            <listitem>
              <para>Mutli access priority: If a block in the previous priority group is accessed
                again, it upgrades to this priority. It is thus part of the second group considered
                during evictions.</para>
            </listitem>
            <listitem xml:id="hbase.cache.inmemory">
              <para>In-memory access priority: If the block's family was configured to be
                "in-memory", it will be part of this priority disregarding the number of times it
                was accessed. Catalog tables are configured like this. This group is the last one
                considered during evictions.</para>
            <para>To mark a column family as in-memory, call
                <programlisting language="java">HColumnDescriptor.setInMemory(true);</programlisting> if creating a table from java,
                or set <command>IN_MEMORY => true</command> when creating or altering a table in
                the shell: e.g.  <programlisting>hbase(main):003:0> create  't', {NAME => 'f', IN_MEMORY => 'true'}</programlisting></para>
            </listitem>
          </itemizedlist>
          <para> For more information, see the <link
              xlink:href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/io/hfile/LruBlockCache.html">LruBlockCache
              source</link>
          </para>
        </section>
        <section
          xml:id="block.cache.usage">
          <title>LruBlockCache Usage</title>
          <para>Block caching is enabled by default for all the user tables which means that any
            read operation will load the LRU cache. This might be good for a large number of use
            cases, but further tunings are usually required in order to achieve better performance.
            An important concept is the <link
              xlink:href="http://en.wikipedia.org/wiki/Working_set_size">working set size</link>, or
            WSS, which is: "the amount of memory needed to compute the answer to a problem". For a
            website, this would be the data that's needed to answer the queries over a short amount
            of time. </para>
          <para>The way to calculate how much memory is available in HBase for caching is: </para>
          <programlisting>
            number of region servers * heap size * hfile.block.cache.size * 0.85
        </programlisting>
          <para>The default value for the block cache is 0.25 which represents 25% of the available
            heap. The last value (85%) is the default acceptable loading factor in the LRU cache
            after which eviction is started. The reason it is included in this equation is that it
            would be unrealistic to say that it is possible to use 100% of the available memory
            since this would make the process blocking from the point where it loads new blocks.
            Here are some examples: </para>
          <itemizedlist>
            <listitem>
              <para>One region server with the default heap size (1GB) and the default block cache
                size will have 217MB of block cache available.</para>
            </listitem>
            <listitem>
              <para>20 region servers with the heap size set to 8GB and a default block cache size
                will have 34GB of block cache.</para>
            </listitem>
            <listitem>
              <para>100 region servers with the heap size set to 24GB and a block cache size of 0.5
                will have about 1TB of block cache.</para>
            </listitem>
        </itemizedlist>
        <para>Your data is not the only resident of the block cache. Here are others that you may have to take into account:
        </para>
          <variablelist>
            <varlistentry>
              <term>Catalog Tables</term>
              <listitem>
                <para>The <code>-ROOT-</code> (prior to HBase 0.96. See <xref
                    linkend="arch.catalog.root" />) and <code>hbase:meta</code> tables are forced
                  into the block cache and have the in-memory priority which means that they are
                  harder to evict. The former never uses more than a few hundreds of bytes while the
                  latter can occupy a few MBs (depending on the number of regions).</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>HFiles Indexes</term>
              <listitem>
                <para>An <firstterm>hfile</firstterm> is the file format that HBase uses to store
                  data in HDFS. It contains a multi-layered index which allows HBase to seek to the
                  data without having to read the whole file. The size of those indexes is a factor
                  of the block size (64KB by default), the size of your keys and the amount of data
                  you are storing. For big data sets it's not unusual to see numbers around 1GB per
                  region server, although not all of it will be in cache because the LRU will evict
                  indexes that aren't used.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Keys</term>
              <listitem>
                <para>The values that are stored are only half the picture, since each value is
                  stored along with its keys (row key, family qualifier, and timestamp). See <xref
                    linkend="keysize" />.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Bloom Filters</term>
              <listitem>
                <para>Just like the HFile indexes, those data structures (when enabled) are stored
                  in the LRU.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <para>Currently the recommended way to measure HFile indexes and bloom filters sizes is to
            look at the region server web UI and checkout the relevant metrics. For keys, sampling
            can be done by using the HFile command line tool and look for the average key size
            metric. Since HBase 0.98.3, you can view detail on BlockCache stats and metrics
            in a special Block Cache section in the UI.</para>
          <para>It's generally bad to use block caching when the WSS doesn't fit in memory. This is
            the case when you have for example 40GB available across all your region servers' block
            caches but you need to process 1TB of data. One of the reasons is that the churn
            generated by the evictions will trigger more garbage collections unnecessarily. Here are
            two use cases: </para>
        <itemizedlist>
            <listitem>
              <para>Fully random reading pattern: This is a case where you almost never access the
                same row twice within a short amount of time such that the chance of hitting a
                cached block is close to 0. Setting block caching on such a table is a waste of
                memory and CPU cycles, more so that it will generate more garbage to pick up by the
                JVM. For more information on monitoring GC, see <xref
                  linkend="trouble.log.gc" />.</para>
            </listitem>
            <listitem>
              <para>Mapping a table: In a typical MapReduce job that takes a table in input, every
                row will be read only once so there's no need to put them into the block cache. The
                Scan object has the option of turning this off via the setCaching method (set it to
                false). You can still keep block caching turned on on this table if you need fast
                random read access. An example would be counting the number of rows in a table that
                serves live traffic, caching every block of that table would create massive churn
                and would surely evict data that's currently in use. </para>
            </listitem>
          </itemizedlist>
          <section xml:id="data.blocks.in.fscache">
            <title>Caching META blocks only (DATA blocks in fscache)</title>
            <para>An interesting setup is one where we cache META blocks only and we read DATA
              blocks in on each access. If the DATA blocks fit inside fscache, this alternative
              may make sense when access is completely random across a very large dataset.
              To enable this setup, alter your table and for each column family
              set <varname>BLOCKCACHE => 'false'</varname>.  You are 'disabling' the
              BlockCache for this column family only you can never disable the caching of
              META blocks. Since
              <link xlink:href="https://issues.apache.org/jira/browse/HBASE-4683">HBASE-4683 Always cache index and bloom blocks</link>,
              we will cache META blocks even if the BlockCache is disabled.
            </para>
          </section>
        </section>
        <section
          xml:id="offheap.blockcache">
          <title>Offheap Block Cache</title>
          <section xml:id="enable.bucketcache">
            <title>How to Enable BucketCache</title>
                <para>The usual deploy of BucketCache is via a managing class that sets up two caching tiers: an L1 onheap cache
                    implemented by LruBlockCache and a second L2 cache implemented with BucketCache. The managing class is <link
                        xlink:href="http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/hfile/CombinedBlockCache.html">CombinedBlockCache</link> by default.
            The just-previous link describes the caching 'policy' implemented by CombinedBlockCache. In short, it works
            by keeping meta blocks -- INDEX and BLOOM in the L1, onheap LruBlockCache tier -- and DATA
            blocks are kept in the L2, BucketCache tier. It is possible to amend this behavior in
            HBase since version 1.0 and ask that a column family have both its meta and DATA blocks hosted onheap in the L1 tier by
            setting <varname>cacheDataInL1</varname> via
                  <code>(HColumnDescriptor.setCacheDataInL1(true)</code>
            or in the shell, creating or amending column families setting <varname>CACHE_DATA_IN_L1</varname>
            to true: e.g. <programlisting>hbase(main):003:0> create 't', {NAME => 't', CONFIGURATION => {CACHE_DATA_IN_L1 => 'true'}}</programlisting></para>

        <para>The BucketCache Block Cache can be deployed onheap, offheap, or file based.
            You set which via the
            <varname>hbase.bucketcache.ioengine</varname> setting.  Setting it to
            <varname>heap</varname> will have BucketCache deployed inside the 
            allocated java heap. Setting it to <varname>offheap</varname> will have
            BucketCache make its allocations offheap,
            and an ioengine setting of <varname>file:PATH_TO_FILE</varname> will direct
            BucketCache to use a file caching (Useful in particular if you have some fast i/o attached to the box such
            as SSDs).
        </para>
        <para xml:id="raw.l1.l2">It is possible to deploy an L1+L2 setup where we bypass the CombinedBlockCache
            policy and have BucketCache working as a strict L2 cache to the L1
              LruBlockCache. For such a setup, set <varname>CacheConfig.BUCKET_CACHE_COMBINED_KEY</varname> to
              <literal>false</literal>. In this mode, on eviction from L1, blocks go to L2.
              When a block is cached, it is cached first in L1. When we go to look for a cached block,
              we look first in L1 and if none found, then search L2.  Let us call this deploy format,
              <emphasis><indexterm><primary>Raw L1+L2</primary></indexterm></emphasis>.</para>
          <para>Other BucketCache configs include: specifying a location to persist cache to across
              restarts, how many threads to use writing the cache, etc.  See the
              <link xlink:href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/io/hfile/CacheConfig.html">CacheConfig.html</link>
              class for configuration options and descriptions.</para>

            <procedure>
              <title>BucketCache Example Configuration</title>
              <para>This sample provides a configuration for a 4 GB offheap BucketCache with a 1 GB
                  onheap cache. Configuration is performed on the RegionServer.  Setting
                  <varname>hbase.bucketcache.ioengine</varname> and 
                  <varname>hbase.bucketcache.size</varname> &gt; 0 enables CombinedBlockCache.
                  Let us presume that the RegionServer has been set to run with a 5G heap:
                  i.e. HBASE_HEAPSIZE=5g.
              </para>
              <step>
                <para>First, edit the RegionServer's <filename>hbase-env.sh</filename> and set
                  <varname>-XX:MaxDirectMemorySize</varname> to a value greater than the offheap size wanted, in
                  this case, 4 GB (expressed as 4G).  Lets set it to 5G.  That'll be 4G
                  for our offheap cache and 1G for any other uses of offheap memory (there are
                  other users of offheap memory other than BlockCache; e.g. DFSClient 
                  in RegionServer can make use of offheap memory). See <xref linkend="direct.memory" />.</para>
                <programlisting>-XX:MaxDirectMemorySize=5G</programlisting>
              </step>
              <step>
                <para>Next, add the following configuration to the RegionServer's
                    <filename>hbase-site.xml</filename>.</para>
                <programlisting language="xml">
<![CDATA[<property>
  <name>hbase.bucketcache.ioengine</name>
  <value>offheap</value>
</property>
<property>
  <name>hfile.block.cache.size</name>
  <value>0.2</value>
</property>
<property>
  <name>hbase.bucketcache.size</name>
  <value>4196</value>
</property>]]>
          </programlisting>
              </step>
              <step>
                <para>Restart or rolling restart your cluster, and check the logs for any
                  issues.</para>
              </step>
            </procedure>
            <para>In the above, we set bucketcache to be 4G.  The onheap lrublockcache we
                configured to have 0.2 of the RegionServer's heap size (0.2 * 5G = 1G).
                In other words, you configure the L1 LruBlockCache as you would normally,
                as you would when there is no L2 BucketCache present.
            </para>
            <note xml:id="direct.memory">
                <title>Direct Memory Usage In HBase</title>
                <para>The default maximum direct memory varies by JVM.  Traditionally it is 64M
                    or some relation to allocated heap size (-Xmx) or no limit at all (JDK7 apparently).
                    HBase servers use direct memory, in particular short-circuit reading, the hosted DFSClient will
                    allocate direct memory buffers.  If you do offheap block caching, you'll
                    be making use of direct memory.  Starting your JVM, make sure
                    the <varname>-XX:MaxDirectMemorySize</varname> setting in
                    <filename>conf/hbase-env.sh</filename> is set to some value that is
                    higher than what you have allocated to your offheap blockcache
                    (<varname>hbase.bucketcache.size</varname>).  It should be larger than your offheap block
                    cache and then some for DFSClient usage (How much the DFSClient uses is not
                    easy to quantify; it is the number of open hfiles * <varname>hbase.dfs.client.read.shortcircuit.buffer.size</varname>
                    where hbase.dfs.client.read.shortcircuit.buffer.size is set to 128k in HBase -- see <filename>hbase-default.xml</filename>
                    default configurations).
                        Direct memory, which is part of the Java process heap, is separate from the object
                        heap allocated by -Xmx. The value allocated by MaxDirectMemorySize must not exceed
                        physical RAM, and is likely to be less than the total available RAM due to other
                        memory requirements and system constraints.
                </para>
                <para>You can see how much memory -- onheap and offheap/direct -- a RegionServer is configured to use
                    and how much it is using at any one time by looking at the
                    <emphasis>Server Metrics: Memory</emphasis> tab in the UI.
                    It can also be gotten via JMX.  In particular the direct
                    memory currently used by the server can be found on the
                    <varname>java.nio.type=BufferPool,name=direct</varname>
                    bean.
                    <footnote><para>Terracotta has a <link xlink:href="http://terracotta.org/documentation/4.0/bigmemorygo/configuration/storage-options">good write up</link> on using offheap memory in java.
                        It is for their product BigMemory but alot of the issues noted apply
                        in general to any attempt at going offheap. Check it out.</para></footnote>
                </para>
            </note>
              <note xml:id="hbase.bucketcache.percentage.in.combinedcache"><title>hbase.bucketcache.percentage.in.combinedcache</title>
                  <para>This is a pre-HBase 1.0 configuration removed because it
                      was confusing. It was a float that you would set to some value
                      between 0.0 and 1.0.  Its default was 0.9. If the deploy was using
                      CombinedBlockCache, then the LruBlockCache L1 size was calculated to
                      be (1 - <varname>hbase.bucketcache.percentage.in.combinedcache</varname>) * <varname>size-of-bucketcache</varname> 
                      and the BucketCache size was <varname>hbase.bucketcache.percentage.in.combinedcache</varname> * size-of-bucket-cache.
                      where size-of-bucket-cache itself is EITHER the value of the configuration hbase.bucketcache.size
                      IF it was specified as megabytes OR <varname>hbase.bucketcache.size</varname> * <varname>-XX:MaxDirectMemorySize</varname> if
                      <varname>hbase.bucketcache.size</varname> between 0 and 1.0.
                  </para>
                  <para>In 1.0, it should be more straight-forward. L1 LruBlockCache size
                      is set as a fraction of java heap using hfile.block.cache.size setting
                      (not the best name) and L2 is set as above either in absolute
                      megabytes or as a fraction of allocated maximum direct memory.
                  </para>
              </note>
          </section>
        </section>
      </section>

      <section
        xml:id="wal">
        <title>Write Ahead Log (WAL)</title>

        <section
          xml:id="purpose.wal">
          <title>Purpose</title>
          <para>The <firstterm>Write Ahead Log (WAL)</firstterm> records all changes to data in
            HBase, to file-based storage. Under normal operations, the WAL is not needed because
            data changes move from the MemStore to StoreFiles. However, if a RegionServer crashes or
          becomes unavailable before the MemStore is flushed, the WAL ensures that the changes to
          the data can be replayed. If writing to the WAL fails, the entire operation to modify the
          data fails.</para>
          <para>HBase uses an implementation of the <link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/regionserver/wal/HLog.html">HLog</link>
            interface for the WAL.
            Usually, there is only one instance of a WAL per RegionServer. The RegionServer records Puts and Deletes to
            it, before recording them to the <xref
              linkend="store.memstore" /> for the affected <xref
              linkend="store" />.</para>
          <para>The WAL resides in HDFS in the <filename>/hbase/WALs/</filename> directory (prior to
            HBase 0.94, they were stored in <filename>/hbase/.logs/</filename>), with subdirectories per
            region.</para>
          <para> For more general information about the concept of write ahead logs, see the
            Wikipedia <link
              xlink:href="http://en.wikipedia.org/wiki/Write-ahead_logging">Write-Ahead Log</link>
            article. </para>
        </section>
        <section
          xml:id="wal_flush">
          <title>WAL Flushing</title>
          <para>TODO (describe). </para>
        </section>

        <section
          xml:id="wal_splitting">
          <title>WAL Splitting</title>

          <para>A RegionServer serves many regions. All of the regions in a region server share the
            same active WAL file. Each edit in the WAL file includes information about which region
            it belongs to. When a region is opened, the edits in the WAL file which belong to that
            region need to be replayed. Therefore, edits in the WAL file must be grouped by region
            so that particular sets can be replayed to regenerate the data in a particular region.
            The process of grouping the WAL edits by region is called <firstterm>log
              splitting</firstterm>. It is a critical process for recovering data if a region server
            fails.</para>
          <para>Log splitting is done by the HMaster during cluster start-up or by the ServerShutdownHandler
            as a region server shuts down. So that consistency is guaranteed, affected regions
            are unavailable until data is restored. All WAL edits need to be recovered and replayed
            before a given region can become available again. As a result, regions affected by
            log splitting are unavailable until the process completes.</para>
          <procedure xml:id="log.splitting.step.by.step">
            <title>Log Splitting, Step by Step</title>
            <step>
              <title>The <filename>/hbase/WALs/&lt;host>,&lt;port>,&lt;startcode></filename> directory is renamed.</title>
              <para>Renaming the directory is important because a RegionServer may still be up and
                accepting requests even if the HMaster thinks it is down. If the RegionServer does
                not respond immediately and does not heartbeat its ZooKeeper session, the HMaster
                may interpret this as a RegionServer failure. Renaming the logs directory ensures
                that existing, valid WAL files which are still in use by an active but busy
                RegionServer are not written to by accident.</para>
              <para>The new directory is named according to the following pattern:</para>
              <screen><![CDATA[/hbase/WALs/<host>,<port>,<startcode>-splitting]]></screen>
              <para>An example of such a renamed directory might look like the following:</para>
              <screen>/hbase/WALs/srv.example.com,60020,1254173957298-splitting</screen>
            </step>
            <step>
              <title>Each log file is split, one at a time.</title>
              <para>The log splitter reads the log file one edit entry at a time and puts each edit
                entry into the buffer corresponding to the edit’s region. At the same time, the
                splitter starts several writer threads. Writer threads pick up a corresponding
                buffer and write the edit entries in the buffer to a temporary recovered edit
                file. The temporary edit file is stored to disk with the following naming pattern:</para>
              <screen><![CDATA[/hbase/<table_name>/<region_id>/recovered.edits/.temp]]></screen>
              <para>This file is used to store all the edits in the WAL log for this region. After
                log splitting completes, the <filename>.temp</filename> file is renamed to the
                sequence ID of the first log written to the file.</para>
              <para>To determine whether all edits have been written, the sequence ID is compared to
                the sequence of the last edit that was written to the HFile. If the sequence of the
                last edit is greater than or equal to the sequence ID included in the file name, it
                is clear that all writes from the edit file have been completed.</para>
            </step>
            <step>
              <title>After log splitting is complete, each affected region is assigned to a
                RegionServer.</title>
              <para> When the region is opened, the <filename>recovered.edits</filename> folder is checked for recovered
                edits files. If any such files are present, they are replayed by reading the edits
                and saving them to the MemStore. After all edit files are replayed, the contents of
                the MemStore are written to disk (HFile) and the edit files are deleted.</para>
            </step>
          </procedure>
  
          <section>
            <title>Handling of Errors During Log Splitting</title>

            <para>If you set the <varname>hbase.hlog.split.skip.errors</varname> option to
                <constant>true</constant>, errors are treated as follows:</para>
            <itemizedlist>
              <listitem>
                <para>Any error encountered during splitting will be logged.</para>
              </listitem>
              <listitem>
                <para>The problematic WAL log will be moved into the <filename>.corrupt</filename>
                  directory under the hbase <varname>rootdir</varname>,</para>
              </listitem>
              <listitem>
                <para>Processing of the WAL will continue</para>
              </listitem>
            </itemizedlist>
            <para>If the <varname>hbase.hlog.split.skip.errors</varname> optionset to
                <literal>false</literal>, the default, the exception will be propagated and the
              split will be logged as failed.<footnote>
                <para>See <link
                    xlink:href="https://issues.apache.org/jira/browse/HBASE-2958">HBASE-2958 When
                    hbase.hlog.split.skip.errors is set to false, we fail the split but thats
                    it</link>. We need to do more than just fail split if this flag is set.</para>
              </footnote></para>
            
            <section>
              <title>How EOFExceptions are treated when splitting a crashed RegionServers'
                WALs</title>

              <para>If an EOFException occurs while splitting logs, the split proceeds even when
                  <varname>hbase.hlog.split.skip.errors</varname> is set to
                <literal>false</literal>. An EOFException while reading the last log in the set of
                files to split is likely, because the RegionServer is likely to be in the process of
                writing a record at the time of a crash. <footnote>
                  <para>For background, see <link
                      xlink:href="https://issues.apache.org/jira/browse/HBASE-2643">HBASE-2643
                      Figure how to deal with eof splitting logs</link></para>
                </footnote></para>
            </section>
          </section>
          
          <section>
            <title>Performance Improvements during Log Splitting</title>
            <para>
              WAL log splitting and recovery can be resource intensive and take a long time,
              depending on the number of RegionServers involved in the crash and the size of the
              regions. <xref linkend="distributed.log.splitting" /> and <xref
                linkend="distributed.log.replay" /> were developed to improve
              performance during log splitting.
            </para>
            <section xml:id="distributed.log.splitting">
              <title>Distributed Log Splitting</title>
              <para><firstterm>Distributed Log Splitting</firstterm> was added in HBase version 0.92
                (<link xlink:href="https://issues.apache.org/jira/browse/HBASE-1364">HBASE-1364</link>) 
                by Prakash Khemani from Facebook. It reduces the time to complete log splitting
                dramatically, improving the availability of regions and tables. For
                example, recovering a crashed cluster took around 9 hours with single-threaded log
                splitting, but only about six minutes with distributed log splitting.</para>
              <para>The information in this section is sourced from Jimmy Xiang's blog post at <link
              xlink:href="http://blog.cloudera.com/blog/2012/07/hbase-log-splitting/" />.</para>
              
              <formalpara>
                <title>Enabling or Disabling Distributed Log Splitting</title>
                <para>Distributed log processing is enabled by default since HBase 0.92. The setting
                  is controlled by the <property>hbase.master.distributed.log.splitting</property>
                  property, which can be set to <literal>true</literal> or <literal>false</literal>,
                  but defaults to <literal>true</literal>. </para>
              </formalpara>
              <procedure>
                <title>Distributed Log Splitting, Step by Step</title>
                <para>After configuring distributed log splitting, the HMaster controls the process.
                  The HMaster enrolls each RegionServer in the log splitting process, and the actual
                  work of splitting the logs is done by the RegionServers. The general process for
                  log splitting, as described in <xref
                    linkend="log.splitting.step.by.step" /> still applies here.</para>
                <step>
                  <para>If distributed log processing is enabled, the HMaster creates a
                    <firstterm>split log manager</firstterm> instance when the cluster is started.
                    The split log manager manages all log files which need
                    to be scanned and split. The split log manager places all the logs into the
                    ZooKeeper splitlog node (<filename>/hbase/splitlog</filename>) as tasks. You can
                  view the contents of the splitlog by issuing the following
                    <command>zkcli</command> command. Example output is shown.</para>
                  <screen language="bourne">ls /hbase/splitlog
[hdfs%3A%2F%2Fhost2.sample.com%3A56020%2Fhbase%2F.logs%2Fhost8.sample.com%2C57020%2C1340474893275-splitting%2Fhost8.sample.com%253A57020.1340474893900, 
hdfs%3A%2F%2Fhost2.sample.com%3A56020%2Fhbase%2F.logs%2Fhost3.sample.com%2C57020%2C1340474893299-splitting%2Fhost3.sample.com%253A57020.1340474893931, 
hdfs%3A%2F%2Fhost2.sample.com%3A56020%2Fhbase%2F.logs%2Fhost4.sample.com%2C57020%2C1340474893287-splitting%2Fhost4.sample.com%253A57020.1340474893946]                  
                  </screen>
                  <para>The output contains some non-ASCII characters. When decoded, it looks much
                    more simple:</para>
                  <screen>
[hdfs://host2.sample.com:56020/hbase/.logs
/host8.sample.com,57020,1340474893275-splitting
/host8.sample.com%3A57020.1340474893900, 
hdfs://host2.sample.com:56020/hbase/.logs
/host3.sample.com,57020,1340474893299-splitting
/host3.sample.com%3A57020.1340474893931, 
hdfs://host2.sample.com:56020/hbase/.logs
/host4.sample.com,57020,1340474893287-splitting
/host4.sample.com%3A57020.1340474893946]                    
                  </screen>
                  <para>The listing represents WAL file names to be scanned and split, which is a
                    list of log splitting tasks.</para>
                </step>
                <step>
                  <title>The split log manager monitors the log-splitting tasks and workers.</title>
                  <para>The split log manager is responsible for the following ongoing tasks:</para>
                  <itemizedlist>
                    <listitem>
                      <para>Once the split log manager publishes all the tasks to the splitlog
                        znode, it monitors these task nodes and waits for them to be
                        processed.</para>
                    </listitem>
                    <listitem>
                      <para>Checks to see if there are any dead split log
                        workers queued up. If it finds tasks claimed by unresponsive workers, it
                        will resubmit those tasks. If the resubmit fails due to some ZooKeeper
                        exception, the dead worker is queued up again for retry.</para>
                    </listitem>
                    <listitem>
                      <para>Checks to see if there are any unassigned
                        tasks. If it finds any, it create an ephemeral rescan node so that each
                        split log worker is notified to re-scan unassigned tasks via the
                          <code>nodeChildrenChanged</code> ZooKeeper event.</para>
                    </listitem>
                    <listitem>
                      <para>Checks for tasks which are assigned but expired. If any are found, they
                        are moved back to <code>TASK_UNASSIGNED</code> state again so that they can
                        be retried. It is possible that these tasks are assigned to slow workers, or
                        they may already be finished. This is not a problem, because log splitting
                        tasks have the property of idempotence. In other words, the same log
                        splitting task can be processed many times without causing any
                        problem.</para>
                    </listitem>
                    <listitem>
                      <para>The split log manager watches the HBase split log znodes constantly. If
                        any split log task node data is changed, the split log manager retrieves the
                        node data. The
                        node data contains the current state of the task. You can use the
                        <command>zkcli</command> <command>get</command> command to retrieve the
                        current state of a task. In the example output below, the first line of the
                        output shows that the task is currently unassigned.</para>
                      <screen>
<userinput>get /hbase/splitlog/hdfs%3A%2F%2Fhost2.sample.com%3A56020%2Fhbase%2F.logs%2Fhost6.sample.com%2C57020%2C1340474893287-splitting%2Fhost6.sample.com%253A57020.1340474893945
</userinput> 
<computeroutput>unassigned host2.sample.com:57000
cZxid = 0×7115
ctime = Sat Jun 23 11:13:40 PDT 2012
...</computeroutput>  
                      </screen>
                      <para>Based on the state of the task whose data is changed, the split log
                        manager does one of the following:</para>

                      <itemizedlist>
                        <listitem>
                          <para>Resubmit the task if it is unassigned</para>
                        </listitem>
                        <listitem>
                          <para>Heartbeat the task if it is assigned</para>
                        </listitem>
                        <listitem>
                          <para>Resubmit or fail the task if it is resigned (see <xref
                            linkend="distributed.log.replay.failure.reasons" />)</para>
                        </listitem>
                        <listitem>
                          <para>Resubmit or fail the task if it is completed with errors (see <xref
                            linkend="distributed.log.replay.failure.reasons" />)</para>
                        </listitem>
                        <listitem>
                          <para>Resubmit or fail the task if it could not complete due to
                            errors (see <xref
                            linkend="distributed.log.replay.failure.reasons" />)</para>
                        </listitem>
                        <listitem>
                          <para>Delete the task if it is successfully completed or failed</para>
                        </listitem>
                      </itemizedlist>
                      <itemizedlist xml:id="distributed.log.replay.failure.reasons">
                        <title>Reasons a Task Will Fail</title>
                        <listitem><para>The task has been deleted.</para></listitem>
                        <listitem><para>The node no longer exists.</para></listitem>
                        <listitem><para>The log status manager failed to move the state of the task
                          to TASK_UNASSIGNED.</para></listitem>
                        <listitem><para>The number of resubmits is over the resubmit
                          threshold.</para></listitem>
                      </itemizedlist>
                    </listitem>
                  </itemizedlist>
                </step>
                <step>
                  <title>Each RegionServer's split log worker performs the log-splitting tasks.</title>
                  <para>Each RegionServer runs a daemon thread called the <firstterm>split log
                      worker</firstterm>, which does the work to split the logs. The daemon thread
                    starts when the RegionServer starts, and registers itself to watch HBase znodes.
                    If any splitlog znode children change, it notifies a sleeping worker thread to
                    wake up and grab more tasks. If if a worker's current task’s node data is
                    changed, the worker checks to see if the task has been taken by another worker.
                    If so, the worker thread stops work on the current task.</para>
                  <para>The worker monitors
                    the splitlog znode constantly. When a new task appears, the split log worker
                    retrieves  the task paths and checks each one until it finds an unclaimed task,
                    which it attempts to claim. If the claim was successful, it attempts to perform
                    the task and updates the task's <property>state</property> property based on the
                    splitting outcome. At this point, the split log worker scans for another
                    unclaimed task.</para>
                  <itemizedlist>
                    <title>How the Split Log Worker Approaches a Task</title>

                    <listitem>
                      <para>It queries the task state and only takes action if the task is in
                          <literal>TASK_UNASSIGNED </literal>state.</para>
                    </listitem>
                    <listitem>
                      <para>If the task is is in <literal>TASK_UNASSIGNED</literal> state, the
                        worker attempts to set the state to <literal>TASK_OWNED</literal> by itself.
                        If it fails to set the state, another worker will try to grab it. The split
                        log manager will also ask all workers to rescan later if the task remains
                        unassigned.</para>
                    </listitem>
                    <listitem>
                      <para>If the worker succeeds in taking ownership of the task, it tries to get
                        the task state again to make sure it really gets it asynchronously. In the
                        meantime, it starts a split task executor to do the actual work: </para>
                      <itemizedlist>
                        <listitem>
                          <para>Get the HBase root folder, create a temp folder under the root, and
                            split the log file to the temp folder.</para>
                        </listitem>
                        <listitem>
                          <para>If the split was successful, the task executor sets the task to
                            state <literal>TASK_DONE</literal>.</para>
                        </listitem>
                        <listitem>
                          <para>If the worker catches an unexpected IOException, the task is set to
                            state <literal>TASK_ERR</literal>.</para>
                        </listitem>
                        <listitem>
                          <para>If the worker is shutting down, set the the task to state
                              <literal>TASK_RESIGNED</literal>.</para>
                        </listitem>
                        <listitem>
                          <para>If the task is taken by another worker, just log it.</para>
                        </listitem>
                      </itemizedlist>
                    </listitem>
                  </itemizedlist>
                </step>
                <step>
                  <title>The split log manager monitors for uncompleted tasks.</title>
                  <para>The split log manager returns when all tasks are completed successfully. If
                    all tasks are completed with some failures, the split log manager throws an
                    exception so that the log splitting can be retried. Due to an asynchronous
                    implementation, in very rare cases, the split log manager loses track of some
                    completed tasks. For that reason, it periodically checks for remaining
                    uncompleted task in its task map or ZooKeeper. If none are found, it throws an
                    exception so that the log splitting can be retried right away instead of hanging
                    there waiting for something that won’t happen.</para>
                </step>
              </procedure>
            </section>
            <section xml:id="distributed.log.replay">
              <title>Distributed Log Replay</title>
              <para>After a RegionServer fails, its failed region is assigned to another
                RegionServer, which is marked as "recovering" in ZooKeeper. A split log worker directly
                replays edits from the WAL of the failed region server to the region at its new
                location. When a region is in "recovering" state, it can accept writes but no reads
                (including Append and Increment), region splits or merges. </para>
              <para>Distributed Log Replay extends the <xref linkend="distributed.log.splitting" /> framework. It works by
                directly replaying WAL edits to another RegionServer instead of creating
                  <filename>recovered.edits</filename> files. It provides the following advantages
                over distributed log splitting alone:</para>
              <itemizedlist>
                <listitem><para>It eliminates the overhead of writing and reading a large number of
                  <filename>recovered.edits</filename> files. It is not unusual for thousands of
                  <filename>recovered.edits</filename> files to be created and written concurrently
                  during a RegionServer recovery. Many small random writes can degrade overall
                  system performance.</para></listitem>
                <listitem><para>It allows writes even when a region is in recovering state. It only takes seconds for a recovering region to accept writes again. 
</para></listitem>
              </itemizedlist>
              <formalpara>
                <title>Enabling Distributed Log Replay</title>
                <para>To enable distributed log replay, set <varname>hbase.master.distributed.log.replay</varname> to
                  true. This will be the default for HBase 0.99 (<link
                    xlink:href="https://issues.apache.org/jira/browse/HBASE-10888">HBASE-10888</link>).</para>
              </formalpara>
              <para>You must also enable HFile version 3 (which is the default HFile format starting
                in HBase 0.99. See <link
                  xlink:href="https://issues.apache.org/jira/browse/HBASE-10855">HBASE-10855</link>).
                Distributed log replay is unsafe for rolling upgrades.</para>
            </section>
          </section>
        </section>
        <section xml:id="wal.disable">
          <title>Disabling the WAL</title>
          <para>It is possible to disable the WAL, to improve performace in certain specific
            situations. However, disabling the WAL puts your data at risk. The only situation where
            this is recommended is during a bulk load. This is because, in the event of a problem,
            the bulk load can be re-run with no risk of data loss.</para>
          <para>The WAL is disabled by calling the HBase client field
              <code>Mutation.writeToWAL(false)</code>. Use the
              <code>Mutation.setDurability(Durability.SKIP_WAL)</code> and Mutation.getDurability()
            methods to set and get the field's value. There is no way to disable the WAL for only a
            specific table.</para>
          <warning>
            <para>If you disable the WAL for anything other than bulk loads, your data is at
              risk.</para></warning>
        </section>
      </section>

    </section>  <!--  regionserver -->

    <section xml:id="regions.arch">
    <title>Regions</title>
    <para>Regions are the basic element of availability and
     distribution for tables, and are comprised of a Store per Column Family. The heirarchy of objects
     is as follows:
<programlisting>
<filename>Table</filename>       (HBase table)
    <filename>Region</filename>       (Regions for the table)
         <filename>Store</filename>          (Store per ColumnFamily for each Region for the table)
              <filename>MemStore</filename>           (MemStore for each Store for each Region for the table)
              <filename>StoreFile</filename>          (StoreFiles for each Store for each Region for the table)
                    <filename>Block</filename>             (Blocks within a StoreFile within a Store for each Region for the table)
 </programlisting>
     For a description of what HBase files look like when written to HDFS, see <xref linkend="trouble.namenode.hbase.objects"/>.
            </para>
    <section xml:id="arch.regions.size">
      <title>Considerations for Number of Regions</title>
<para> In general, HBase is designed to run with a small (20-200) number of relatively large (5-20Gb) regions per server. The considerations for this are as follows:</para>
<section xml:id="too_many_regions">
          <title>Why cannot I have too many regions?</title>
          <para>
              Typically you want to keep your region count low on HBase for numerous reasons.
              Usually right around 100 regions per RegionServer has yielded the best results.
              Here are some of the reasons below for keeping region count low:</para>
              <orderedlist>
                  <listitem><para>
                          MSLAB requires 2mb per memstore (that's 2mb per family per region).
                          1000 regions that have 2 families each is 3.9GB of heap used, and it's not even storing data yet. NB: the 2MB value is configurable.
                  </para></listitem>
                  <listitem><para>If you fill all the regions at somewhat the same rate, the global memory usage makes it that it forces tiny
                          flushes when you have too many regions which in turn generates compactions.
                          Rewriting the same data tens of times is the last thing you want.
                          An example is filling 1000 regions (with one family) equally and let's consider a lower bound for global memstore
                          usage of 5GB (the region server would have a big heap).
                          Once it reaches 5GB it will force flush the biggest region,
                          at that point they should almost all have about 5MB of data so
                          it would flush that amount. 5MB inserted later, it would flush another
                          region that will now have a bit over 5MB of data, and so on.
                          This is currently the main limiting factor for the number of regions; see <xref linkend="ops.capacity.regions.count" />
                          for detailed formula.
                  </para></listitem>
                  <listitem><para>The master as is is allergic to tons of regions, and will
                          take a lot of time assigning them and moving them around in batches.
                          The reason is that it's heavy on ZK usage, and it's not very async
                          at the moment (could really be improved -- and has been imporoved a bunch
                          in 0.96 hbase).
                  </para></listitem>
                  <listitem><para>
                          In older versions of HBase (pre-v2 hfile, 0.90 and previous), tons of regions
                          on a few RS can cause the store file index to rise, increasing heap usage and potentially
                          creating memory pressure or OOME on the RSs
                  </para></listitem>
          </orderedlist>
            <para>Another issue is the effect of the number of regions on mapreduce jobs; it is typical to have one mapper per HBase region.
              Thus, hosting only 5 regions per RS may not be enough to get sufficient number of tasks for a mapreduce job, while 1000 regions will generate far too many tasks.
            </para>
            <para>See <xref linkend="ops.capacity.regions" /> for configuration guidelines.</para>

      </section>

    </section>

      <section xml:id="regions.arch.assignment">
        <title>Region-RegionServer Assignment</title>
        <para>This section describes how Regions are assigned to RegionServers.
         </para>

        <section xml:id="regions.arch.assignment.startup">
          <title>Startup</title>
          <para>When HBase starts regions are assigned as follows (short version):
            <orderedlist>
              <listitem><para>The Master invokes the <code>AssignmentManager</code> upon startup.</para>
              </listitem>
              <listitem><para>The <code>AssignmentManager</code> looks at the existing region assignments in META.</para>
              </listitem>
              <listitem><para>If the region assignment is still valid (i.e., if the RegionServer is still online)
                then the assignment is kept.</para>
              </listitem>
              <listitem><para>If the assignment is invalid, then the <code>LoadBalancerFactory</code> is invoked to assign the
                region.  The <code>DefaultLoadBalancer</code> will randomly assign the region to a RegionServer.</para>
              </listitem>
              <listitem><para>META is updated with the RegionServer assignment (if needed) and the RegionServer start codes
              (start time of the RegionServer process) upon region opening by the RegionServer.</para>
              </listitem>
           </orderedlist>
          </para>
        </section>

        <section
          xml:id="regions.arch.assignment.failover">
          <title>Failover</title>
          <para>When a RegionServer fails: <orderedlist>
              <listitem>
                <para>The regions immediately become unavailable because the RegionServer is
                  down.</para>
              </listitem>
              <listitem>
                <para>The Master will detect that the RegionServer has failed.</para>
              </listitem>
              <listitem>
                <para>The region assignments will be considered invalid and will be re-assigned just
                  like the startup sequence.</para>
              </listitem>
              <listitem>
                <para>In-flight queries are re-tried, and not lost.</para>
              </listitem>
              <listitem>
                <para>Operations are switched to a new RegionServer within the following amount of
                  time:</para>
                <programlisting>ZooKeeper session timeout + split time + assignment/replay time</programlisting>
              </listitem>
            </orderedlist>
          </para>
        </section>

        <section xml:id="regions.arch.balancer">
          <title>Region Load Balancing</title>
          <para>
          Regions can be periodically moved by the <xref linkend="master.processes.loadbalancer" />.
          </para>
        </section>

      </section>  <!--  assignment -->

      <section xml:id="regions.arch.locality">
        <title>Region-RegionServer Locality</title>
        <para>Over time, Region-RegionServer locality is achieved via HDFS block replication.
          The HDFS client does the following by default when choosing locations to write replicas:</para>
           <orderedlist>
             <listitem><para>First replica is written to local node</para>
             </listitem>
             <listitem><para>Second replica is written to a random node on another rack</para>
             </listitem>
             <listitem><para>Third replica is written on the same rack as the second, but on a different node chosen randomly</para>
             </listitem>
             <listitem><para>Subsequent replicas are written on random nodes on the cluster
<footnote><para>See <emphasis>Replica Placement: The First Baby Steps</emphasis> on this page: <link xlink:href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html">HDFS Architecture</link></para></footnote>
             </para></listitem>
           </orderedlist>
        <para>
          Thus, HBase eventually achieves locality for a region after a flush or a compaction.
          In a RegionServer failover situation a RegionServer may be assigned regions with non-local
          StoreFiles (because none of the replicas are local), however as new data is written
          in the region, or the table is compacted and StoreFiles are re-written, they will become "local"
          to the RegionServer.
        </para>
        <para>For more information, see <emphasis>Replica Placement: The First Baby Steps</emphasis> on this page: <link xlink:href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html">HDFS Architecture</link>
        and also Lars George's blog on <link xlink:href="http://www.larsgeorge.com/2010/05/hbase-file-locality-in-hdfs.html">HBase and HDFS locality</link>.
        </para>
      </section>

      <section xml:id="arch.region.splits">
        <title>Region Splits</title>
        <para>Regions split when they reach a configured threshold.
        Below we treat the topic in short.  For a longer exposition,
        see <link xlink:href="http://hortonworks.com/blog/apache-hbase-region-splitting-and-merging/">Apache HBase Region Splitting and Merging</link>
        by our Enis Soztutar.
        </para>

        <para>Splits run unaided on the RegionServer; i.e. the Master does not
        participate. The RegionServer splits a region, offlines the split
        region and then adds the daughter regions to META, opens daughters on
        the parent's hosting RegionServer and then reports the split to the
        Master. See <xref linkend="disable.splitting" /> for how to manually manage
        splits (and for why you might do this)</para>
        <section>
          <title>Custom Split Policies</title>
          <para>The default split policy can be overwritten using a custom <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/regionserver/RegionSplitPolicy.html">RegionSplitPolicy</link> (HBase 0.94+).
          Typically a custom split policy should extend HBase's default split policy: <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/regionserver/ConstantSizeRegionSplitPolicy.html">ConstantSizeRegionSplitPolicy</link>.
          </para>
          <para>The policy can set globally through the HBaseConfiguration used or on a per table basis:
<programlisting language="java">
HTableDescriptor myHtd = ...;
myHtd.setValue(HTableDescriptor.SPLIT_POLICY, MyCustomSplitPolicy.class.getName());
</programlisting>
          </para>
        </section>
      </section>

       <section>
        <title>Online Region Merges</title>

        <para>Both Master and Regionserver participate in the event of online region merges.
        Client sends merge RPC to master, then master moves the regions together to the
        same regionserver where the more heavily loaded region resided, finally master
        send merge request to this regionserver and regionserver run the region merges.
        Similar with process of region splits, region merges run as a local transaction
        on the regionserver, offlines the regions and then merges two regions on the file
        system, atomically delete merging regions from META and add merged region to the META,
        opens merged region on the regionserver and reports the merge to Master at last.
        </para>
        <para>An example of region merges in the hbase shell
          <programlisting language="bourne">$ hbase> merge_region 'ENCODED_REGIONNAME', 'ENCODED_REGIONNAME'
          hbase> merge_region 'ENCODED_REGIONNAME', 'ENCODED_REGIONNAME', true
          </programlisting>
          It's an asynchronous operation and call returns immediately without waiting merge completed.
          Passing 'true' as the optional third parameter will force a merge ('force' merges regardless
          else merge will fail unless passed adjacent regions. 'force' is for expert use only)
        </para>
      </section>

      <section xml:id="store">
          <title>Store</title>
          <para>A Store hosts a MemStore and 0 or more StoreFiles (HFiles). A Store corresponds to a column family for a table for a given region.
          </para>
      <section
          xml:id="store.memstore">
      <title>MemStore</title>
          <para>The MemStore holds in-memory modifications to the Store. Modifications are
            Cells/KeyValues. When a flush is requested, the current memstore is moved to a snapshot and is
            cleared. HBase continues to serve edits from the new memstore and backing snapshot until
            the flusher reports that the flush succeeded. At this point, the snapshot is discarded.
            Note that when the flush happens, Memstores that belong to the same region will all be
            flushed.</para>
      </section>
        <section>
          <title>MemStoreFlush</title>
          <para> A MemStore flush can be triggered under any of the conditions listed below. The
            minimum flush unit is per region, not at individual MemStore level.</para>
          <orderedlist>
            <listitem>
              <para>When a MemStore reaches the value specified by
                  <varname>hbase.hregion.memstore.flush.size</varname>, all MemStores that belong to
                its region will be flushed out to disk.</para>
            </listitem>
            <listitem>
              <para>When overall memstore usage reaches the value specified by
                  <varname>hbase.regionserver.global.memstore.upperLimit</varname>, MemStores from
                various regions will be flushed out to disk to reduce overall MemStore usage in a
                Region Server. The flush order is based on the descending order of a region's
                MemStore usage. Regions will have their MemStores flushed until the overall MemStore
                usage drops to or slightly below
                  <varname>hbase.regionserver.global.memstore.lowerLimit</varname>. </para>
            </listitem>
            <listitem>
              <para>When the number of HLog per region server reaches the value specified in
                  <varname>hbase.regionserver.max.logs</varname>, MemStores from various regions
                will be flushed out to disk to reduce HLog count. The flush order is based on time.
                Regions with the oldest MemStores are flushed first until HLog count drops below
                  <varname>hbase.regionserver.max.logs</varname>. </para>
            </listitem>
          </orderedlist>
        </section>
        <section xml:id="hregion.scans">
          <title>Scans</title>
          <itemizedlist>
            <listitem>
              <para> When a client issues a scan against a table, HBase generates
                  <code>RegionScanner</code> objects, one per region, to serve the scan request.
              </para>
            </listitem>
            <listitem>
              <para>The <code>RegionScanner</code> object contains a list of
                  <code>StoreScanner</code> objects, one per column family. </para>
            </listitem>
            <listitem>
              <para>Each <code>StoreScanner</code> object further contains a list of
                  <code>StoreFileScanner</code> objects, corresponding to each StoreFile and
                HFile of the corresponding column family, and a list of
                  <code>KeyValueScanner</code> objects for the MemStore. </para>
            </listitem>
            <listitem>
              <para>The two lists are merge into one, which is sorted in ascending order with the
                scan object for the MemStore at the end of the list.</para>
            </listitem>
            <listitem>
              <para>When a <code>StoreFileScanner</code> object is constructed, it is associated
                with a <code>MultiVersionConsistencyControl</code> read point, which is the
                current <code>memstoreTS</code>, filtering out any new updates beyond the read
                point. </para>
            </listitem>
          </itemizedlist>
      </section>
  <section xml:id="hfile">
      <title>StoreFile (HFile)</title>
      <para>StoreFiles are where your data lives.
      </para>
      <section><title>HFile Format</title>
          <para>The <emphasis>hfile</emphasis> file format is based on
              the SSTable file described in the <link xlink:href="http://research.google.com/archive/bigtable.html">BigTable [2006]</link> paper and on
              Hadoop's <link xlink:href="http://hadoop.apache.org/common/docs/current/api/org/apache/hadoop/io/file/tfile/TFile.html">tfile</link>
              (The unit test suite and the compression harness were taken directly from tfile).
              Schubert Zhang's blog post on <link xlink:href="http://cloudepr.blogspot.com/2009/09/hfile-block-indexed-file-format-to.html">HFile: A Block-Indexed File Format to Store Sorted Key-Value Pairs</link> makes for a thorough introduction to HBase's hfile.  Matteo Bertozzi has also put up a
              helpful description, <link xlink:href="http://th30z.blogspot.com/2011/02/hbase-io-hfile.html?spref=tw">HBase I/O: HFile</link>.
          </para>
          <para>For more information, see the <link xlink:href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/io/hfile/HFile.html">HFile source code</link>.
          Also see <xref linkend="hfilev2"/> for information about the HFile v2 format that was included in 0.92.
          </para>
      </section>
      <section xml:id="hfile_tool">
        <title>HFile Tool</title>

        <para>To view a textualized version of hfile content, you can do use
        the <classname>org.apache.hadoop.hbase.io.hfile.HFile
        </classname>tool. Type the following to see usage:<programlisting language="bourne"><code>$ ${HBASE_HOME}/bin/hbase org.apache.hadoop.hbase.io.hfile.HFile </code> </programlisting>For
        example, to view the content of the file
        <filename>hdfs://10.81.47.41:8020/hbase/TEST/1418428042/DSMP/4759508618286845475</filename>,
        type the following:<programlisting language="bourne"> <code>$ ${HBASE_HOME}/bin/hbase org.apache.hadoop.hbase.io.hfile.HFile -v -f hdfs://10.81.47.41:8020/hbase/TEST/1418428042/DSMP/4759508618286845475 </code> </programlisting>If
        you leave off the option -v to see just a summary on the hfile. See
        usage for other things to do with the <classname>HFile</classname>
        tool.</para>
      </section>
      <section xml:id="store.file.dir">
       <title>StoreFile Directory Structure on HDFS</title>
        <para>For more information of what StoreFiles look like on HDFS with respect to the directory structure, see <xref linkend="trouble.namenode.hbase.objects" />.
        </para>
      </section>
      </section> <!--  hfile -->

      <section xml:id="hfile.blocks">
        <title>Blocks</title>
        <para>StoreFiles are composed of blocks.  The blocksize is configured on a per-ColumnFamily basis.
        </para>
        <para>Compression happens at the block level within StoreFiles.  For more information on compression, see <xref linkend="compression"/>.
        </para>
        <para>For more information on blocks, see the <link xlink:href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/io/hfile/HFileBlock.html">HFileBlock source code</link>.
        </para>
      </section>
      <section xml:id="keyvalue">
        <title>KeyValue</title>
        <para>The KeyValue class is the heart of data storage in HBase.  KeyValue wraps a byte array and takes offsets and lengths into passed array
         at where to start interpreting the content as KeyValue.
        </para>
        <para>The KeyValue format inside a byte array is:
           <itemizedlist>
             <listitem><para>keylength</para></listitem>
             <listitem><para>valuelength</para></listitem>
             <listitem><para>key</para></listitem>
             <listitem><para>value</para></listitem>
           </itemizedlist>
        </para>
        <para>The Key is further decomposed as:
           <itemizedlist>
             <listitem><para>rowlength</para></listitem>
             <listitem><para>row (i.e., the rowkey)</para></listitem>
             <listitem><para>columnfamilylength</para></listitem>
             <listitem><para>columnfamily</para></listitem>
             <listitem><para>columnqualifier</para></listitem>
             <listitem><para>timestamp</para></listitem>
             <listitem><para>keytype (e.g., Put, Delete, DeleteColumn, DeleteFamily)</para></listitem>
           </itemizedlist>
        </para>
        <para>KeyValue instances are <emphasis>not</emphasis> split across blocks.
         For example, if there is an 8 MB KeyValue, even if the block-size is 64kb this KeyValue will be read
         in as a coherent block.  For more information, see the <link xlink:href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/KeyValue.html">KeyValue source code</link>.
        </para>
        <section xml:id="keyvalue.example"><title>Example</title>
          <para>To emphasize the points above, examine what happens with two Puts for two different columns for the same row:</para>
           <itemizedlist>
             <listitem><para>Put #1:  <code>rowkey=row1, cf:attr1=value1</code></para></listitem>
             <listitem><para>Put #2:  <code>rowkey=row1, cf:attr2=value2</code></para></listitem>
             </itemizedlist>
          <para>Even though these are for the same row, a KeyValue is created for each column:</para>
          <para>Key portion for Put #1:
           <itemizedlist>
             <listitem><para>rowlength <code>------------&gt; 4</code></para></listitem>
             <listitem><para>row <code>-----------------&gt; row1</code></para></listitem>
             <listitem><para>columnfamilylength <code>---&gt; 2</code></para></listitem>
             <listitem><para>columnfamily <code>--------&gt; cf</code></para></listitem>
             <listitem><para>columnqualifier <code>------&gt; attr1</code></para></listitem>
             <listitem><para>timestamp <code>-----------&gt; server time of Put</code></para></listitem>
             <listitem><para>keytype <code>-------------&gt; Put</code></para></listitem>
           </itemizedlist>
          </para>
          <para>Key portion for Put #2:
           <itemizedlist>
             <listitem><para>rowlength <code>------------&gt; 4</code></para></listitem>
             <listitem><para>row <code>-----------------&gt; row1</code></para></listitem>
             <listitem><para>columnfamilylength <code>---&gt; 2</code></para></listitem>
             <listitem><para>columnfamily <code>--------&gt; cf</code></para></listitem>
             <listitem><para>columnqualifier <code>------&gt; attr2</code></para></listitem>
             <listitem><para>timestamp <code>-----------&gt; server time of Put</code></para></listitem>
             <listitem><para>keytype <code>-------------&gt; Put</code></para></listitem>
           </itemizedlist>
           <!--  trying to get the above arrows to line up at the same horizontal position has proven
           harder than I thought -->
          </para>
          <para>It is critical to understand that the rowkey, ColumnFamily, and column (aka columnqualifier) are embedded within
            the KeyValue instance.  The longer these identifiers are, the bigger the KeyValue is.</para>
        </section>

      </section>
        <section
          xml:id="compaction">
          <title>Compaction</title>
          <itemizedlist>
            <title>Ambiguous Terminology</title>
            <listitem><para>A <firstterm>StoreFile</firstterm> is a facade of HFile. In terms of compaction, use of
              StoreFile seems to have prevailed in the past.</para></listitem>
            <listitem><para>A <firstterm>Store</firstterm> is the same thing as a ColumnFamily.
              StoreFiles are related to a Store, or ColumnFamily.</para></listitem>
            <listitem>
              <para>If you want to read more about StoreFiles versus HFiles and Stores versus
                ColumnFamilies, see <link
                  xlink:href="https://issues.apache.org/jira/browse/HBASE-11316">HBASE-11316</link>.</para>
            </listitem>
          </itemizedlist>
          <para>When the MemStore reaches a given size
              (<code>hbase.hregion.memstore.flush.size)</code>, it flushes its contents to a
            StoreFile. The number of StoreFiles in a Store increases over time.
              <firstterm>Compaction</firstterm> is an operation which reduces the number of
            StoreFiles in a Store, by merging them together, in order to increase performance on
            read operations. Compactions can be resource-intensive to perform, and can either help
            or hinder performance depending on many factors. </para>
          <para>Compactions fall into two categories: minor and major. Minor and major compactions
            differ in the following ways.</para>
          <para><firstterm>Minor compactions</firstterm> usually select a small number of small,
            adjacent StoreFiles and rewrite them as a single StoreFile. Minor compactions do not
            drop (filter out) deletes or expired versions, because of potential side effects. See <xref
              linkend="compaction.and.deletes" /> and <xref
              linkend="compaction.and.versions" /> for information on how deletes and versions are
            handled in relation to compactions. The end result of a minor compaction is fewer,
            larger StoreFiles for a given Store.</para>
          <para>The end result of a <firstterm>major compaction</firstterm> is a single StoreFile
            per Store. Major compactions also process delete markers and max versions. See <xref
              linkend="compaction.and.deletes" /> and <xref
              linkend="compaction.and.versions" /> for information on how deletes and versions are
            handled in relation to compactions.</para>

          <formalpara
            xml:id="compaction.and.deletes">
            <title>Compaction and Deletions</title>
            <para> When an explicit deletion occurs in HBase, the data is not actually deleted.
              Instead, a <firstterm>tombstone</firstterm> marker is written. The tombstone marker
              prevents the data from being returned with queries. During a major compaction, the
              data is actually deleted, and the tombstone marker is removed from the StoreFile. If
              the deletion happens because of an expired TTL, no tombstone is created. Instead, the
              expired data is filtered out and is not written back to the compacted
              StoreFile.</para>
          </formalpara>

          <formalpara
            xml:id="compaction.and.versions">
            <title>Compaction and Versions</title>
            <para> When you create a Column Family, you can specify the maximum number of versions
              to keep, by specifying <varname>HColumnDescriptor.setMaxVersions(int
                versions)</varname>. The default value is <literal>3</literal>. If more versions
              than the specified maximum exist, the excess versions are filtered out and not written
              back to the compacted StoreFile.</para>
          </formalpara>

          <note>
            <title>Major Compactions Can Impact Query Results</title>
            <para> In some situations, older versions can be inadvertently resurrected if a newer
              version is explicitly deleted. See <xref
                linkend="major.compactions.change.query.results" /> for a more in-depth explanation.
              This situation is only possible before the compaction finishes. </para>
          </note>

          <para>In theory, major compactions improve performance. However, on a highly loaded
            system, major compactions can require an inappropriate number of resources and adversely
            affect performance. In a default configuration, major compactions are scheduled
            automatically to run once in a 7-day period. This is sometimes inappropriate for systems
            in production. You can manage major compactions manually. See <xref
              linkend="managed.compactions" />. </para>
          <para>Compactions do not perform region merges. See <xref
              linkend="ops.regionmgt.merge" /> for more information on region merging. </para>
          <section
            xml:id="compaction.file.selection">
            <title>Compaction Policy - HBase 0.96.x and newer</title>
            <para>Compacting large StoreFiles, or too many StoreFiles at once, can cause more IO
              load than your cluster is able to handle without causing performance problems. The
              method by which HBase selects which StoreFiles to include in a compaction (and whether
              the compaction is a minor or major compaction) is called the <firstterm>compaction
                policy</firstterm>.</para>
            <para>Prior to HBase 0.96.x, there was only one compaction policy. That original
              compaction policy is still available as
                <systemitem>RatioBasedCompactionPolicy</systemitem> The new compaction default
              policy, called <systemitem>ExploringCompactionPolicy</systemitem>, was subsequently
              backported to HBase 0.94 and HBase 0.95, and is the default in HBase 0.96 and newer.
              It was implemented in <link
                xlink:href="https://issues.apache.org/jira/browse/HBASE-7842">HBASE-7842</link>. In
              short, <systemitem>ExploringCompactionPolicy</systemitem> attempts to select the best
              possible set of StoreFiles to compact with the least amount of work, while the
                <systemitem>RatioBasedCompactionPolicy</systemitem> selects the first set that meets
              the criteria.</para>
            <para>Regardless of the compaction policy used, file selection is controlled by several
              configurable parameters and happens in a multi-step approach. These parameters will be
              explained in context, and then will be given in a table which shows their
              descriptions, defaults, and implications of changing them.</para>

            <section
              xml:id="compaction.being.stuck">
              <title>Being Stuck</title>
              <para>When the MemStore gets too large, it needs to flush its contents to a StoreFile.
                However, a Store can only have <varname>hbase.hstore.blockingStoreFiles</varname>
                files, so the MemStore needs to wait for the number of StoreFiles to be reduced by
                one or more compactions. However, if the MemStore grows larger than
                  <varname>hbase.hregion.memstore.flush.size</varname>, it is not able to flush its
                contents to a StoreFile. If the MemStore is too large and the number of StpreFo;es
                is also too high, the algorithm is said to be "stuck". The compaction algorithm
                checks for this "stuck" situation and provides mechanisms to alleviate it.</para>
            </section>

            <section
              xml:id="exploringcompaction.policy">
              <title>The ExploringCompactionPolicy Algorithm</title>
              <para>The ExploringCompactionPolicy algorithm considers each possible set of
                adjacent StoreFiles before choosing the set where compaction will have the most
                benefit. </para>
              <para>One situation where the ExploringCompactionPolicy works especially well is when
                you are bulk-loading data and the bulk loads create larger StoreFiles than the
                StoreFiles which are holding data older than the bulk-loaded data. This can "trick"
                HBase into choosing to perform a major compaction each time a compaction is needed,
                and cause a lot of extra overhead. With the ExploringCompactionPolicy, major
                compactions happen much less frequently because minor compactions are more
                efficient.</para>
              <para>In general, ExploringCompactionPolicy is the right choice for most situations,
                and thus is the default compaction policy. You can also use
                ExploringCompactionPolicy along with <xref
                  linkend="ops.stripe" />.</para>
              <para>The logic of this policy can be examined in
                  <filename>hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/ExploringCompactionPolicy.java</filename>.
                The following is a walk-through of the logic of the
                ExploringCompactionPolicy.</para>
              <procedure>
                <step>
                  <para>Make a list of all existing StoreFiles in the Store. The rest of the
                    algorithm filters this list to come up with the subset of HFiles which will be
                    chosen for compaction.</para>
                </step>
                <step>
                  <para>If this was a user-requested compaction, attempt to perform the requested
                    compaction type, regardless of what would normally be chosen. Note that even if
                    the user requests a major compaction, it may not be possible to perform a major
                    compaction. This may be because not all StoreFiles in the Column Family are
                    available to compact or because there are too many Stores in the Column
                    Family.</para>
                </step>
                <step>
                  <para>Some StoreFiles are automatically excluded from consideration. These
                    include:</para>
                  <itemizedlist>
                    <listitem>
                      <para>StoreFiles that are larger than
                          <varname>hbase.hstore.compaction.max.size</varname></para>
                    </listitem>
                    <listitem>
                      <para>StoreFiles that were created by a bulk-load operation which explicitly
                        excluded compaction. You may decide to exclude StoreFiles resulting from
                        bulk loads, from compaction. To do this, specify the
                          <varname>hbase.mapreduce.hfileoutputformat.compaction.exclude</varname>
                        parameter during the bulk load operation.</para>
                    </listitem>
                  </itemizedlist>
                </step>
                <step>
                  <para>Iterate through the list from step 1, and make a list of all potential sets
                    of StoreFiles to compact together. A potential set is a grouping of
                      <varname>hbase.hstore.compaction.min</varname> contiguous StoreFiles in the
                    list. For each set, perform some sanity-checking and figure out whether this is
                    the best compaction that could be done:</para>
                  <itemizedlist>
                    <listitem>
                      <para>If the number of StoreFiles in this set (not the size of the StoreFiles)
                        is fewer than <varname>hbase.hstore.compaction.min</varname> or more than
                          <varname>hbase.hstore.compaction.max</varname>, take it out of
                        consideration.</para>
                    </listitem>
                    <listitem>
                      <para>Compare the size of this set of StoreFiles with the size of the smallest
                        possible compaction that has been found in the list so far. If the size of
                        this set of StoreFiles represents the smallest compaction that could be
                        done, store it to be used as a fall-back if the algorithm is "stuck" and no
                        StoreFiles would otherwise be chosen. See <xref
                          linkend="compaction.being.stuck" />.</para>
                    </listitem>
                    <listitem>
                      <para>Do size-based sanity checks against each StoreFile in this set of
                        StoreFiles.</para>
                      <itemizedlist>
                        <listitem>
                          <para>If the size of this StoreFile is larger than
                              <varname>hbase.hstore.compaction.max.size</varname>, take it out of
                            consideration.</para>
                        </listitem>
                        <listitem>
                          <para>If the size is greater than or equal to
                              <varname>hbase.hstore.compaction.min.size</varname>, sanity-check it
                            against the file-based ratio to see whether it is too large to be
                            considered. The sanity-checking is successful if:</para>
                          <itemizedlist>
                            <listitem>
                              <para>There is only one StoreFile in this set, or</para>
                            </listitem>
                            <listitem>
                              <para>For each StoreFile, its size multiplied by
                                  <varname>hbase.hstore.compaction.ratio</varname> (or
                                  <varname>hbase.hstore.compaction.ratio.offpeak</varname> if
                                off-peak hours are configured and it is during off-peak hours) is
                                less than the sum of the sizes of the other HFiles in the
                                set.</para>
                            </listitem>
                          </itemizedlist>
                        </listitem>
                      </itemizedlist>
                    </listitem>
                  </itemizedlist>
                </step>
                <step>
                  <para>If this set of StoreFiles is still in consideration, compare it to the
                    previously-selected best compaction. If it is better, replace the
                    previously-selected best compaction with this one.</para>
                </step>
                <step>
                  <para>When the entire list of potential compactions has been processed, perform
                    the best compaction that was found. If no StoreFiles were selected for
                    compaction, but there are multiple StoreFiles, assume the algorithm is stuck
                    (see <xref
                      linkend="compaction.being.stuck" />) and if so, perform the smallest
                    compaction that was found in step 3.</para>
                </step>
              </procedure>
            </section>

            <section
              xml:id="compaction.ratiobasedcompactionpolicy.algorithm">
              <title>RatioBasedCompactionPolicy Algorithm</title>
              <para>The RatioBasedCompactionPolicy was the only compaction policy prior to HBase
                0.96, though ExploringCompactionPolicy has now been backported to HBase 0.94 and
                0.95. To use the RatioBasedCompactionPolicy rather than the
                ExploringCompactionPolicy, set
                  <varname>hbase.hstore.defaultengine.compactionpolicy.class</varname> to
                  <literal>RatioBasedCompactionPolicy</literal> in the
                  <filename>hbase-site.xml</filename> file. To switch back to the
                ExploringCompactionPolicy, remove the setting from the
                  <filename>hbase-site.xml</filename>.</para>
              <para>The following section walks you through the algorithm used to select StoreFiles
                for compaction in the RatioBasedCompactionPolicy.</para>
              <procedure>
                <step>
                  <para>The first phase is to create a list of all candidates for compaction. A list
                    is created of all StoreFiles not already in the compaction queue, and all
                    StoreFiles newer than the newest file that is currently being compacted. This
                    list of StoreFiles is ordered by the sequence ID. The sequence ID is generated
                    when a Put is appended to the write-ahead log (WAL), and is stored in the
                    metadata of the HFile.</para>
                </step>
                <step>
                  <para>Check to see if the algorithm is stuck (see <xref
                      linkend="compaction.being.stuck" />, and if so, a major compaction is forced.
                    This is a key area where <xref
                      linkend="exploringcompaction.policy" /> is often a better choice than the
                    RatioBasedCompactionPolicy.</para>
                </step>
                <step>
                  <para>If the compaction was user-requested, try to perform the type of compaction
                    that was requested. Note that a major compaction may not be possible if all
                    HFiles are not available for compaction or if too may StoreFiles exist (more
                    than <varname>hbase.hstore.compaction.max</varname>).</para>
                </step>
                <step>
                  <para>Some StoreFiles are automatically excluded from consideration. These
                    include:</para>
                  <itemizedlist>
                    <listitem>
                      <para>StoreFiles that are larger than
                          <varname>hbase.hstore.compaction.max.size</varname></para>
                    </listitem>
                    <listitem>
                      <para>StoreFiles that were created by a bulk-load operation which explicitly
                        excluded compaction. You may decide to exclude StoreFiles resulting from
                        bulk loads, from compaction. To do this, specify the
                          <varname>hbase.mapreduce.hfileoutputformat.compaction.exclude</varname>
                        parameter during the bulk load operation.</para>
                    </listitem>
                  </itemizedlist>
                </step>
                <step>
                  <para>The maximum number of StoreFiles allowed in a major compaction is controlled
                    by the <varname>hbase.hstore.compaction.max</varname> parameter. If the list
                    contains more than this number of StoreFiles, a minor compaction is performed
                    even if a major compaction would otherwise have been done. However, a
                    user-requested major compaction still occurs even if there are more than
                      <varname>hbase.hstore.compaction.max</varname> StoreFiles to compact.</para>
                </step>
                <step>
                  <para>If the list contains fewer than
                      <varname>hbase.hstore.compaction.min</varname> StoreFiles to compact, a minor
                    compaction is aborted. Note that a major compaction can be performed on a single
                    HFile. Its function is to remove deletes and expired versions, and reset
                    locality on the StoreFile.</para>
                </step>
                <step>
                  <para>The value of the <varname>hbase.hstore.compaction.ratio</varname> parameter
                    is multiplied by the sum of StoreFiles smaller than a given file, to determine
                    whether that StoreFile is selected for compaction during a minor compaction. For
                    instance, if hbase.hstore.compaction.ratio is 1.2, FileX is 5 mb, FileY is 2 mb,
                    and FileZ is 3 mb:</para>
                  <screen>5 &lt;= 1.2 x (2 + 3)            or           5 &lt;= 6</screen>
                  <para>In this scenario, FileX is eligible for minor compaction. If FileX were 7
                    mb, it would not be eligible for minor compaction. This ratio favors smaller
                    StoreFile. You can configure a different ratio for use in off-peak hours, using
                    the parameter <varname>hbase.hstore.compaction.ratio.offpeak</varname>, if you
                    also configure <varname>hbase.offpeak.start.hour</varname> and
                      <varname>hbase.offpeak.end.hour</varname>.</para>
                </step>

                <step>
                  <para>If the last major compaction was too long ago and there is more than one
                    StoreFile to be compacted, a major compaction is run, even if it would otherwise
                    have been minor. By default, the maximum time between major compactions is 7
                    days, plus or minus a 4.8 hour period, and determined randomly within those
                    parameters. Prior to HBase 0.96, the major compaction period was 24 hours. See
                      <varname>hbase.hregion.majorcompaction</varname> in the table below to tune or
                    disable time-based major compactions.</para>
                </step>
              </procedure>
            </section>

            <section xml:id="compaction.parameters">

              <title>Parameters Used by Compaction Algorithm</title>
              <para>This table contains the main configuration parameters for compaction. This list
                is not exhaustive. To tune these parameters from the defaults, edit the
                  <filename>hbase-default.xml</filename> file. For a full list of all configuration
                parameters available, see <xref
                  linkend="config.files" /></para>
              <informaltable>
                <tgroup
                  cols="3">
                  <thead>
                    <row>
                      <entry>Parameter</entry>
                      <entry>Description</entry>
                      <entry>Default</entry>
                    </row>
                  </thead>
                  <tbody>
                    <row>
                      <entry>hbase.hstore.compaction.min</entry>
                      <entry><para>The minimum number of StoreFiles which must be eligible for
                          compaction before compaction can run.</para>
                        <para>The goal of tuning <varname>hbase.hstore.compaction.min</varname>
                          is to avoid ending up with too many tiny StoreFiles to compact. Setting
                          this value to <literal>2</literal> would cause a minor compaction each
                          time you have two StoreFiles in a Store, and this is probably not
                          appropriate. If you set this value too high, all the other values will
                          need to be adjusted accordingly. For most cases, the default value is
                          appropriate.</para>
                        <para>In previous versions of HBase, the parameter
                            <code>hbase.hstore.compaction.min</code> was called
                            <code>hbase.hstore.compactionThreshold</code>.</para>
                      </entry>
                      <entry>3</entry>
                    </row>
                    <row>
                      <entry>hbase.hstore.compaction.max</entry>
                      <entry><para>The maximum number of StoreFiles which will be selected for a
                          single minor compaction, regardless of the number of eligible
                          StoreFiles.</para>
                        <para>Effectively, the value of
                            <varname>hbase.hstore.compaction.max</varname> controls the length of
                          time it takes a single compaction to complete. Setting it larger means
                          that more StoreFiles are included in a compaction. For most cases, the
                          default value is appropriate.</para>
                      </entry>
                      <entry>10</entry>
                    </row>
                    <row>
                      <entry>hbase.hstore.compaction.min.size</entry>
                      <entry><para>A StoreFile smaller than this size will always be eligible for
                          minor compaction. StoreFiles this size or larger are evaluated by
                            <varname>hbase.hstore.compaction.ratio</varname> to determine if they are
                          eligible.</para>
                        <para>Because this limit represents the "automatic include" limit for
                          all StoreFiles smaller than this value, this value may need to be reduced
                          in write-heavy environments where many files in the 1-2 MB range are being
                          flushed, because every StoreFile will be targeted for compaction and the
                          resulting StoreFiles may still be under the minimum size and require
                          further compaction.</para>
                        <para>If this parameter is lowered, the ratio check is triggered more
                          quickly. This addressed some issues seen in earlier versions of HBase but
                          changing this parameter is no longer necessary in most situations.</para>
                      </entry>
                      <entry>128 MB</entry>
                    </row>
                    <row>
                      <entry>hbase.hstore.compaction.max.size</entry>
                      <entry><para>An StoreFile larger than this size will be excluded from
                          compaction. The effect of raising
                            <varname>hbase.hstore.compaction.max.size</varname> is fewer, larger
                          StoreFiles that do not get compacted often. If you feel that compaction is
                          happening too often without much benefit, you can try raising this
                          value.</para></entry>
                      <entry>Long.MAX_VALUE</entry>
                    </row>
                    <row>
                      <entry>hbase.hstore.compaction.ratio</entry>
                      <entry><para>For minor compaction, this ratio is used to determine whether a
                          given StoreFile which is larger than
                            <varname>hbase.hstore.compaction.min.size</varname> is eligible for
                          compaction. Its effect is to limit compaction of large StoreFile. The
                          value of <varname>hbase.hstore.compaction.ratio</varname> is expressed as
                          a floating-point decimal.</para>
                        <para>A large ratio, such as <literal>10</literal>, will produce a
                          single giant StoreFile. Conversely, a value of <literal>.25</literal>,
                          will produce behavior similar to the BigTable compaction algorithm,
                          producing four StoreFiles.</para>
                        <para>A moderate value of between 1.0 and 1.4 is recommended. When
                          tuning this value, you are balancing write costs with read costs. Raising
                          the value (to something like 1.4) will have more write costs, because you
                          will compact larger StoreFiles. However, during reads, HBase will need to seek
                          through fewer StpreFo;es to accomplish the read. Consider this approach if you
                          cannot take advantage of <xref
                            linkend="schema.bloom" />.</para>
                        <para>Alternatively, you can lower this value to something like 1.0 to
                          reduce the background cost of writes, and use <xref
                            linkend="schema.bloom" /> to limit the number of StoreFiles touched
                          during reads.</para>
                        <para>For most cases, the default value is appropriate.</para>
                      </entry>
                      <entry>1.2F</entry>
                    </row>
                    <row>
                      <entry>hbase.hstore.compaction.ratio.offpeak</entry>
                      <entry>The compaction ratio used during off-peak compactions, if off-peak
                        hours are also configured (see below). Expressed as a floating-point
                        decimal. This allows for more aggressive (or less aggressive, if you set it
                        lower than <varname>hbase.hstore.compaction.ratio</varname>) compaction
                        during a set time period. Ignored if off-peak is disabled (default). This
                        works the same as <varname>hbase.hstore.compaction.ratio</varname>.</entry>
                      <entry>5.0F</entry>
                    </row>
                    <row>
                      <entry>hbase.offpeak.start.hour</entry>
                      <entry>The start of off-peak hours, expressed as an integer between 0 and 23,
                        inclusive. Set to <literal>-1</literal> to disable off-peak.</entry>
                      <entry>-1 (disabled)</entry>
                    </row>
                    <row>
                      <entry>hbase.offpeak.end.hour</entry>
                      <entry>The end of off-peak hours, expressed as an integer between 0 and 23,
                        inclusive. Set to <literal>-1</literal> to disable off-peak.</entry>
                      <entry>-1 (disabled)</entry>
                    </row>
                    <row>
                      <entry>hbase.regionserver.thread.compaction.throttle</entry>
                      <entry><para>There are two different thread pools for compactions, one for
                          large compactions and the other for small compactions. This helps to keep
                          compaction of lean tables (such as <systemitem>hbase:meta</systemitem>)
                          fast. If a compaction is larger than this threshold, it goes into the
                          large compaction pool. In most cases, the default value is
                          appropriate.</para></entry>
                      <entry>2 x hbase.hstore.compaction.max x hbase.hregion.memstore.flush.size
                        (which defaults to 128)</entry>
                    </row>
                    <row>
                      <entry>hbase.hregion.majorcompaction</entry>
                      <entry><para>Time between major compactions, expressed in milliseconds. Set to
                          0 to disable time-based automatic major compactions. User-requested and
                          size-based major compactions will still run. This value is multiplied by
                            <varname>hbase.hregion.majorcompaction.jitter</varname> to cause
                          compaction to start at a somewhat-random time during a given window of
                          time.</para></entry>
                      <entry>7 days (604800000 milliseconds)</entry>
                    </row>
                    <row>
                      <entry>hbase.hregion.majorcompaction.jitter</entry>
                      <entry><para>A multiplier applied to
                            <varname>hbase.hregion.majorcompaction</varname> to cause compaction to
                          occur a given amount of time either side of
                            <varname>hbase.hregion.majorcompaction</varname>. The smaller the
                          number, the closer the compactions will happen to the
                            <varname>hbase.hregion.majorcompaction</varname> interval. Expressed as
                          a floating-point decimal.</para></entry>
                      <entry>.50F</entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable>
            </section>
          </section>
          <section
            xml:id="compaction.file.selection.old">
            <title>Compaction File Selection</title>
            <note>
              <title>Legacy Information</title>
              <para>This section has been preserved for historical reasons and refers to the way
                compaction worked prior to HBase 0.96.x. You can still use this behavior if you
                enable <xref
                  linkend="compaction.ratiobasedcompactionpolicy.algorithm" /> For information on
                the way that compactions work in HBase 0.96.x and later, see <xref
                  linkend="compaction" />.</para>
            </note>
            <para>To understand the core algorithm for StoreFile selection, there is some ASCII-art
              in the <link
                xlink:href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/regionserver/Store.html#836">Store
                source code</link> that will serve as useful reference. It has been copied below:
              <programlisting>
/* normal skew:
 *
 *         older ----> newer
 *     _
 *    | |   _
 *    | |  | |   _
 *  --|-|- |-|- |-|---_-------_-------  minCompactSize
 *    | |  | |  | |  | |  _  | |
 *    | |  | |  | |  | | | | | |
 *    | |  | |  | |  | | | | | |
 */
</programlisting>
              Important knobs: <itemizedlist>
                <listitem>
                  <para><code>hbase.hstore.compaction.ratio</code> Ratio used in compaction file
                    selection algorithm (default 1.2f).</para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.min</code> (.90
                    hbase.hstore.compactionThreshold) (files) Minimum number of StoreFiles per Store
                    to be selected for a compaction to occur (default 2).</para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.max</code> (files) Maximum number of
                    StoreFiles to compact per minor compaction (default 10).</para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.min.size</code> (bytes) Any StoreFile smaller
                    than this setting with automatically be a candidate for compaction. Defaults to
                      <code>hbase.hregion.memstore.flush.size</code> (128 mb). </para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.max.size</code> (.92) (bytes) Any StoreFile
                    larger than this setting with automatically be excluded from compaction (default
                    Long.MAX_VALUE). </para>
                </listitem>
              </itemizedlist>
            </para>
            <para>The minor compaction StoreFile selection logic is size based, and selects a file
              for compaction when the file &lt;= sum(smaller_files) *
                <code>hbase.hstore.compaction.ratio</code>. </para>

          <section
            xml:id="compaction.file.selection.example1">
            <title>Minor Compaction File Selection - Example #1 (Basic Example)</title>
            <para>This example mirrors an example from the unit test
                <code>TestCompactSelection</code>.</para>
            <itemizedlist>
              <listitem>
                <para><code>hbase.hstore.compaction.ratio</code> = 1.0f </para>
              </listitem>
              <listitem>
                <para><code>hbase.hstore.compaction.min</code> = 3 (files) </para>
              </listitem>
              <listitem>
                <para><code>hbase.hstore.compaction.max</code> = 5 (files) </para>
              </listitem>
              <listitem>
                <para><code>hbase.hstore.compaction.min.size</code> = 10 (bytes) </para>
              </listitem>
              <listitem>
                <para><code>hbase.hstore.compaction.max.size</code> = 1000 (bytes) </para>
              </listitem>
            </itemizedlist>
            <para> The following StoreFiles exist: 100, 50, 23, 12, and 12 bytes apiece (oldest to
              newest). With the above parameters, the files that would be selected for minor
              compaction are 23, 12, and 12. </para>
            <para>Why? <itemizedlist>
                <listitem>
                  <para>100 --&gt; No, because sum(50, 23, 12, 12) * 1.0 = 97. </para>
                </listitem>
                <listitem>
                  <para>50 --&gt; No, because sum(23, 12, 12) * 1.0 = 47. </para>
                </listitem>
                <listitem>
                  <para>23 --&gt; Yes, because sum(12, 12) * 1.0 = 24. </para>
                </listitem>
                <listitem>
                  <para>12 --&gt; Yes, because the previous file has been included, and because this
                    does not exceed the the max-file limit of 5 </para>
                </listitem>
                <listitem>
                  <para>12 --&gt; Yes, because the previous file had been included, and because this
                    does not exceed the the max-file limit of 5.</para>
                </listitem>
              </itemizedlist>
            </para>
          </section>
          <section
            xml:id="compaction.file.selection.example2">
            <title>Minor Compaction File Selection - Example #2 (Not Enough Files To
              Compact)</title>
            <para>This example mirrors an example from the unit test
                <code>TestCompactSelection</code>. <itemizedlist>
                <listitem>
                  <para><code>hbase.hstore.compaction.ratio</code> = 1.0f </para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.min</code> = 3 (files) </para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.max</code> = 5 (files)</para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.min.size</code> = 10 (bytes) </para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.max.size</code> = 1000 (bytes) </para>
                </listitem>
              </itemizedlist>
            </para>
            <para>The following StoreFiles exist: 100, 25, 12, and 12 bytes apiece (oldest to
              newest). With the above parameters, no compaction will be started. </para>
            <para>Why? <itemizedlist>
                <listitem>
                  <para>100 --&gt; No, because sum(25, 12, 12) * 1.0 = 47</para>
                </listitem>
                <listitem>
                  <para>25 --&gt; No, because sum(12, 12) * 1.0 = 24</para>
                </listitem>
                <listitem>
                  <para>12 --&gt; No. Candidate because sum(12) * 1.0 = 12, there are only 2 files
                    to compact and that is less than the threshold of 3</para>
                </listitem>
                <listitem>
                  <para>12 --&gt; No. Candidate because the previous StoreFile was, but there are
                    not enough files to compact</para>
                </listitem>
              </itemizedlist>
            </para>
          </section>
          <section
            xml:id="compaction.file.selection.example3">
            <title>Minor Compaction File Selection - Example #3 (Limiting Files To Compact)</title>
            <para>This example mirrors an example from the unit test
                <code>TestCompactSelection</code>. <itemizedlist>
                <listitem>
                  <para><code>hbase.hstore.compaction.ratio</code> = 1.0f </para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.min</code> = 3 (files) </para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.max</code> = 5 (files)</para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.min.size</code> = 10 (bytes) </para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.max.size</code> = 1000 (bytes) </para>
                </listitem>
              </itemizedlist> The following StoreFiles exist: 7, 6, 5, 4, 3, 2, and 1 bytes apiece
              (oldest to newest). With the above parameters, the files that would be selected for
              minor compaction are 7, 6, 5, 4, 3. </para>
            <para>Why? <itemizedlist>
                <listitem>
                  <para>7 --&gt; Yes, because sum(6, 5, 4, 3, 2, 1) * 1.0 = 21. Also, 7 is less than
                    the min-size</para>
                </listitem>
                <listitem>
                  <para>6 --&gt; Yes, because sum(5, 4, 3, 2, 1) * 1.0 = 15. Also, 6 is less than
                    the min-size. </para>
                </listitem>
                <listitem>
                  <para>5 --&gt; Yes, because sum(4, 3, 2, 1) * 1.0 = 10. Also, 5 is less than the
                    min-size. </para>
                </listitem>
                <listitem>
                  <para>4 --&gt; Yes, because sum(3, 2, 1) * 1.0 = 6. Also, 4 is less than the
                    min-size. </para>
                </listitem>
                <listitem>
                  <para>3 --&gt; Yes, because sum(2, 1) * 1.0 = 3. Also, 3 is less than the
                    min-size. </para>
                </listitem>
                <listitem>
                  <para>2 --&gt; No. Candidate because previous file was selected and 2 is less than
                    the min-size, but the max-number of files to compact has been reached. </para>
                </listitem>
                <listitem>
                  <para>1 --&gt; No. Candidate because previous file was selected and 1 is less than
                    the min-size, but max-number of files to compact has been reached. </para>
                </listitem>
              </itemizedlist>
            </para>
            <section
              xml:id="compaction.config.impact">
              <title>Impact of Key Configuration Options</title>
              <note>
                <para>This information is now included in the configuration parameter table in <xref
                    linkend="compaction.configuration.parameters" />.</para>
              </note>
            </section>
          </section>
          </section>
          <section
            xml:id="ops.stripe">
            <title>Experimental: Stripe Compactions</title>
            <para> Stripe compactions is an experimental feature added in HBase 0.98 which aims to
              improve compactions for large regions or non-uniformly distributed row keys. In order
              to achieve smaller and/or more granular compactions, the StoreFiles within a region
              are maintained separately for several row-key sub-ranges, or "stripes", of the region.
              The stripes are transparent to the rest of HBase, so other operations on the HFiles or
              data work without modification.</para>
            <para>Stripe compactions change the HFile layout, creating sub-regions within regions.
              These sub-regions are easier to compact, and should result in fewer major compactions.
              This approach alleviates some of the challenges of larger regions.</para>
            <para>Stripe compaction is fully compatible with <xref
                linkend="compaction" /> and works in conjunction with either the
              ExploringCompactionPolicy or RatioBasedCompactionPolicy. It can be enabled for
              existing tables, and the table will continue to operate normally if it is disabled
              later. </para>
          </section>
          <section
            xml:id="ops.stripe.when">
            <title>When To Use Stripe Compactions</title>
            <para>Consider using stripe compaction if you have either of the following:</para>
            <itemizedlist>
              <listitem>
                <para>Large regions. You can get the positive effects of smaller regions without
                  additional overhead for MemStore and region management overhead.</para>
              </listitem>
              <listitem>
                <para>Non-uniform keys, such as time dimension in a key. Only the stripes receiving
                  the new keys will need to compact. Old data will not compact as often, if at
                  all</para>
              </listitem>
            </itemizedlist>
            <formalpara>
              <title>Performance Improvements</title>
              <para>Performance testing has shown that the performance of reads improves somewhat,
                and variability of performance of reads and writes is greatly reduced. An overall
                long-term performance improvement is seen on large non-uniform-row key regions, such
                as a hash-prefixed timestamp key. These performance gains are the most dramatic on a
                table which is already large. It is possible that the performance improvement might
                extend to region splits.</para>
            </formalpara>
            <section
              xml:id="ops.stripe.enable">
              <title>Enabling Stripe Compaction</title>
              <para>You can enable stripe compaction for a table or a column family, by setting its
                  <varname>hbase.hstore.engine.class</varname> to
                  <varname>org.apache.hadoop.hbase.regionserver.StripeStoreEngine</varname>. You
                also need to set the <varname>hbase.hstore.blockingStoreFiles</varname> to a high
                number, such as 100 (rather than the default value of 10).</para>
              <procedure>
                <title>Enable Stripe Compaction</title>
                <step>
                  <para>If the table already exists, disable the table.</para>
                </step>
                <step>
                  <para>Run one of following commands in the HBase shell. Replace the table name
                      <literal>orders_table</literal> with the name of your table.</para>
                  <screen language="sql">
<userinput>alter 'orders_table', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.StripeStoreEngine', 'hbase.hstore.blockingStoreFiles' => '100'}</userinput>
<userinput>alter 'orders_table', {NAME => 'blobs_cf', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.StripeStoreEngine', 'hbase.hstore.blockingStoreFiles' => '100'}}</userinput>
<userinput>create 'orders_table', 'blobs_cf', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.StripeStoreEngine', 'hbase.hstore.blockingStoreFiles' => '100'}</userinput>                  
                </screen>
                </step>
                <step>
                  <para>Configure other options if needed. See <xref
                      linkend="ops.stripe.config" /> for more information.</para>
                </step>
                <step>
                  <para>Enable the table.</para>
                </step>
              </procedure>

              <procedure>
                <title>Disable Stripe Compaction</title>
                <step>
                  <para>Disable the table.</para>
                </step>
                <step>
                  <para>Set the <varname>hbase.hstore.engine.class</varname> option to either nil or
                      <literal>org.apache.hadoop.hbase.regionserver.DefaultStoreEngine</literal>.
                    Either option has the same effect.</para>
                  <screen language="sql">
<userinput>alter 'orders_table', CONFIGURATION => {'hbase.hstore.engine.class' => ''}</userinput>
                </screen>
                </step>
                <step>
                  <para>Enable the table.</para>
                </step>
              </procedure>
              <para> When you enable a large table after changing the store engine either way, a
                major compaction will likely be performed on most regions. This is not necessary on
                new tables.</para>
            </section>
            <section
              xml:id="ops.stripe.config">
              <title>Configuring Stripe Compaction</title>
              <para>Each of the settings for stripe compaction should be configured at the table or
                column family, after disabling the table. If you use HBase shell, the general
                command pattern is as follows:</para>

              <programlisting language="sql">
alter 'orders_table', CONFIGURATION => {'key' => 'value', ..., 'key' => 'value'}}
              </programlisting>
              <section
                xml:id="ops.stripe.config.sizing">
                <title>Region and stripe sizing</title>
                <para>You can configure your stripe sizing bsaed upon your region sizing. By
                  default, your new regions will start with one stripe. On the next compaction after
                  the stripe has grown too large (16 x MemStore flushes size), it is split into two
                  stripes. Stripe splitting continues as the region grows, until the region is large
                  enough to split.</para>
                <para>You can improve this pattern for your own data. A good rule is to aim for a
                  stripe size of at least 1 GB, and about 8-12 stripes for uniform row keys. For
                  example, if your regions are 30 GB, 12 x 2.5 GB stripes might be a good starting
                  point.</para>

                <table
                  frame="all">
                  <title>Stripe Sizing Settings</title>
                  <tgroup
                    cols="2"
                    align="left"
                    colsep="1"
                    rowsep="1">
                    <colspec
                      colname="c1" />
                    <colspec
                      colname="c2" />
                    <thead>
                      <row>
                        <entry>Setting</entry>
                        <entry>Notes</entry>
                      </row>
                    </thead>
                    <tbody>
                      <row>
                        <entry>
                          <varname>hbase.store.stripe.initialStripeCount</varname>
                        </entry>
                        <entry>
                          <para>The number of stripes to create when stripe compaction is enabled.
                            You can use it as follows: </para><itemizedlist>
                            <listitem>
                              <para>For relatively uniform row keys, if you know the approximate
                                target number of stripes from the above, you can avoid some
                                splitting overhead by starting with several stripes (2, 5, 10...).
                                If the early data is not representative of overall row key
                                distribution, this will not be as efficient.</para>
                            </listitem>
                            <listitem>
                              <para>For existing tables with a large amount of data, this setting
                                will effectively pre-split your stripes.</para>
                            </listitem>
                            <listitem>
                              <para>For keys such as hash-prefixed sequential keys, with more than
                                one hash prefix per region, pre-splitting may make sense. </para>
                            </listitem>
                          </itemizedlist>
                        </entry>
                      </row>
                      <row>
                        <entry>
                          <varname>hbase.store.stripe.sizeToSplit</varname>
                        </entry>
                        <entry>The maximum size a stripe grows before splitting. Use this in
                          conjunction with <varname>hbase.store.stripe.splitPartCount</varname> to
                          control the target stripe size (sizeToSplit = splitPartsCount * target
                          stripe size), according to the above sizing considerations. </entry>
                      </row>
                      <row>
                        <entry>
                          <varname>hbase.store.stripe.splitPartCount</varname>
                        </entry>
                        <entry>The number of new stripes to create when splitting a stripe. The
                          default is 2, which is appropriate for most cases. For non-uniform row
                          keys, you can experiment with increasing the number to 3 or 4, to isolate
                          the arriving updates into narrower slice of the region without additional
                          splits being required.</entry>
                      </row>
                    </tbody>
                  </tgroup>
                </table>
              </section>
              <section
                xml:id="ops.stripe.config.memstore">
                <title>MemStore Size Settings</title>
                <para> By default, the flush creates several files from one MemStore, according to
                  existing stripe boundaries and row keys to flush. This approach minimizes write
                  amplification, but can be undesirable if the MemStore is small and there are many
                  stripes, because the files will be too small. </para>
                <para>In this type of situation, you can set
                    <varname>hbase.store.stripe.compaction.flushToL0</varname> to
                    <literal>true</literal>. This will cause a MemStore flush to create a single
                  file instead. When at least
                    <varname>hbase.store.stripe.compaction.minFilesL0</varname> such files (by
                  default, 4) accumulate, they will be compacted into striped files.</para>
              </section>
              <section
                xml:id="ops.stripe.config.compact">
                <title>Normal Compaction Configuration and Stripe Compaction</title>
                <para> All the settings that apply to normal compactions (see <xref
                    linkend="compaction.configuration.parameters" />) apply to stripe compactions.
                  The exceptions are the minimum and maximum number of files, which are set to
                  higher values by default because the files in stripes are smaller. To control
                  these for stripe compactions, use
                    <varname>hbase.store.stripe.compaction.minFiles</varname> and
                    <varname>hbase.store.stripe.compaction.maxFiles</varname>, rather than
                    <varname>hbase.hstore.compaction.min</varname> and
                    <varname>hbase.hstore.compaction.max</varname>. </para>
              </section>
            </section>
          </section>
        </section>  <!--  compaction -->

     </section>  <!--  store -->

    </section>  <!--  regions -->

	<section xml:id="arch.bulk.load"><title>Bulk Loading</title>
      <section xml:id="arch.bulk.load.overview"><title>Overview</title>
      <para>
        HBase includes several methods of loading data into tables.
        The most straightforward method is to either use the <code>TableOutputFormat</code>
        class from a MapReduce job, or use the normal client APIs; however,
        these are not always the most efficient methods.
      </para>
      <para>
        The bulk load feature uses a MapReduce job to output table data in HBase's internal
        data format, and then directly loads the generated StoreFiles into a running
        cluster. Using bulk load will use less CPU and network resources than
        simply using the HBase API.
      </para>
    </section>
    <section xml:id="arch.bulk.load.limitations"><title>Bulk Load Limitations</title>
        <para>As bulk loading bypasses the write path, the WAL doesn’t get written to as part of the process.
            Replication works by reading the WAL files so it won’t see the bulk loaded data – and the same goes for the edits that use Put.setWriteToWAL(true).
            One way to handle that is to ship the raw files or the HFiles to the other cluster and do the other processing there.</para>
    </section>
    <section xml:id="arch.bulk.load.arch"><title>Bulk Load Architecture</title>
      <para>
        The HBase bulk load process consists of two main steps.
      </para>
      <section xml:id="arch.bulk.load.prep"><title>Preparing data via a MapReduce job</title>
        <para>
          The first step of a bulk load is to generate HBase data files (StoreFiles) from
          a MapReduce job using <code>HFileOutputFormat</code>. This output format writes
          out data in HBase's internal storage format so that they can be
          later loaded very efficiently into the cluster.
        </para>
        <para>
          In order to function efficiently, <code>HFileOutputFormat</code> must be
          configured such that each output HFile fits within a single region.
          In order to do this, jobs whose output will be bulk loaded into HBase
          use Hadoop's <code>TotalOrderPartitioner</code> class to partition the map output
          into disjoint ranges of the key space, corresponding to the key
          ranges of the regions in the table.
        </para>
        <para>
          <code>HFileOutputFormat</code> includes a convenience function,
          <code>configureIncrementalLoad()</code>, which automatically sets up
          a <code>TotalOrderPartitioner</code> based on the current region boundaries of a
          table.
        </para>
      </section>
      <section xml:id="arch.bulk.load.complete"><title>Completing the data load</title>
        <para>
          After the data has been prepared using
          <code>HFileOutputFormat</code>, it is loaded into the cluster using
          <code>completebulkload</code>. This command line tool iterates
          through the prepared data files, and for each one determines the
          region the file belongs to. It then contacts the appropriate Region
          Server which adopts the HFile, moving it into its storage directory
          and making the data available to clients.
        </para>
        <para>
          If the region boundaries have changed during the course of bulk load
          preparation, or between the preparation and completion steps, the
          <code>completebulkloads</code> utility will automatically split the
          data files into pieces corresponding to the new boundaries. This
          process is not optimally efficient, so users should take care to
          minimize the delay between preparing a bulk load and importing it
          into the cluster, especially if other clients are simultaneously
          loading data through other means.
        </para>
      </section>
    </section>
    <section xml:id="arch.bulk.load.import"><title>Importing the prepared data using the completebulkload tool</title>
      <para>
        After a data import has been prepared, either by using the
        <code>importtsv</code> tool with the
        "<code>importtsv.bulk.output</code>" option or by some other MapReduce
        job using the <code>HFileOutputFormat</code>, the
        <code>completebulkload</code> tool is used to import the data into the
        running cluster.
      </para>
      <para>
        The <code>completebulkload</code> tool simply takes the output path
        where <code>importtsv</code> or your MapReduce job put its results, and
        the table name to import into. For example:
      </para>
      <screen language="bourne">$ hadoop jar hbase-VERSION.jar completebulkload [-c /path/to/hbase/config/hbase-site.xml] /user/todd/myoutput mytable</screen>
      <para>
        The <code>-c config-file</code> option can be used to specify a file
        containing the appropriate hbase parameters (e.g., hbase-site.xml) if
        not supplied already on the CLASSPATH (In addition, the CLASSPATH must
        contain the directory that has the zookeeper configuration file if
        zookeeper is NOT managed by HBase).
      </para>
      <para>
        Note: If the target table does not already exist in HBase, this
        tool will create the table automatically.</para>
      <para>
        This tool will run quickly, after which point the new data will be visible in
        the cluster.
      </para>
    </section>
    <section xml:id="arch.bulk.load.also"><title>See Also</title>
      <para>For more information about the referenced utilities, see <xref linkend="importtsv"/> and  <xref linkend="completebulkload"/>.
      </para>
      <para>
          See <link xlink:href="http://blog.cloudera.com/blog/2013/09/how-to-use-hbase-bulk-loading-and-why/">How-to: Use HBase Bulk Loading, and Why</link>
          for a recent blog on current state of bulk loading.
      </para>
    </section>
    <section xml:id="arch.bulk.load.adv"><title>Advanced Usage</title>
      <para>
        Although the <code>importtsv</code> tool is useful in many cases, advanced users may
        want to generate data programatically, or import data from other formats. To get
        started doing so, dig into <code>ImportTsv.java</code> and check the JavaDoc for
        HFileOutputFormat.
      </para>
      <para>
        The import step of the bulk load can also be done programatically. See the
        <code>LoadIncrementalHFiles</code> class for more information.
      </para>
    </section>
	</section>  <!--  bulk loading -->

    <section xml:id="arch.hdfs"><title>HDFS</title>
       <para>As HBase runs on HDFS (and each StoreFile is written as a file on HDFS),
        it is important to have an understanding of the HDFS Architecture
         especially in terms of how it stores files, handles failovers, and replicates blocks.
       </para>
       <para>See the Hadoop documentation on <link xlink:href="http://hadoop.apache.org/common/docs/current/hdfs_design.html">HDFS Architecture</link>
       for more information.
       </para>
       <section xml:id="arch.hdfs.nn"><title>NameNode</title>
         <para>The NameNode is responsible for maintaining the filesystem metadata.  See the above HDFS Architecture link
         for more information.
         </para>
       </section>
       <section xml:id="arch.hdfs.dn"><title>DataNode</title>
         <para>The DataNodes are responsible for storing HDFS blocks.  See the above HDFS Architecture link
         for more information.
         </para>
       </section>
    </section>

		<section xml:id="arch.timelineconsistent.reads">
	      <title>Timeline-consistent High Available Reads</title>
			<section xml:id="casestudies.timelineconsistent.intro">
		      <title>Introduction</title>
		      <para> 
			HBase, architecturally, always had the strong consistency guarantee from the start. All reads and writes are routed through a single region server, which guarantees that all writes happen in an order, and all reads are seeing the most recent committed data. 
	          </para><para>
			However, because of this single homing of the reads to a single location, if the server becomes unavailable, the regions of the table that were hosted in the region server become unavailable for some time. There are three phases in the region recovery process - detection, assignment, and recovery. Of these, the detection is usually the longest and is presently in the order of 20-30 seconds depending on the zookeeper session timeout. During this time and before the recovery is complete, the clients will not be able to read the region data.
	          </para><para>
			However, for some use cases, either the data may be read-only, or doing reads againsts some stale data is acceptable. With timeline-consistent high available reads, HBase can be used for these kind of latency-sensitive use cases where the application can expect to have a time bound on the read completion. 
	          </para><para>
			For achieving high availability for reads, HBase provides a feature called “region replication”. In this model, for each region of a table, there will be multiple replicas that are opened in different region servers. By default, the region replication is set to 1, so only a single region replica is deployed and there will not be any changes from the original model. If region replication is set to 2 or more, than the master will assign replicas of the regions of the table. The Load Balancer ensures that the region replicas are not co-hosted in the same region servers and also in the same rack (if possible). 
	          </para><para>
			All of the replicas for a single region will have a unique replica_id, starting from 0. The region replica having replica_id==0 is called the primary region, and the others “secondary regions” or secondaries. Only the primary can accept writes from the client, and the primary will always contain the latest changes. Since all writes still have to go through the primary region, the writes are not highly-available (meaning they might block for some time if the region becomes unavailable). 
	          </para><para>
			The writes are asynchronously sent to the secondary region replicas using an “Async WAL replication” feature. This works similarly to HBase’s multi-datacenter replication, but instead the data from a region is replicated to the secondary regions. Each secondary replica always receives and observes the writes in the same order that the primary region committed them. This ensures that the secondaries won’t diverge from the primary regions data, but since the log replication is asnyc, the data might be stale in secondary regions. In some sense, this design can be thought of as “in-cluster replication”, where instead of replicating to a different datacenter, the data goes to a secondary region to keep secondary region’s in-memory state up to date. The data files are shared between the primary region and the other replicas, so that there is no extra storage overhead. However, the secondary regions will have recent non-flushed data in their memstores, which increases the memory overhead. 
	         </para><para>
	Async WAL replication feature is being implemented in Phase 2 of issue HBASE-10070. Before this, region replicas will only be updated with flushed data files from the primary (see hbase.regionserver.storefile.refresh.period below). It is also possible to use this without setting storefile.refresh.period for read only tables. 
		     </para>
	       </section>
	       <section>
	       <title>Timeline Consistency </title>
	         <para>
			With this feature, HBase introduces a Consistency definition, which can be provided per read operation (get or scan).
	<programlisting language="java">
public enum Consistency {
    STRONG,
    TIMELINE
}
	</programlisting>
			<code>Consistency.STRONG</code> is the default consistency model provided by HBase. In case the table has region replication = 1, or in a table with region replicas but the reads are done with this consistency, the read is always performed by the primary regions, so that there will not be any change from the previous behaviour, and the client always observes the latest data. 
	          </para><para>
			In case a read is performed with <code>Consistency.TIMELINE</code>, then the read RPC will be sent to the primary region server first. After a short interval (<code>hbase.client.primaryCallTimeout.get</code>, 10ms by default), parallel RPC for secondary region replicas will also be sent if the primary does not respond back. After this, the result is returned from whichever RPC is finished first. If the response came back from the primary region replica, we can always know that the data is latest. For this Result.isStale() API has been added to inspect the staleness. If the result is from a secondary region, then Result.isStale() will be set to true. The user can then inspect this field to possibly reason about the data. 
	          </para><para>
			In terms of semantics, TIMELINE consistency as implemented by HBase differs from pure eventual
			consistency in these respects: </para>
			  <itemizedlist>
            <listitem>
              <para> Single homed and ordered updates: Region replication or not, on the write side,
                there is still only 1 defined replica (primary) which can accept writes. This
                replica is responsible for ordering the edits and preventing conflicts. This
                guarantees that two different writes are not committed at the same time by different
                replicas and the data diverges. With this, there is no need to do read-repair or
                last-timestamp-wins kind of conflict resolution. </para>
            </listitem>
            <listitem>
              <para> The secondaries also apply the edits in the order that the primary committed
                them. This way the secondaries will contain a snapshot of the primaries data at any
                point in time. This is similar to RDBMS replications and even HBase’s own
                multi-datacenter replication, however in a single cluster. </para>
            </listitem>
            <listitem>
              <para> On the read side, the client can detect whether the read is coming from
                up-to-date data or is stale data. Also, the client can issue reads with different
                consistency requirements on a per-operation basis to ensure its own semantic
                guarantees. </para>
            </listitem>
            <listitem>
              <para> The client can still observe edits out-of-order, and can go back in time, if it
                observes reads from one secondary replica first, then another secondary replica.
                There is no stickiness to region replicas or a transaction-id based guarantee. If
                required, this can be implemented later though. </para>
            </listitem>
          </itemizedlist>

        <figure>
          <title>HFile Version 1</title>
          <mediaobject>
            <imageobject>
              <imagedata
                align="center"
                valign="middle"
                fileref="timeline_consistency.png" />
            </imageobject>
            <textobject>
              <phrase>HFile Version 1</phrase>
            </textobject>
          </mediaobject>
        </figure>
		<para>
			To better understand the TIMELINE semantics, lets look at the above diagram. Lets say that there are two clients, and the first one writes x=1 at first, then x=2 and x=3 later. As above, all writes are handled by the primary region replica. The writes are saved in the write ahead log (WAL), and replicated to the other replicas asynchronously. In the above diagram, notice that replica_id=1 received 2 updates, and it’s data shows that x=2, while the replica_id=2 only received a single update, and its data shows that x=1. 
		</para><para>
			If client1 reads with STRONG consistency, it will only talk with the replica_id=0, and thus is guaranteed to observe the latest value of x=3. In case of a client issuing TIMELINE consistency reads, the RPC will go to all replicas (after primary timeout) and the result from the first response will be returned back. Thus the client can see either 1, 2 or 3 as the value of x. Let’s say that the primary region has failed and log replication cannot continue for some time. If the client does multiple reads with TIMELINE consistency, she can observe x=2 first, then x=1, and so on. 

		</para>
	</section>
	<section>
		<title>Tradeoffs</title>
        <para> Having secondary regions hosted for read availability comes with some tradeoffs which
          should be carefully evaluated per use case. Following are advantages and
          disadvantages.</para>
        <itemizedlist>
          <title>Advantages</title>
          <listitem>
            <para>High availability for read-only tables.</para>
          </listitem>
          <listitem>
            <para>High availability for stale reads</para>
          </listitem>
          <listitem>
            <para>Ability to do very low latency reads with very high percentile (99.9%+) latencies
              for stale reads</para>
          </listitem>
        </itemizedlist>

        <itemizedlist>
          <title>Disadvantages</title>
          <listitem>
            <para>Double / Triple memstore usage (depending on region replication count) for tables
              with region replication &gt; 1</para>
          </listitem>
          <listitem>
            <para>Increased block cache usage</para>
          </listitem>
          <listitem>
            <para>Extra network traffic for log replication </para>
          </listitem>
          <listitem>
            <para>Extra backup RPCs for replicas</para>
          </listitem>
        </itemizedlist>
        <para>To serve the region data from multiple replicas, HBase opens the regions in secondary
          mode in the region servers. The regions opened in secondary mode will share the same data
          files with the primary region replica, however each secondary region replica will have its
          own memstore to keep the unflushed data (only primary region can do flushes). Also to
          serve reads from secondary regions, the blocks of data files may be also cached in the
          block caches for the secondary regions. </para>
		</section>
		<section>
			<title>Configuration properties</title>
			<para>
	To use highly available reads, you should set the following properties in hbase-site.xml file. There is no specific configuration to enable or disable region replicas. Instead you can change the number of region replicas per table to increase or decrease at the table creation or with alter table. 
		</para>
		<section>
			<title>Server side properties</title>
			<programlisting language="xml"><![CDATA[
<property>
    <name>hbase.regionserver.storefile.refresh.period</name>
    <value>0</value>
    <description>
      The period (in milliseconds) for refreshing the store files for the secondary regions. 0 means this feature is disabled. Secondary regions sees new files (from flushes and compactions) from primary once the secondary region refreshes the list of files in the region. But too frequent refreshes might cause extra Namenode pressure. If the files cannot be refreshed for longer than HFile TTL (hbase.master.hfilecleaner.ttl) the requests are rejected. Configuring HFile TTL to a larger value is also recommended with this setting.
    </description>
</property>
]]></programlisting>

          <para> One thing to keep in mind also is that, region replica placement policy is only
            enforced by the <code>StochasticLoadBalancer</code> which is the default balancer. If
            you are using a custom load balancer property in hbase-site.xml
              (<code>hbase.master.loadbalancer.class</code>) replicas of regions might end up being
            hosted in the same server.</para>
			</section>
			<section>
				<title>Client side properties</title>
          <para> Ensure to set the following for all clients (and servers) that will use region
            replicas. </para>			
			  <programlisting language="xml"><![CDATA[
<property>
    <name>hbase.ipc.client.allowsInterrupt</name>
    <value>true</value>
    <description>
      Whether to enable interruption of RPC threads at the client side. This is required for region replicas with fallback RPC’s to secondary regions.
    </description>
</property>
<property>
    <name>hbase.client.primaryCallTimeout.get</name>
    <value>10000</value>
    <description>
      The timeout (in microseconds), before secondary fallback RPC’s are submitted for get requests with Consistency.TIMELINE to the secondary replicas of the regions. Defaults to 10ms. Setting this lower will increase the number of RPC’s, but will lower the p99 latencies. 
    </description>
</property>
<property>
    <name>hbase.client.primaryCallTimeout.multiget</name>
    <value>10000</value>
    <description>
      The timeout (in microseconds), before secondary fallback RPC’s are submitted for multi-get requests (HTable.get(List<Get>)) with Consistency.TIMELINE to the secondary replicas of the regions. Defaults to 10ms. Setting this lower will increase the number of RPC’s, but will lower the p99 latencies. 
    </description>
</property>
<property>
    <name>hbase.client.replicaCallTimeout.scan</name>
    <value>1000000</value>
    <description>
      The timeout (in microseconds), before secondary fallback RPC’s are submitted for scan requests with Consistency.TIMELINE to the secondary replicas of the regions. Defaults to 1 sec. Setting this lower will increase the number of RPC’s, but will lower the p99 latencies. 
    </description>
</property>
]]></programlisting>

	</section>
	</section>
	<section>
		<title>Creating a table with region replication</title>
		<para>
		Region replication is a per-table property. All tables have REGION_REPLICATION = 1 by default, which means that there is only one replica per region. You can set and change the number of replicas per region of a table by supplying the REGION_REPLICATION property in the table descriptor. 
	    </para>
	<section><title>Shell</title>
	<programlisting><![CDATA[
create 't1', 'f1', {REGION_REPLICATION => 2}

describe 't1'
for i in 1..100
put 't1', "r#{i}", 'f1:c1', i
end
flush 't1'
]]></programlisting>

	</section>
	<section><title>Java</title>
	<programlisting language="java"><![CDATA[
HTableDescriptor htd = new HTableDesctiptor(TableName.valueOf(“test_table”)); 
htd.setRegionReplication(2);
...
admin.createTable(htd); 
]]></programlisting>

          <para>You can also use <code>setRegionReplication()</code> and alter table to increase, decrease the
            region replication for a table.</para> 
	</section>
	</section>
	<section>
		<title>Region splits and merges</title>
        <para>Region splits and merges are not compatible with regions with replicas yet. So you
          have to pre-split the table, and disable the region splits. Also you should not execute
          region merges on tables with region replicas. To disable region splits you can use
          DisabledRegionSplitPolicy as the split policy.</para>
	</section>
	<section>
		<title>User Interface</title>
        <para> In the masters user interface, the region replicas of a table are also shown together
          with the primary regions. You can notice that the replicas of a region will share the same
          start and end keys and the same region name prefix. The only difference would be the
          appended replica_id (which is encoded as hex), and the region encoded name will be
          different. You can also see the replica ids shown explicitly in the UI. </para>	
	</section>
			<section>
				<title>API and Usage</title>
				<section>
					<title>Shell</title>
          <para> You can do reads in shell using a the Consistency.TIMELINE semantics as follows
          </para>	
				  <programlisting><![CDATA[
hbase(main):001:0> get 't1','r6', {CONSISTENCY => "TIMELINE"}
]]></programlisting>
          <para> You can simulate a region server pausing or becoming unavailable and do a read from
            the secondary replica: </para>	
				  <programlisting language="bourne"><![CDATA[
$ kill -STOP <pid or primary region server>

hbase(main):001:0> get 't1','r6', {CONSISTENCY => "TIMELINE"}
]]></programlisting>
          <para> Using scans is also similar </para>	
				  <programlisting><![CDATA[
hbase> scan 't1', {CONSISTENCY => 'TIMELINE'}
]]></programlisting>
		</section>
		<section>
			<title>Java</title>
          <para>You can set set the consistency for Gets and Scans and do requests as
            follows.</para> 
	<programlisting language="java"><![CDATA[
Get get = new Get(row);
get.setConsistency(Consistency.TIMELINE);
...
Result result = table.get(get); 
]]></programlisting>
          <para>You can also pass multiple gets: </para>
	<programlisting language="java"><![CDATA[
Get get1 = new Get(row);
get1.setConsistency(Consistency.TIMELINE);
...
ArrayList<Get> gets = new ArrayList<Get>();
gets.add(get1);
...
Result[] results = table.get(gets); 
]]></programlisting>
          <para>And Scans: </para>
	<programlisting language="java"><![CDATA[
Scan scan = new Scan();
scan.setConsistency(Consistency.TIMELINE);
...
ResultScanner scanner = table.getScanner(scan);
]]></programlisting>
          <para>You can inspect whether the results are coming from primary region or not by calling
            the Result.isStale() method: </para>

	<programlisting language="java"><![CDATA[
Result result = table.get(get); 
if (result.isStale()) {
  ...
}
]]></programlisting>
		</section>
	</section>

	<section>
		<title>Resources</title>
        <orderedlist>
          <listitem>
            <para>More information about the design and implementation can be found at the jira
              issue: <link
                xlink:href="https://issues.apache.org/jira/browse/HBASE-10070">HBASE-10070</link></para>
          </listitem>

          <listitem>
            <para>HBaseCon 2014 <link
                xlink:href="http://hbasecon.com/sessions/#session15">talk</link> also contains some
              details and <link
                xlink:href="http://www.slideshare.net/enissoz/hbase-high-availability-for-reads-with-time">slides</link>.</para>
          </listitem>
        </orderedlist>
	    </section>
	</section>

  </chapter>   <!--  architecture -->
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="hbase_apis.xml"/>
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="external_apis.xml"/>
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="thrift_filter_language.xml"/>
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="cp.xml" />
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="performance.xml"/>
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="troubleshooting.xml"/>
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="case_studies.xml" />
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="ops_mgt.xml"/>
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="developer.xml"/>
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="zookeeper.xml" />
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="community.xml" />
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="appendix_contributing_to_documentation.xml" />
  
<appendix xml:id="faq">
    <title >FAQ</title>
    <qandaset defaultlabel='qanda'>
        <qandadiv><title>General</title>
        <qandaentry>
                <question><para>When should I use HBase?</para></question>
            <answer>
                <para>See the <xref linkend="arch.overview" /> in the Architecture chapter.
                </para>
            </answer>
        </qandaentry>
        <qandaentry>
                <question><para>Are there other HBase FAQs?</para></question>
            <answer>
                <para>
              See the FAQ that is up on the wiki, <link xlink:href="http://wiki.apache.org/hadoop/Hbase/FAQ">HBase Wiki FAQ</link>.
                </para>
            </answer>
        </qandaentry>
        <qandaentry xml:id="faq.sql">
            <question><para>Does HBase support SQL?</para></question>
            <answer>
                <para>
                    Not really.  SQL-ish support for HBase via <link xlink:href="http://hive.apache.org/">Hive</link> is in development, however Hive is based on MapReduce which is not generally suitable for low-latency requests.
                    See the <xref linkend="datamodel" /> section for examples on the HBase client.
                </para>
            </answer>
        </qandaentry>
        <qandaentry>
            <question><para>How can I find examples of NoSQL/HBase?</para></question>
            <answer>
                <para>See the link to the BigTable paper in <xref linkend="other.info" /> in the appendix, as
                well as the other papers.
                </para>
            </answer>
        </qandaentry>
        <qandaentry>
            <question><para>What is the history of HBase?</para></question>
            <answer>
                <para>See <xref linkend="hbase.history"/>.
                </para>
            </answer>
        </qandaentry>
    </qandadiv>
    <qandadiv xml:id="faq.arch"><title>Architecture</title>
        <qandaentry xml:id="faq.arch.regions">
            <question><para>How does HBase handle Region-RegionServer assignment and locality?</para></question>
            <answer>
                <para>
                    See <xref linkend="regions.arch" />.
                </para>
            </answer>
            </qandaentry>
    </qandadiv>
    <qandadiv xml:id="faq.config"><title>Configuration</title>
        <qandaentry xml:id="faq.config.started">
            <question><para>How can I get started with my first cluster?</para></question>
            <answer>
                <para>
                    See <xref linkend="quickstart" />.
                </para>
            </answer>
            </qandaentry>
        <qandaentry xml:id="faq.config.options">
            <question><para>Where can I learn about the rest of the configuration options?</para></question>
            <answer>
                <para>
                    See <xref linkend="configuration" />.
                </para>
            </answer>
            </qandaentry>
    </qandadiv>
    <qandadiv xml:id="faq.design"><title>Schema Design / Data Access</title>
        <qandaentry xml:id="faq.design.schema">
            <question><para>How should I design my schema in HBase?</para></question>
            <answer>
                <para>
                    See <xref linkend="datamodel" /> and <xref linkend="schema" />
                </para>
            </answer>
        </qandaentry>
        <qandaentry>
            <question><para>
                    How can I store (fill in the blank) in HBase?
            </para></question>
            <answer>
                <para>
                See <xref linkend="supported.datatypes" />.
                </para>
            </answer>
        </qandaentry>
        <qandaentry xml:id="secondary.indices">
            <question><para>
                    How can I handle secondary indexes in HBase?
            </para></question>
            <answer>
                <para>
                See <xref linkend="secondary.indexes" />
                </para>
            </answer>
        </qandaentry>
        <qandaentry xml:id="faq.changing.rowkeys">
            <question><para>Can I change a table's rowkeys?</para></question>
            <answer>
                <para> This is a very common question. You can't. See <xref
                linkend="changing.rowkeys"/>. </para>
            </answer>
        </qandaentry>
        <qandaentry xml:id="faq.apis">
            <question><para>What APIs does HBase support?</para></question>
            <answer>
                <para>
                    See <xref linkend="datamodel" />, <xref linkend="client" /> and <xref linkend="nonjava.jvm"/>.
                </para>
            </answer>
        </qandaentry>
    </qandadiv>
    <qandadiv xml:id="faq.mapreduce"><title>MapReduce</title>
        <qandaentry xml:id="faq.mapreduce.use">
            <question><para>How can I use MapReduce with HBase?</para></question>
            <answer>
                <para>
                    See <xref linkend="mapreduce" />
                </para>
            </answer>
        </qandaentry>
    </qandadiv>
    <qandadiv><title>Performance and Troubleshooting</title>
        <qandaentry>
            <question><para>
                   How can I improve HBase cluster performance?
            </para></question>
            <answer>
                <para>
                See <xref linkend="performance" />.
                </para>
            </answer>
        </qandaentry>
        <qandaentry>
            <question><para>
                    How can I troubleshoot my HBase cluster?
            </para></question>
            <answer>
                <para>
                See <xref linkend="trouble" />.
                </para>
            </answer>
        </qandaentry>
    </qandadiv>
    <qandadiv xml:id="ec2"><title>Amazon EC2</title>
        <qandaentry>
            <question><para>
            I am running HBase on Amazon EC2 and...
            </para></question>
            <answer>
                <para>
 	            EC2 issues are a special case.  See Troubleshooting <xref linkend="trouble.ec2" /> and Performance <xref linkend="perf.ec2" /> sections.
               </para>
            </answer>
        </qandaentry>
    </qandadiv>
    <qandadiv><title xml:id="faq.operations">Operations</title>
        <qandaentry>
            <question><para>
                    How do I manage my HBase cluster?
            </para></question>
            <answer>
                <para>
                    See <xref linkend="ops_mgt" />
                </para>
            </answer>
        </qandaentry>
        <qandaentry>
            <question><para>
                    How do I back up my HBase cluster?
            </para></question>
            <answer>
                <para>
                    See <xref linkend="ops.backup" />
                </para>
            </answer>
        </qandaentry>
    </qandadiv>
        <qandadiv><title>HBase in Action</title>
        <qandaentry>
            <question><para>Where can I find interesting videos and presentations on HBase?</para></question>
            <answer>
                <para>
                    See <xref linkend="other.info" />
                </para>
            </answer>
        </qandaentry>
        </qandadiv>
    </qandaset>
  </appendix>

  <appendix xml:id="hbck.in.depth">
    <title>hbck In Depth</title>
	<para>HBaseFsck (hbck) is a tool for checking for region consistency and table integrity problems
and repairing a corrupted HBase. It works in two basic modes -- a read-only inconsistency
identifying mode and a multi-phase read-write repair mode.
	</para>
	<section>
	  <title>Running hbck to identify inconsistencies</title>
<para>To check to see if your HBase cluster has corruptions, run hbck against your HBase cluster:</para>
<programlisting language="bourne">
$ ./bin/hbase hbck
</programlisting>
	<para>
At the end of the commands output it prints OK or tells you the number of INCONSISTENCIES
present. You may also want to run run hbck a few times because some inconsistencies can be
transient (e.g. cluster is starting up or a region is splitting). Operationally you may want to run
hbck regularly and setup alert (e.g. via nagios) if it repeatedly reports inconsistencies .
A run of hbck will report a list of inconsistencies along with a brief description of the regions and
tables affected. The using the <code>-details</code> option will report more details including a representative
listing of all the splits present in all the tables.
	</para>
<programlisting language="bourne">
$ ./bin/hbase hbck -details
</programlisting>
<para>If you just want to know if some tables are corrupted, you can limit hbck to identify inconsistencies
in only specific tables. For example the following command would only attempt to check table
TableFoo and TableBar. The benefit is that hbck will run in less time.</para>
<programlisting language="bourne">
$ ./bin/hbase hbck TableFoo TableBar
</programlisting>
	</section>
	<section><title>Inconsistencies</title>
	<para>
	If after several runs, inconsistencies continue to be reported, you may have encountered a
corruption. These should be rare, but in the event they occur newer versions of HBase include
the hbck tool enabled with automatic repair options.
	</para>
	<para>
	There are two invariants that when violated create inconsistencies in HBase:
	</para>
	<itemizedlist>
	  <listitem><para>HBase’s region consistency invariant is satisfied if every region is assigned and
deployed on exactly one region server, and all places where this state kept is in
accordance.</para>
	</listitem>
	<listitem><para>HBase’s table integrity invariant is satisfied if for each table, every possible row key
resolves to exactly one region.</para>
	</listitem>
	</itemizedlist>
	<para>
Repairs generally work in three phases -- a read-only information gathering phase that identifies
inconsistencies, a table integrity repair phase that restores the table integrity invariant, and then
finally a region consistency repair phase that restores the region consistency invariant.
Starting from version 0.90.0, hbck could detect region consistency problems report on a subset
of possible table integrity problems. It also included the ability to automatically fix the most
common inconsistency, region assignment and deployment consistency problems. This repair
could be done by using the <code>-fix</code> command line option. These problems close regions if they are
open on the wrong server or on multiple region servers and also assigns regions to region
servers if they are not open.
</para>
<para>
Starting from HBase versions 0.90.7, 0.92.2 and 0.94.0, several new command line options are
introduced to aid repairing a corrupted HBase. This hbck sometimes goes by the nickname
“uberhbck”. Each particular version of uber hbck is compatible with the HBase’s of the same
major version (0.90.7 uberhbck can repair a 0.90.4). However, versions &lt;=0.90.6 and versions
&lt;=0.92.1 may require restarting the master or failing over to a backup master.
</para>
	</section>
	<section><title>Localized repairs</title>
	<para>
	When repairing a corrupted HBase, it is best to repair the lowest risk inconsistencies first.
These are generally region consistency repairs -- localized single region repairs, that only modify
in-memory data, ephemeral zookeeper data, or patch holes in the META table.
Region consistency requires that the HBase instance has the state of the region’s data in HDFS
(.regioninfo files), the region’s row in the hbase:meta table., and region’s deployment/assignments on
region servers and the master in accordance. Options for repairing region consistency include:
	<itemizedlist>
		<listitem><para><code>-fixAssignments</code> (equivalent to the 0.90 <code>-fix</code> option) repairs unassigned, incorrectly
assigned or multiply assigned regions.</para>
		</listitem>
		<listitem><para><code>-fixMeta</code> which removes meta rows when corresponding regions are not present in
		  HDFS and adds new meta rows if they regions are present in HDFS while not in META.</para>
		</listitem>
	</itemizedlist>
	To fix deployment and assignment problems you can run this command:
</para>
<programlisting language="bourne">
$ ./bin/hbase hbck -fixAssignments
</programlisting>
<para>To fix deployment and assignment problems as well as repairing incorrect meta rows you can
run this command:</para>
<programlisting language="bourne">
$ ./bin/hbase hbck -fixAssignments -fixMeta
</programlisting>
<para>There are a few classes of table integrity problems that are low risk repairs. The first two are
degenerate (startkey == endkey) regions and backwards regions (startkey > endkey). These are
automatically handled by sidelining the data to a temporary directory (/hbck/xxxx).
The third low-risk class is hdfs region holes. This can be repaired by using the:</para>
	<itemizedlist>
		<listitem><para><code>-fixHdfsHoles</code> option for fabricating new empty regions on the file system.
If holes are detected you can use -fixHdfsHoles and should include -fixMeta and -fixAssignments to make the new region consistent.</para>
		</listitem>
	</itemizedlist>
<programlisting language="bourne">
$ ./bin/hbase hbck -fixAssignments -fixMeta -fixHdfsHoles
</programlisting>
<para>Since this is a common operation, we’ve added a the <code>-repairHoles</code> flag that is equivalent to the
previous command:</para>
<programlisting language="bourne">
$ ./bin/hbase hbck -repairHoles
</programlisting>
<para>If inconsistencies still remain after these steps, you most likely have table integrity problems
related to orphaned or overlapping regions.</para>
	</section>
	<section><title>Region Overlap Repairs</title>
<para>Table integrity problems can require repairs that deal with overlaps. This is a riskier operation
because it requires modifications to the file system, requires some decision making, and may
require some manual steps. For these repairs it is best to analyze the output of a <code>hbck -details</code>
run so that you isolate repairs attempts only upon problems the checks identify. Because this is
riskier, there are safeguard that should be used to limit the scope of the repairs.
WARNING: This is a relatively new and have only been tested on online but idle HBase instances
(no reads/writes). Use at your own risk in an active production environment!
The options for repairing table integrity violations include:</para>
	<itemizedlist>
		<listitem><para><code>-fixHdfsOrphans</code> option for “adopting” a region directory that is missing a region
metadata file (the .regioninfo file).</para>
		</listitem>
		<listitem><para><code>-fixHdfsOverlaps</code> ability for fixing overlapping regions</para>
		</listitem>
	</itemizedlist>
<para>When repairing overlapping regions, a region’s data can be modified on the file system in two
ways: 1) by merging regions into a larger region or 2) by sidelining regions by moving data to
“sideline” directory where data could be restored later. Merging a large number of regions is
technically correct but could result in an extremely large region that requires series of costly
compactions and splitting operations. In these cases, it is probably better to sideline the regions
that overlap with the most other regions (likely the largest ranges) so that merges can happen on
a more reasonable scale. Since these sidelined regions are already laid out in HBase’s native
directory and HFile format, they can be restored by using HBase’s bulk load mechanism.
The default safeguard thresholds are conservative. These options let you override the default
thresholds and to enable the large region sidelining feature.</para>
	<itemizedlist>
		<listitem><para><code>-maxMerge &lt;n&gt;</code> maximum number of overlapping regions to merge</para>
		</listitem>
		<listitem><para><code>-sidelineBigOverlaps</code> if more than maxMerge regions are overlapping, sideline attempt
to sideline the regions overlapping with the most other regions.</para>
		</listitem>
		<listitem><para><code>-maxOverlapsToSideline &lt;n&gt;</code> if sidelining large overlapping regions, sideline at most n
regions.</para>
		</listitem>
	</itemizedlist>

<para>Since often times you would just want to get the tables repaired, you can use this option to turn
on all repair options:</para>
	<itemizedlist>
		<listitem><para><code>-repair</code> includes all the region consistency options and only the hole repairing table
integrity options.</para>
		</listitem>
	</itemizedlist>
<para>Finally, there are safeguards to limit repairs to only specific tables. For example the following
command would only attempt to check and repair table TableFoo and TableBar.</para>
<screen language="bourne">
$ ./bin/hbase hbck -repair TableFoo TableBar
</screen>
	<section><title>Special cases: Meta is not properly assigned</title>
<para>There are a few special cases that hbck can handle as well.
Sometimes the meta table’s only region is inconsistently assigned or deployed. In this case
there is a special <code>-fixMetaOnly</code> option that can try to fix meta assignments.</para>
<screen language="bourne">
$ ./bin/hbase hbck -fixMetaOnly -fixAssignments
</screen>
	</section>
	<section><title>Special cases: HBase version file is missing</title>
<para>HBase’s data on the file system requires a version file in order to start. If this flie is missing, you
can use the <code>-fixVersionFile</code> option to fabricating a new HBase version file. This assumes that
the version of hbck you are running is the appropriate version for the HBase cluster.</para>
	</section>
	<section><title>Special case: Root and META are corrupt.</title>
<para>The most drastic corruption scenario is the case where the ROOT or META is corrupted and
HBase will not start. In this case you can use the OfflineMetaRepair tool create new ROOT
and META regions and tables.
This tool assumes that HBase is offline. It then marches through the existing HBase home
directory, loads as much information from region metadata files (.regioninfo files) as possible
from the file system. If the region metadata has proper table integrity, it sidelines the original root
and meta table directories, and builds new ones with pointers to the region directories and their
data.</para>
<screen language="bourne">
$ ./bin/hbase org.apache.hadoop.hbase.util.hbck.OfflineMetaRepair
</screen>
<para>NOTE: This tool is not as clever as uberhbck but can be used to bootstrap repairs that uberhbck
can complete.
If the tool succeeds you should be able to start hbase and run online repairs if necessary.</para>
	</section>
	<section><title>Special cases: Offline split parent</title>
    <para>
Once a region is split, the offline parent will be cleaned up automatically. Sometimes, daughter regions
are split again before their parents are cleaned up. HBase can clean up parents in the right order. However,
there could be some lingering offline split parents sometimes. They are in META, in HDFS, and not deployed.
But HBase can't clean them up. In this case, you can use the <code>-fixSplitParents</code> option to reset
them in META to be online and not split. Therefore, hbck can merge them with other regions if fixing
overlapping regions option is used.
    </para>
    <para>
This option should not normally be used, and it is not in <code>-fixAll</code>.
    </para>
	</section>
	</section>
  </appendix>

  <appendix
    xml:id="compression">

    <title>Compression and Data Block Encoding In
          HBase<indexterm><primary>Compression</primary><secondary>Data Block
          Encoding</secondary><seealso>codecs</seealso></indexterm></title>
    <note>
      <para>Codecs mentioned in this section are for encoding and decoding data blocks or row keys.
       For information about replication codecs, see <xref
          linkend="cluster.replication.preserving.tags" />.</para>
    </note>
    <para>Some of the information in this section is pulled from a <link
        xlink:href="http://search-hadoop.com/m/lL12B1PFVhp1/v=threaded">discussion</link> on the
      HBase Development mailing list.</para>
    <para>HBase supports several different compression algorithms which can be enabled on a
      ColumnFamily. Data block encoding attempts to limit duplication of information in keys, taking
      advantage of some of the fundamental designs and patterns of HBase, such as sorted row keys
      and the schema of a given table. Compressors reduce the size of large, opaque byte arrays in
      cells, and can significantly reduce the storage space needed to store uncompressed
      data.</para>
    <para>Compressors and data block encoding can be used together on the same ColumnFamily.</para>
    
    <formalpara>
      <title>Changes Take Effect Upon Compaction</title>
      <para>If you change compression or encoding for a ColumnFamily, the changes take effect during
       compaction.</para>
    </formalpara>

    <para>Some codecs take advantage of capabilities built into Java, such as GZip compression.
      Others rely on native libraries. Native libraries may be available as part of Hadoop, such as
      LZ4. In this case, HBase only needs access to the appropriate shared library. Other codecs,
      such as Google Snappy, need to be installed first. Some codecs are licensed in ways that
      conflict with HBase's license and cannot be shipped as part of HBase.</para>

    <para>This section discusses common codecs that are used and tested with HBase. No matter what
      codec you use, be sure to test that it is installed correctly and is available on all nodes in
      your cluster. Extra operational steps may be necessary to be sure that codecs are available on
      newly-deployed nodes. You can use the <xref
        linkend="compression.test" /> utility to check that a given codec is correctly
      installed.</para>

    <para>To configure HBase to use a compressor, see <xref
        linkend="compressor.install" />. To enable a compressor for a ColumnFamily, see <xref
        linkend="changing.compression" />. To enable data block encoding for a ColumnFamily, see
      <xref linkend="data.block.encoding.enable" />.</para>
    <itemizedlist>
      <title>Block Compressors</title>
      <listitem>
        <para>none</para>
      </listitem>
      <listitem>
        <para>Snappy</para>
      </listitem>
      <listitem>
        <para>LZO</para>
      </listitem>
      <listitem>
        <para>LZ4</para>
      </listitem>
      <listitem>
        <para>GZ</para>
      </listitem>
    </itemizedlist>


    <itemizedlist>
      <title>Data Block Encoding Types</title>
      <listitem>
        <para>Prefix - Often, keys are very similar. Specifically, keys often share a common prefix
          and only differ near the end. For instance, one key might be
            <literal>RowKey:Family:Qualifier0</literal> and the next key might be
            <literal>RowKey:Family:Qualifier1</literal>. In Prefix encoding, an extra column is
          added which holds the length of the prefix shared between the current key and the previous
          key. Assuming the first key here is totally different from the key before, its prefix
          length is 0. The second key's prefix length is <literal>23</literal>, since they have the
          first 23 characters in common.</para>
        <para>Obviously if the keys tend to have nothing in common, Prefix will not provide much
          benefit.</para>
        <para>The following image shows a hypothetical ColumnFamily with no data block encoding.</para>
        <figure>
          <title>ColumnFamily with No Encoding</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="data_block_no_encoding.png" width="800"/>
            </imageobject>
            <textobject><para></para>
            </textobject>
          </mediaobject>
        </figure>
        <para>Here is the same data with prefix data encoding.</para>
        <figure>
          <title>ColumnFamily with Prefix Encoding</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="data_block_prefix_encoding.png" width="800"/>
            </imageobject>
            <textobject><para></para>
            </textobject>
          </mediaobject>
        </figure>
      </listitem>
      <listitem>
        <para>Diff - Diff encoding expands upon Prefix encoding. Instead of considering the key
          sequentially as a monolithic series of bytes, each key field is split so that each part of
          the key can be compressed more efficiently. Two new fields are added: timestamp and type.
          If the ColumnFamily is the same as the previous row, it is omitted from the current row.
          If the key length, value length or type are the same as the previous row, the field is
          omitted. In addition, for increased compression, the timestamp is stored as a Diff from
          the previous row's timestamp, rather than being stored in full. Given the two row keys in
          the Prefix example, and given an exact match on timestamp and the same type, neither the
          value length, or type needs to be stored for the second row, and the timestamp value for
          the second row is just 0, rather than a full timestamp.</para>
        <para>Diff encoding is disabled by default because writing and scanning are slower but more
          data is cached.</para>
        <para>This image shows the same ColumnFamily from the previous images, with Diff encoding.</para>
        <figure>
          <title>ColumnFamily with Diff Encoding</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="data_block_diff_encoding.png" width="800"/>
            </imageobject>
            <textobject><para></para>
            </textobject>
          </mediaobject>
        </figure>
      </listitem>
      <listitem>
        <para>Fast Diff - Fast Diff works similar to Diff, but uses a faster implementation. It also
          adds another field which stores a single bit to track whether the data itself is the same
          as the previous row. If it is, the data is not stored again. Fast Diff is the recommended
          codec to use if you have long keys or many columns. The data format is nearly identical to
        Diff encoding, so there is not an image to illustrate it.</para>
      </listitem>
      <listitem>
        <para>Prefix Tree encoding was introduced as an experimental feature in HBase 0.96. It
          provides similar memory savings to the Prefix, Diff, and Fast Diff encoder, but provides
          faster random access at a cost of slower encoding speed. Prefix Tree may be appropriate
          for applications that have high block cache hit ratios. It introduces new 'tree' fields
          for the row and column. The row tree field contains a list of offsets/references
          corresponding to the cells in that row. This allows for a good deal of compression. For
          more details about Prefix Tree encoding, see <link
            xlink:href="https://issues.apache.org/jira/browse/HBASE-4676">HBASE-4676</link>. It is
          difficult to graphically illustrate a prefix tree, so no image is included. See the
          Wikipedia article for <link
            xlink:href="http://en.wikipedia.org/wiki/Trie">Trie</link> for more general information
          about this data structure.</para>
      </listitem>
    </itemizedlist>

    <section>
      <title>Which Compressor or Data Block Encoder To Use</title>
      <para>The compression or codec type to use depends on the characteristics of your data.
        Choosing the wrong type could cause your data to take more space rather than less, and can
        have performance implications. In general, you need to weigh your options between smaller
        size and faster compression/decompression. Following are some general guidelines, expanded from a discussion at <link xlink:href="http://search-hadoop.com/m/lL12B1PFVhp1">Documenting Guidance on compression and codecs</link>. </para>
      <itemizedlist>
        <listitem>
          <para>If you have long keys (compared to the values) or many columns, use a prefix
            encoder. FAST_DIFF is recommended, as more testing is needed for Prefix Tree
            encoding.</para>
        </listitem>
        <listitem>
          <para>If the values are large (and not precompressed, such as images), use a data block
            compressor.</para>
        </listitem>
        <listitem>
          <para>Use GZIP for <firstterm>cold data</firstterm>, which is accessed infrequently. GZIP
            compression uses more CPU resources than Snappy or LZO, but provides a higher
            compression ratio.</para>
        </listitem>
        <listitem>
          <para>Use Snappy or LZO for <firstterm>hot data</firstterm>, which is accessed
            frequently. Snappy and LZO use fewer CPU resources than GZIP, but do not provide as high
          of a compression ratio.</para>
        </listitem>
        <listitem>
          <para>In most cases, enabling Snappy or LZO by default is a good choice, because they have
            a low performance overhead and provide space savings.</para>
        </listitem>
        <listitem>
          <para>Before Snappy became available by Google in 2011, LZO was the default. Snappy has
            similar qualities as LZO but has been shown to perform better.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Compressor Configuration, Installation, and Use</title>
      <section
        xml:id="compressor.install">
        <title>Configure HBase For Compressors</title>
        <para>Before HBase can use a given compressor, its libraries need to be available. Due to
          licensing issues, only GZ compression is available to HBase (via native Java libraries) in
          a default installation.</para>
        <section>
          <title>Compressor Support On the Master</title>
          <para>A new configuration setting was introduced in HBase 0.95, to check the Master to
            determine which data block encoders are installed and configured on it, and assume that
            the entire cluster is configured the same. This option,
              <code>hbase.master.check.compression</code>, defaults to <literal>true</literal>. This
            prevents the situation described in <link
              xlink:href="https://issues.apache.org/jira/browse/HBASE-6370">HBASE-6370</link>, where
            a table is created or modified to support a codec that a region server does not support,
            leading to failures that take a long time to occur and are difficult to debug. </para>
          <para>If <code>hbase.master.check.compression</code> is enabled, libraries for all desired
            compressors need to be installed and configured on the Master, even if the Master does
            not run a region server.</para>
        </section>
        <section>
          <title>Install GZ Support Via Native Libraries</title>
          <para>HBase uses Java's built-in GZip support unless the native Hadoop libraries are
            available on the CLASSPATH. The recommended way to add libraries to the CLASSPATH is to
            set the environment variable <envar>HBASE_LIBRARY_PATH</envar> for the user running
            HBase. If native libraries are not available and Java's GZIP is used, <literal>Got
              brand-new compressor</literal> reports will be present in the logs. See <xref
              linkend="brand.new.compressor" />).</para>
        </section>
        <section
          xml:id="lzo.compression">
          <title>Install LZO Support</title>
          <para>HBase cannot ship with LZO because of incompatibility between HBase, which uses an
            Apache Software License (ASL) and LZO, which uses a GPL license. See the <link
              xlink:href="http://wiki.apache.org/hadoop/UsingLzoCompression">Using LZO
              Compression</link> wiki page for information on configuring LZO support for HBase. </para>
          <para>If you depend upon LZO compression, consider configuring your RegionServers to fail
            to start if LZO is not available. See <xref
              linkend="hbase.regionserver.codecs" />.</para>
        </section>
        <section
          xml:id="lz4.compression">
          <title>Configure LZ4 Support</title>
          <para>LZ4 support is bundled with Hadoop. Make sure the hadoop shared library
            (libhadoop.so) is accessible when you start
            HBase. After configuring your platform (see <xref
              linkend="hbase.native.platform" />), you can make a symbolic link from HBase to the native Hadoop
            libraries. This assumes the two software installs are colocated. For example, if my
            'platform' is Linux-amd64-64:
            <programlisting language="bourne">$ cd $HBASE_HOME
$ mkdir lib/native
$ ln -s $HADOOP_HOME/lib/native lib/native/Linux-amd64-64</programlisting>
            Use the compression tool to check that LZ4 is installed on all nodes. Start up (or restart)
            HBase. Afterward, you can create and alter tables to enable LZ4 as a
            compression codec.:
            <screen>
hbase(main):003:0> <userinput>alter 'TestTable', {NAME => 'info', COMPRESSION => 'LZ4'}</userinput>
            </screen>
          </para>
        </section>
        <section
          xml:id="snappy.compression.installation">
          <title>Install Snappy Support</title>
          <para>HBase does not ship with Snappy support because of licensing issues. You can install
            Snappy binaries (for instance, by using <command>yum install snappy</command> on CentOS)
            or build Snappy from source. After installing Snappy, search for the shared library,
            which will be called <filename>libsnappy.so.X</filename> where X is a number. If you
            built from source, copy the shared library to a known location on your system, such as
              <filename>/opt/snappy/lib/</filename>.</para>
          <para>In addition to the Snappy library, HBase also needs access to the Hadoop shared
            library, which will be called something like <filename>libhadoop.so.X.Y</filename>,
            where X and Y are both numbers. Make note of the location of the Hadoop library, or copy
            it to the same location as the Snappy library.</para>
          <note>
            <para>The Snappy and Hadoop libraries need to be available on each node of your cluster.
              See <xref
                linkend="compression.test" /> to find out how to test that this is the case.</para>
            <para>See <xref
                linkend="hbase.regionserver.codecs" /> to configure your RegionServers to fail to
              start if a given compressor is not available.</para>
          </note>
          <para>Each of these library locations need to be added to the environment variable
              <envar>HBASE_LIBRARY_PATH</envar> for the operating system user that runs HBase. You
            need to restart the RegionServer for the changes to take effect.</para>
        </section>


        <section
          xml:id="compression.test">
          <title>CompressionTest</title>
          <para>You can use the CompressionTest tool to verify that your compressor is available to
            HBase:</para>
          <screen language="bourne">
 $ hbase org.apache.hadoop.hbase.util.CompressionTest hdfs://<replaceable>host/path/to/hbase</replaceable> snappy       
          </screen>
        </section>


        <section
          xml:id="hbase.regionserver.codecs">
          <title>Enforce Compression Settings On a RegionServer</title>
          <para>You can configure a RegionServer so that it will fail to restart if compression is
            configured incorrectly, by adding the option hbase.regionserver.codecs to the
              <filename>hbase-site.xml</filename>, and setting its value to a comma-separated list
            of codecs that need to be available. For example, if you set this property to
              <literal>lzo,gz</literal>, the RegionServer would fail to start if both compressors
            were not available. This would prevent a new server from being added to the cluster
            without having codecs configured properly.</para>
        </section>
      </section>

      <section
        xml:id="changing.compression">
        <title>Enable Compression On a ColumnFamily</title>
        <para>To enable compression for a ColumnFamily, use an <code>alter</code> command. You do
          not need to re-create the table or copy data. If you are changing codecs, be sure the old
          codec is still available until all the old StoreFiles have been compacted.</para>
        <example>
          <title>Enabling Compression on a ColumnFamily of an Existing Table using HBase
            Shell</title>
          <screen><![CDATA[
hbase> disable 'test'
hbase> alter 'test', {NAME => 'cf', COMPRESSION => 'GZ'}
hbase> enable 'test']]>
        </screen>
        </example>
        <example>
          <title>Creating a New Table with Compression On a ColumnFamily</title>
          <screen><![CDATA[
hbase> create 'test2', { NAME => 'cf2', COMPRESSION => 'SNAPPY' }         
          ]]></screen>
        </example>
        <example>
          <title>Verifying a ColumnFamily's Compression Settings</title>
          <screen><![CDATA[
hbase> describe 'test'
DESCRIPTION                                          ENABLED
 'test', {NAME => 'cf', DATA_BLOCK_ENCODING => 'NONE false
 ', BLOOMFILTER => 'ROW', REPLICATION_SCOPE => '0',
 VERSIONS => '1', COMPRESSION => 'GZ', MIN_VERSIONS
 => '0', TTL => 'FOREVER', KEEP_DELETED_CELLS => 'fa
 lse', BLOCKSIZE => '65536', IN_MEMORY => 'false', B
 LOCKCACHE => 'true'}
1 row(s) in 0.1070 seconds
          ]]></screen>
        </example>
      </section>

      <section>
        <title>Testing Compression Performance</title>
        <para>HBase includes a tool called LoadTestTool which provides mechanisms to test your
          compression performance. You must specify either <literal>-write</literal> or
          <literal>-update-read</literal> as your first parameter, and if you do not specify another
        parameter, usage advice is printed for each option.</para>
        <example>
          <title><command>LoadTestTool</command> Usage</title>
          <screen language="bourne"><![CDATA[
$ bin/hbase org.apache.hadoop.hbase.util.LoadTestTool -h            
usage: bin/hbase org.apache.hadoop.hbase.util.LoadTestTool <options>
Options:
 -batchupdate                 Whether to use batch as opposed to separate
                              updates for every column in a row
 -bloom <arg>                 Bloom filter type, one of [NONE, ROW, ROWCOL]
 -compression <arg>           Compression type, one of [LZO, GZ, NONE, SNAPPY,
                              LZ4]
 -data_block_encoding <arg>   Encoding algorithm (e.g. prefix compression) to
                              use for data blocks in the test column family, one
                              of [NONE, PREFIX, DIFF, FAST_DIFF, PREFIX_TREE].
 -encryption <arg>            Enables transparent encryption on the test table,
                              one of [AES]
 -generator <arg>             The class which generates load for the tool. Any
                              args for this class can be passed as colon
                              separated after class name
 -h,--help                    Show usage
 -in_memory                   Tries to keep the HFiles of the CF inmemory as far
                              as possible.  Not guaranteed that reads are always
                              served from inmemory
 -init_only                   Initialize the test table only, don't do any
                              loading
 -key_window <arg>            The 'key window' to maintain between reads and
                              writes for concurrent write/read workload. The
                              default is 0.
 -max_read_errors <arg>       The maximum number of read errors to tolerate
                              before terminating all reader threads. The default
                              is 10.
 -multiput                    Whether to use multi-puts as opposed to separate
                              puts for every column in a row
 -num_keys <arg>              The number of keys to read/write
 -num_tables <arg>            A positive integer number. When a number n is
                              speicfied, load test tool  will load n table
                              parallely. -tn parameter value becomes table name
                              prefix. Each table name is in format
                              <tn>_1...<tn>_n
 -read <arg>                  <verify_percent>[:<#threads=20>]
 -regions_per_server <arg>    A positive integer number. When a number n is
                              specified, load test tool will create the test
                              table with n regions per server
 -skip_init                   Skip the initialization; assume test table already
                              exists
 -start_key <arg>             The first key to read/write (a 0-based index). The
                              default value is 0.
 -tn <arg>                    The name of the table to read or write
 -update <arg>                <update_percent>[:<#threads=20>][:<#whether to
                              ignore nonce collisions=0>]
 -write <arg>                 <avg_cols_per_key>:<avg_data_size>[:<#threads=20>]
 -zk <arg>                    ZK quorum as comma-separated host names without
                              port numbers
 -zk_root <arg>               name of parent znode in zookeeper            
          ]]></screen>
        </example>
        <example>
          <title>Example Usage of LoadTestTool</title>
          <screen language="bourne">
$ hbase org.apache.hadoop.hbase.util.LoadTestTool -write 1:10:100 -num_keys 1000000
          -read 100:30 -num_tables 1 -data_block_encoding NONE -tn load_test_tool_NONE
          </screen>
        </example>
      </section>
    </section>

    <section xml:id="data.block.encoding.enable">
      <title>Enable Data Block Encoding</title>
      <para>Codecs are built into HBase so no extra configuration is needed. Codecs are enabled on a
        table by setting the <code>DATA_BLOCK_ENCODING</code> property. Disable the table before
        altering its DATA_BLOCK_ENCODING setting. Following is an example using HBase Shell:</para>
      <example>
        <title>Enable Data Block Encoding On a Table</title>
        <screen><![CDATA[
hbase>  disable 'test'
hbase> alter 'test', { NAME => 'cf', DATA_BLOCK_ENCODING => 'FAST_DIFF' }
Updating all regions with the new schema...
0/1 regions updated.
1/1 regions updated.
Done.
0 row(s) in 2.2820 seconds
hbase> enable 'test'
0 row(s) in 0.1580 seconds          
          ]]></screen>
      </example>
      <example>
        <title>Verifying a ColumnFamily's Data Block Encoding</title>
        <screen><![CDATA[
hbase> describe 'test'
DESCRIPTION                                          ENABLED
 'test', {NAME => 'cf', DATA_BLOCK_ENCODING => 'FAST true
 _DIFF', BLOOMFILTER => 'ROW', REPLICATION_SCOPE =>
 '0', VERSIONS => '1', COMPRESSION => 'GZ', MIN_VERS
 IONS => '0', TTL => 'FOREVER', KEEP_DELETED_CELLS =
 > 'false', BLOCKSIZE => '65536', IN_MEMORY => 'fals
 e', BLOCKCACHE => 'true'}
1 row(s) in 0.0650 seconds          
        ]]></screen>
      </example>
    </section>
  </appendix>


  <appendix>
      <title xml:id="ycsb"><link xlink:href="https://github.com/brianfrankcooper/YCSB/">YCSB: The Yahoo! Cloud Serving Benchmark</link> and HBase</title>
      <para>TODO: Describe how YCSB is poor for putting up a decent cluster load.</para>
      <para>TODO: Describe setup of YCSB for HBase.  In particular, presplit your tables before you start
          a run.  See <link xlink:href="https://issues.apache.org/jira/browse/HBASE-4163">HBASE-4163 Create Split Strategy for YCSB Benchmark</link>
          for why and a little shell command for how to do it.</para>
      <para>Ted Dunning redid YCSB so it's mavenized and added facility for verifying workloads.  See <link xlink:href="https://github.com/tdunning/YCSB">Ted Dunning's YCSB</link>.</para>

  </appendix>

<appendix xml:id="hfilev2">
   <title>HFile format version 2</title>

   <section><title>Motivation </title>
   <para>Note:  this feature was introduced in HBase 0.92</para>
   <para>We found it necessary to revise the HFile format after encountering high memory usage and slow startup times caused by large Bloom filters and block indexes in the region server. Bloom filters can get as large as 100 MB per HFile, which adds up to 2 GB when aggregated over 20 regions. Block indexes can grow as large as 6 GB in aggregate size over the same set of regions. A region is not considered opened until all of its block index data is loaded. Large Bloom filters produce a different performance problem: the first get request that requires a Bloom filter lookup will incur the latency of loading the entire Bloom filter bit array.</para>
   <para>To speed up region server startup we break Bloom filters and block indexes into multiple blocks and write those blocks out as they fill up, which also reduces the HFile writer’s memory footprint. In the Bloom filter case, “filling up a block” means accumulating enough keys to efficiently utilize a fixed-size bit array, and in the block index case we accumulate an “index block” of the desired size. Bloom filter blocks and index blocks (we call these “inline blocks”) become interspersed with data blocks, and as a side effect we can no longer rely on the difference between block offsets to determine data block length, as it was done in version 1.</para>
   <para>HFile is a low-level file format by design, and it should not deal with application-specific details such as Bloom filters, which are handled at StoreFile level. Therefore, we call Bloom filter blocks in an HFile "inline" blocks. We also supply HFile with an interface to write those inline blocks. </para>
   <para>Another format modification aimed at reducing the region server startup time is to use a contiguous “load-on-open” section that has to be loaded in memory at the time an HFile is being opened. Currently, as an HFile opens, there are separate seek operations to read the trailer, data/meta indexes, and file info. To read the Bloom filter, there are two more seek operations for its “data” and “meta” portions. In version 2, we seek once to read the trailer and seek again to read everything else we need to open the file from a contiguous block.</para></section>
   <section><title>HFile format version 1 overview </title><para>As we will be discussing the changes we are making to the HFile format, it is useful to give a short overview of the previous (HFile version 1) format. An HFile in the existing format is structured as follows:
           <inlinemediaobject>
               <imageobject>
                   <imagedata align="center" valign="middle" fileref="hfile.png" />
               </imageobject>
               <textobject>
                 <phrase>HFile Version 1</phrase>
               </textobject>
               
           </inlinemediaobject>
           <footnote><para>Image courtesy of Lars George, <link xlink:href="http://www.larsgeorge.com/2009/10/hbase-architecture-101-storage.html">hbase-architecture-101-storage.html</link>.</para></footnote>
       </para>
       <section><title> Block index format in version 1 </title>
   <para>The block index in version 1 is very straightforward. For each entry, it contains: </para>
   <orderedlist>
      <listitem>
         <para>Offset (long)</para>
      </listitem>
      <listitem>
         <para>Uncompressed size (int)</para>
      </listitem>
      <listitem>
         <para>Key (a serialized byte array written using Bytes.writeByteArray) </para>
         <orderedlist>
             <listitem>
                 <para>Key length as a variable-length integer (VInt)
                  </para>
              </listitem>
             <listitem>
                 <para>
                     Key bytes
                 </para>
             </listitem>
         </orderedlist>
      </listitem>
   </orderedlist>
   <para>The number of entries in the block index is stored in the fixed file trailer, and has to be passed in to the method that reads the block index. One of the limitations of the block index in version 1 is that it does not provide the compressed size of a block, which turns out to be necessary for decompression. Therefore, the HFile reader has to infer this compressed size from the offset difference between blocks. We fix this limitation in version 2, where we store on-disk block size instead of uncompressed size, and get uncompressed size from the block header.</para></section></section><section><title>
      HBase file format with inline blocks (version 2)
      </title>
      <section><title> Overview</title>
   <para>The version of HBase introducing the above features reads both version 1 and 2 HFiles, but only writes version 2 HFiles. A version 2 HFile is structured as follows:
           <inlinemediaobject>
               <imageobject>
                   <imagedata align="center" valign="middle" fileref="hfilev2.png" />
               </imageobject>
               <textobject>
                 <phrase>HFile Version 2</phrase>
               </textobject>
           </inlinemediaobject>

   </para>
   </section>
   <section><title>Unified version 2 block format</title>
   <para>In the version 2 every block in the data section contains the following fields: </para>
   <orderedlist>
      <listitem>
         <para>8 bytes: Block type, a sequence of bytes equivalent to version 1's "magic records". Supported block types are: </para>
         <orderedlist>
             <listitem>
                 <para>DATA – data blocks
                  </para>
              </listitem>
             <listitem>
                 <para>
                     LEAF_INDEX – leaf-level index blocks in a multi-level-block-index
                 </para>
             </listitem>
             <listitem>
                 <para>
                     BLOOM_CHUNK – Bloom filter chunks
                  </para>
              </listitem>
             <listitem>
                 <para>
                     META – meta blocks (not used for Bloom filters in version 2 anymore)
                  </para>
              </listitem>
             <listitem>
                 <para>
                     INTERMEDIATE_INDEX – intermediate-level index blocks in a multi-level blockindex
                  </para>
              </listitem>
             <listitem>
                 <para>
                     ROOT_INDEX – root>level index blocks in a multi>level block index
                  </para>
              </listitem>
             <listitem>
                 <para>
                     FILE_INFO – the “file info” block, a small key>value map of metadata
                  </para>
              </listitem>
             <listitem>
                 <para>
                     BLOOM_META – a Bloom filter metadata block in the load>on>open section
                  </para>
              </listitem>
             <listitem>
                 <para>
                     TRAILER – a fixed>size file trailer. As opposed to the above, this is not an
                     HFile v2 block but a fixed>size (for each HFile version) data structure
                  </para>
              </listitem>
             <listitem>
                 <para>
                      INDEX_V1 – this block type is only used for legacy HFile v1 block
                  </para>
              </listitem>
         </orderedlist>
      </listitem>
      <listitem>
         <para>Compressed size of the block's data, not including the header (int).
         </para>
                 <para>
Can be used for skipping the current data block when scanning HFile data.
                  </para>
      </listitem>
      <listitem>
         <para>Uncompressed size of the block's data, not including the header (int)</para>
                 <para>
 This is equal to the compressed size if the compression algorithm is NON
                  </para>
      </listitem>
      <listitem>
         <para>File offset of the previous block of the same type (long)</para>
                 <para>
 Can be used for seeking to the previous data/index block
                  </para>
      </listitem>
      <listitem>
         <para>Compressed data (or uncompressed data if the compression algorithm is NONE).</para>
      </listitem>
   </orderedlist>
   <para>The above format of blocks is used in the following HFile sections:</para>
   <orderedlist>
      <listitem>
         <para>Scanned block section. The section is named so because it contains all data blocks that need to be read when an HFile is scanned sequentially.  Also contains leaf block index and Bloom chunk blocks. </para>
      </listitem>
      <listitem>
         <para>Non-scanned block section. This section still contains unified-format v2 blocks but it does not have to be read when doing a sequential scan. This section contains “meta” blocks and intermediate-level index blocks.
         </para>
      </listitem>
   </orderedlist>
   <para>We are supporting “meta” blocks in version 2 the same way they were supported in version 1, even though we do not store Bloom filter data in these blocks anymore. </para></section>

<section><title> Block index in version 2</title>
   <para>There are three types of block indexes in HFile version 2, stored in two different formats (root and non-root): </para>
   <orderedlist>
      <listitem>
         <para>Data index — version 2 multi-level block index, consisting of:</para>
         <orderedlist>
          <listitem>
             <para>
 Version 2 root index, stored in the data block index section of the file
             </para>
          </listitem>
          <listitem>
             <para>
Optionally, version 2 intermediate levels, stored in the non%root format in   the data index section of the file.    Intermediate levels can only be present if leaf level blocks are present
             </para>
          </listitem>
          <listitem>
             <para>
Optionally, version 2 leaf levels, stored in the non%root format inline with   data blocks
             </para>
          </listitem>
      </orderedlist>
      </listitem>
      <listitem>
         <para>Meta index — version 2 root index format only, stored in the meta index section of the file</para>
      </listitem>
      <listitem>
         <para>Bloom index — version 2 root index format only, stored in the “load-on-open” section as part of Bloom filter metadata.</para>
      </listitem>
   </orderedlist></section>
<section><title>
      Root block index format in version 2</title>
   <para>This format applies to:</para>
   <orderedlist>
      <listitem>
         <para>Root level of the version 2 data index</para>
      </listitem>
      <listitem>
         <para>Entire meta and Bloom indexes in version 2, which are always single-level. </para>
      </listitem>
   </orderedlist>
   <para>A version 2 root index block is a sequence of entries of the following format, similar to entries of a version 1 block index, but storing on-disk size instead of uncompressed size. </para>
   <orderedlist>
      <listitem>
         <para>Offset (long) </para>
             <para>
This offset may point to a data block or to a deeper>level index block.
             </para>
      </listitem>
      <listitem>
         <para>On-disk size (int) </para>
      </listitem>
      <listitem>
         <para>Key (a serialized byte array stored using Bytes.writeByteArray) </para>
         <orderedlist>
          <listitem>
             <para>Key (VInt)
             </para>
          </listitem>
          <listitem>
             <para>Key bytes
             </para>
          </listitem>
      </orderedlist>
      </listitem>
   </orderedlist>
   <para>A single-level version 2 block index consists of just a single root index block. To read a root index block of version 2, one needs to know the number of entries. For the data index and the meta index the number of entries is stored in the trailer, and for the Bloom index it is stored in the compound Bloom filter metadata.</para>

   <para>For a multi-level block index we also store the following fields in the root index block in the load-on-open section of the HFile, in addition to the data structure described above:</para>
   <orderedlist>
      <listitem>
         <para>Middle leaf index block offset</para>
      </listitem>
      <listitem>
         <para>Middle leaf block on-disk size (meaning the leaf index block containing the reference to the “middle” data block of the file) </para>
      </listitem>
      <listitem>
         <para>The index of the mid-key (defined below) in the middle leaf-level block.</para>
      </listitem>
   </orderedlist>
   <para/>
   <para>These additional fields are used to efficiently retrieve the mid-key of the HFile used in HFile splits, which we define as the first key of the block with a zero-based index of (n – 1) / 2, if the total number of blocks in the HFile is n. This definition is consistent with how the mid-key was determined in HFile version 1, and is reasonable in general, because blocks are likely to be the same size on average, but we don’t have any estimates on individual key/value pair sizes. </para>
   <para/>
   <para>When writing a version 2 HFile, the total number of data blocks pointed to by every leaf-level index block is kept track of. When we finish writing and the total number of leaf-level blocks is determined, it is clear which leaf-level block contains the mid-key, and the fields listed above are computed.  When reading the HFile and the mid-key is requested, we retrieve the middle leaf index block (potentially from the block cache) and get the mid-key value from the appropriate position inside that leaf block.</para></section>
<section><title>
      Non-root block index format in version 2</title>
   <para>This format applies to intermediate-level and leaf index blocks of a version 2 multi-level data block index. Every non-root index block is structured as follows. </para>
   <orderedlist>
      <listitem>
         <para>numEntries: the number of entries (int). </para>
      </listitem>
      <listitem>
         <para>entryOffsets: the “secondary index” of offsets of entries in the block, to facilitate a quick binary search on the key (numEntries + 1 int values). The last value is the total length of all entries in this index block. For example, in a non-root index block with entry sizes 60, 80, 50 the “secondary index” will contain the following int array: {0, 60, 140, 190}.</para>
      </listitem>
      <listitem>
         <para>Entries. Each entry contains: </para>
         <orderedlist>
          <listitem>
             <para>
Offset of the block referenced by this entry in the file (long)
             </para>
          </listitem>
          <listitem>
             <para>
On>disk size of the referenced block (int)
             </para>
          </listitem>
          <listitem>
             <para>
Key. The length can be calculated from entryOffsets.
             </para>
          </listitem>
      </orderedlist>

      </listitem>
   </orderedlist></section><section><title>
      Bloom filters in version 2</title>
   <para>In contrast with version 1, in a version 2 HFile Bloom filter metadata is stored in the load-on-open section of the HFile for quick startup. </para>
   <orderedlist>
      <listitem>
         <para>A compound Bloom filter. </para>
         <orderedlist>
          <listitem>
             <para>
 Bloom filter version = 3 (int). There used to be a DynamicByteBloomFilter class that had the Bloom   filter version number 2
             </para>
          </listitem>
          <listitem>
             <para>
The total byte size of all compound Bloom filter chunks (long)
             </para>
          </listitem>
          <listitem>
             <para>
 Number of hash functions (int
             </para>
          </listitem>
          <listitem>
             <para>
Type of hash functions (int)
             </para>
          </listitem>
          <listitem>
             <para>
The total key count inserted into the Bloom filter (long)
             </para>
          </listitem>
          <listitem>
             <para>
The maximum total number of keys in the Bloom filter (long)
             </para>
          </listitem>
          <listitem>
             <para>
The number of chunks (int)
             </para>
          </listitem>
          <listitem>
             <para>
Comparator class used for Bloom filter keys, a UTF>8 encoded string stored   using Bytes.writeByteArray
             </para>
          </listitem>
          <listitem>
             <para>
 Bloom block index in the version 2 root block index format
             </para>
          </listitem>
      </orderedlist>
      </listitem>
   </orderedlist></section><section><title>File Info format in versions 1 and 2</title>
   <para>The file info block is a serialized <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/io/HbaseMapWritable.html">HbaseMapWritable</link> (essentially a map from byte arrays to byte arrays) with the following keys, among others. StoreFile-level logic adds more keys to this.</para>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>hfile.LASTKEY </para>
            </entry>
            <entry>
               <para>The last key of the file (byte array) </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>hfile.AVG_KEY_LEN </para>
            </entry>
            <entry>
               <para>The average key length in the file (int) </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>hfile.AVG_VALUE_LEN </para>
            </entry>
            <entry>
               <para>The average value length in the file (int) </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>File info format did not change in version 2. However, we moved the file info to the final section of the file, which can be loaded as one block at the time the HFile is being opened. Also, we do not store comparator in the version 2 file info anymore. Instead, we store it in the fixed file trailer. This is because we need to know the comparator at the time of parsing the load-on-open section of the HFile.</para></section><section><title>
      Fixed file trailer format differences between versions 1 and 2</title>
   <para>The following table shows common and different fields between fixed file trailers in versions 1 and 2. Note that the size of the trailer is different depending on the version, so it is “fixed” only within one version. However, the version is always stored as the last four-byte integer in the file. </para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="2">
<colspec colname='c1'/>
<colspec colname='c2'/>
<tbody>
    <row>
            <entry>
               <para>Version 1 </para>
            </entry>
            <entry>
               <para>Version 2 </para>
            </entry>
         </row>
         <row>
            <entry align="center" namest="c1" nameend="c2">
               <para>File info offset (long) </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Data index offset (long) </para>
            </entry>
            <entry>
                <para>loadOnOpenOffset (long)</para>
                <para><emphasis>The offset of the section that we need toload when opening the file.</emphasis></para>
            </entry>
         </row>
         <row>
            <entry align="center" namest="c1" nameend="c2">
               <para>Number of data index entries (int) </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>metaIndexOffset (long)</para>
               <para>This field is not being used by the version 1 reader, so we removed it from version 2.</para>
            </entry>
            <entry>
               <para>uncompressedDataIndexSize (long)</para>
               <para>The total uncompressed size of the whole data block index, including root-level, intermediate-level, and leaf-level blocks.</para>
            </entry>
         </row>
         <row>
            <entry namest="c1" nameend="c2" align="center">
               <para>Number of meta index entries (int) </para>
            </entry>
         </row>
         <row>
            <entry namest="c1" nameend="c2" align="center">
               <para>Total uncompressed bytes (long) </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>numEntries (int) </para>
            </entry>
            <entry>
               <para>numEntries (long) </para>
            </entry>
         </row>
         <row>
            <entry namest="c1" nameend="c2" align="center">
               <para>Compression codec: 0 = LZO, 1 = GZ, 2 = NONE (int) </para>
            </entry>
         </row>
         <row>
            <entry>
               <para></para>
            </entry>
            <entry>
               <para>The number of levels in the data block index (int) </para>
            </entry>
         </row>
         <row>
            <entry>
               <para></para>
            </entry>
            <entry>
               <para>firstDataBlockOffset (long)</para>
               <para>The offset of the first first data block. Used when scanning. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para></para>
            </entry>
            <entry>
               <para>lastDataBlockEnd (long)</para>
               <para>The offset of the first byte after the last key/value data block. We don't need to go beyond this offset when scanning. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Version: 1 (int) </para>
            </entry>
            <entry>
               <para>Version: 2 (int) </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para/></section>
   <section><title>getShortMidpointKey(an optimization for data index block)</title>
     <para>Note: this optimization was introduced in HBase 0.95+</para>
       <para>HFiles contain many blocks that contain a range of sorted Cells. Each cell has a key. To save IO when reading Cells, the HFile also has an index that maps a Cell's start key to the offset of the beginning of a particular block. Prior to this optimization, HBase would use the key of the first cell in each data block as the index key.</para>
     <para>In HBASE-7845, we generate a new key that is lexicographically larger than the last key of the previous block and lexicographically equal or smaller than the start key of the current block. While actual keys can potentially be very long, this "fake key" or "virtual key" can be much shorter. For example, if the stop key of previous block is "the quick brown fox", the start key of current block is "the who", we could use "the r" as our virtual key in our hfile index.</para>
     <para>There are two benefits to this:</para>
     <itemizedlist>
     <listitem><para>having shorter keys reduces the hfile index size, (allowing us to keep more indexes in memory), and</para></listitem>
     <listitem><para>using something closer to the end key of the previous block allows us to avoid a potential extra IO when the target key lives in between the "virtual key" and the key of the first element in the target block.</para></listitem>
     </itemizedlist>
     <para>This optimization (implemented by the getShortMidpointKey method) is inspired by LevelDB's ByteWiseComparatorImpl::FindShortestSeparator() and FindShortSuccessor().</para>
   </section></section></appendix>

  <appendix xml:id="other.info">
      <title>Other Information About HBase</title>
       <section xml:id="other.info.videos"><title>HBase Videos</title>
         <para>Introduction to HBase
            <itemizedlist>
              <listitem><para><link xlink:href="http://www.cloudera.com/content/cloudera/en/resources/library/presentation/chicago_data_summit_apache_hbase_an_introduction_todd_lipcon.html">Introduction to HBase</link> by Todd Lipcon (Chicago Data Summit 2011).
			  </para></listitem>
			  <listitem><para><link xlink:href="http://www.cloudera.com/videos/intorduction-hbase-todd-lipcon">Introduction to HBase</link> by Todd Lipcon (2010).
			  </para></listitem>
			</itemizedlist>
         </para>
         <para><link xlink:href="http://www.cloudera.com/videos/hadoop-world-2011-presentation-video-building-realtime-big-data-services-at-facebook-with-hadoop-and-hbase">Building Real Time Services at Facebook with HBase</link> by Jonathan Gray (Hadoop World 2011).
         </para>
         <para><link xlink:href="http://www.cloudera.com/videos/hw10_video_how_stumbleupon_built_and_advertising_platform_using_hbase_and_hadoop">HBase and Hadoop, Mixing Real-Time and Batch Processing at StumbleUpon</link> by JD Cryans (Hadoop World 2010).
         </para>
       </section>
       <section xml:id="other.info.pres"><title>HBase Presentations (Slides)</title>
         <para><link xlink:href="http://www.cloudera.com/content/cloudera/en/resources/library/hadoopworld/hadoop-world-2011-presentation-video-advanced-hbase-schema-design.html">Advanced HBase Schema Design</link> by Lars George (Hadoop World 2011).
         </para>
         <para><link xlink:href="http://www.slideshare.net/cloudera/chicago-data-summit-apache-hbase-an-introduction">Introduction to HBase</link> by Todd Lipcon (Chicago Data Summit 2011).
         </para>
         <para><link xlink:href="http://www.slideshare.net/cloudera/hw09-practical-h-base-getting-the-most-from-your-h-base-install">Getting The Most From Your HBase Install</link> by Ryan Rawson, Jonathan Gray (Hadoop World 2009).
         </para>
       </section>
       <section xml:id="other.info.papers"><title>HBase Papers</title>
         <para><link xlink:href="http://research.google.com/archive/bigtable.html">BigTable</link> by Google (2006).
         </para>
         <para><link xlink:href="http://www.larsgeorge.com/2010/05/hbase-file-locality-in-hdfs.html">HBase and HDFS Locality</link> by Lars George (2010).
         </para>
         <para><link xlink:href="http://ianvarley.com/UT/MR/Varley_MastersReport_Full_2009-08-07.pdf">No Relation: The Mixed Blessings of Non-Relational Databases</link> by Ian Varley (2009).
         </para>
       </section>
       <section xml:id="other.info.sites"><title>HBase Sites</title>
         <para><link xlink:href="http://www.cloudera.com/blog/category/hbase/">Cloudera's HBase Blog</link> has a lot of links to useful HBase information.
		<itemizedlist>
			<listitem><para><link xlink:href="http://www.cloudera.com/blog/2010/04/cap-confusion-problems-with-partition-tolerance/">CAP Confusion</link> is a relevant entry for background information on
			distributed storage systems.</para>
			</listitem>
		</itemizedlist>
         </para>
         <para><link xlink:href="http://wiki.apache.org/hadoop/HBase/HBasePresentations">HBase Wiki</link> has a page with a number of presentations.
         </para>
         <para><link xlink:href="http://refcardz.dzone.com/refcardz/hbase">HBase RefCard</link> from DZone.
         </para>
       </section>
       <section xml:id="other.info.books"><title>HBase Books</title>
         <para><link xlink:href="http://shop.oreilly.com/product/0636920014348.do">HBase:  The Definitive Guide</link> by Lars George.
         </para>
       </section>
       <section xml:id="other.info.books.hadoop"><title>Hadoop Books</title>
         <para><link xlink:href="http://shop.oreilly.com/product/9780596521981.do">Hadoop:  The Definitive Guide</link> by Tom White.
         </para>
       </section>

  </appendix>

  <appendix xml:id="hbase.history"><title>HBase History</title>
    <itemizedlist>
	  <listitem><para>2006:  <link xlink:href="http://research.google.com/archive/bigtable.html">BigTable</link> paper published by Google.
	  </para></listitem>
	  <listitem><para>2006 (end of year):  HBase development starts.
	  </para></listitem>
	  <listitem><para>2008:  HBase becomes Hadoop sub-project.
	  </para></listitem>
	  <listitem><para>2010:  HBase becomes Apache top-level project.
	  </para></listitem>
	</itemizedlist>
  </appendix>

  <appendix xml:id="asf" ><title>HBase and the Apache Software Foundation</title>
    <para>HBase is a project in the Apache Software Foundation and as such there are responsibilities to the ASF to ensure
    a healthy project.</para>
       <section xml:id="asf.devprocess"><title>ASF Development Process</title>
        <para>See the <link xlink:href="http://www.apache.org/dev/#committers">Apache Development Process page</link>
        for all sorts of information on how the ASF is structured (e.g., PMC, committers, contributors), to tips on contributing
        and getting involved, and how open-source works at ASF.
        </para>
       </section>
       <section xml:id="asf.reporting"><title>ASF Board Reporting</title>
         <para>Once a quarter, each project in the ASF portfolio submits a report to the ASF board.  This is done by the HBase project
         lead and the committers.  See <link xlink:href="http://www.apache.org/foundation/board/reporting">ASF board reporting</link> for more information.
         </para>
       </section>
  </appendix>

  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="tracing.xml" />
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="rpc.xml" />

  <index xml:id="book_index">
  <title>Index</title>
  </index>
</book>
