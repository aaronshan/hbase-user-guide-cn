<?xml version="1.0" encoding="UTF-8"?>
<chapter
  version="5.0"
  xml:id="security"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:xi="http://www.w3.org/2001/XInclude"
  xmlns:svg="http://www.w3.org/2000/svg"
  xmlns:m="http://www.w3.org/1998/Math/MathML"
  xmlns:html="http://www.w3.org/1999/xhtml"
  xmlns:db="http://docbook.org/ns/docbook">
  <!--
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
-->
  <title>安全的Apache HBase</title>
  <section
    xml:id="hbase.secure.configuration">
    <title>安全的客户端访问Apache HBase</title>
    <para>
        最新的Apache HBase (&gt;= 0.92)发行版支持可选择的客户端SASL认证
        <footnote>
        <para>可以参考Matteo Bertozzi's的文章 <link
            xlink:href="http://www.cloudera.com/blog/2012/09/understanding-user-authentication-and-authorization-in-apache-hbase/">Understanding
            User Authentication and Authorization in Apache HBase</link>。</para>
      </footnote>.</para>
    <para>
        下面描述如何设置Apache HBase和客户端，以使得可以进行安全的HBase资源连接。
        </para>

    <section xml:id="security.prerequisites">
      <title>先决条件</title>
      <variablelist>
        <varlistentry>
          <term>Hadoop的身份验证配置</term>
          <listitem>
            <para>
                为了使用强验证来运行HBase RPC，你必须设置<code>hbase.security.authentication</code>的值为<literal>true</literal>。
                在这个例子中，你也必须设置<code>hadoop.security.authentication</code>的值为<literal>true</literal>。否则，你将能在HBase中使用强验证
                但底层的HDFS不是使用强验证，这会把所有的好处都抵消掉。
                </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Kerberos KDC</term>
          <listitem>
            <para> 你需要有一个工作中的Kerberos KDC。 </para>
            <para>
                HBase配置安全的客户端访问需要运行在安全的HDFS集群上。HBase必须能够验证HDFS的服务。HBase需要Kerberos凭证与启用Kerberos的HDFS守护进程交互。
                验证一个服务应该使用keytab文件来完成。为HBase创建keytabs的过程与为Hadoop创建keytabs的过程相同。这些步骤在这里被省略。复制生成的keytab文件
                到HBase的Master和Regionserver，在部署时使它们只能被运行HBase守护进程的账户读取。 </para>
            <para>
                Kerberos主体有三个部分，格式为<code>username/fully.qualified.domain.name@YOUR-REALM.COM</code>。
                我们建议使用<code>hbase</code>作为用户名的一部分。 </para>
            <para>
                下面是一个配置Kerberos操作的属性的例子。你必须在集群中服务器上的每一个<code>hbase-site.xml</code>文件进行配置。
                即使对于最基本的交互，也需要使用安全的Hadoop配置，这和HBase的安全相互独立。
                 </para>
            <programlisting language="xml"><![CDATA[
<property>
  <name>hbase.regionserver.kerberos.principal</name>
  <value>hbase/_HOST@YOUR-REALM.COM</value>
</property>
<property>
  <name>hbase.regionserver.keytab.file</name>
  <value>/etc/hbase/conf/keytab.krb5</value>
</property>
<property>
  <name>hbase.master.kerberos.principal</name>
  <value>hbase/_HOST@YOUR-REALM.COM</value>
</property>
<property>
  <name>hbase.master.keytab.file</name>
  <value>/etc/hbase/conf/keytab.krb5</value>
</property>
    ]]></programlisting>
            <para>
                每一个HBase客户端用户应该被给予一个Kerberos主体。这个主体应该被分配一个密码（而不是keytab文件）。客户端主体的<code>maxrenewlife</code>应该被设置，以便它可以在
                HBase客户端进程的续期内完成。例如，如果一个用户运行一个长时间的HBase客户端处理过程（至多花费3天），我们可能在<code>kadmin</code>使用：<code>addprinc -maxrenewlife
                3days</code>创建这个用户的主体。
            </para>
            <para>
                长时间运行的守护进程，需要到HBase的客户端访问无限期的寿命可以改为配置为从密钥表登录。对于运行的守护进程等各个主机上，创建的kadmin或kadmin.local密钥表。用于HBase的服务创建keytabs的过程是相同的，为的Hadoop创建keytabs。这些步骤在这里被省略。复制生成的密钥表文件到客户端守护进程就会执行，使他们只能读取到用户帐户下的守护进程运行。复制生成的keytab文件
                到HBase的Master和Regionserver，在部署时使它们只能被运行HBase守护进程的账户读取。
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section>
      <title>安全操作的服务器端配置</title>
      <para>
          首先，参考<xref linkend="security.prerequisites" />并且确定你底层的HDFS配置是安全的。
          </para>
      <para> 增加下面的内容到集群中的每一个服务器中的 <code>hbase-site.xml</code> 文件中： </para>
      <programlisting language="xml"><![CDATA[
<property>
  <name>hbase.security.authentication</name>
  <value>kerberos</value>
</property>
<property>
  <name>hbase.security.authorization</name>
  <value>true</value>
</property>
<property>
<name>hbase.coprocessor.region.classes</name>
  <value>org.apache.hadoop.hbase.security.token.TokenProvider</value>
</property>
    ]]></programlisting>
      <para>
          当配置好这些内容之后，关闭且重启HBase服务以使新的配置生效。
           </para>
    </section>

    <section>
      <title>安全操作客户端的配置</title>
      <para>
          首先，参考<xref linkend="security.prerequisites" />并且确定你底层的HDFS配置是安全的。
          </para>
      <para> 增加下面的内容到每一个客户端的 <code>hbase-site.xml</code> 文件中： </para>
      <programlisting language="xml"><![CDATA[
<property>
  <name>hbase.security.authentication</name>
  <value>kerberos</value>
</property>
    ]]></programlisting>
      <para>
          在与HBase集群通信之前，客户端环境必须通过<code>kinit</code>命令从KDC或者keytab登录到了Kerberos。
           </para>
      <para>
          注意，如果在客户端和服务器端站点文件的<code>hbase.security.authentication</code>不匹配，则客户端将无法与集群通信。
           </para>
      <para>
          一旦HBase的配置为安全的RPC，所以能够根据需要配置加密通信。要做到这一点，需要添加以下内容到每个客户端上的<code>hbase-site.xml</code>文件：
           </para>
      <programlisting language="xml"><![CDATA[
<property>
  <name>hbase.rpc.protection</name>
  <value>privacy</value>
</property>
    ]]></programlisting>
      <para>
          此配置属性还可以在每个连接设置。在新建<code>HTable</code>时配置<code>Configuration</code>：
           </para>
      <programlisting language="java">
Configuration conf = HBaseConfiguration.create();
conf.set("hbase.rpc.protection", "privacy");
HTable table = new HTable(conf, tablename);
    </programlisting>
      <para> 预计加密通信将造成大约10%的性能损失。</para>
    </section>


    <section xml:id="security.client.thrift">
      <title>安全操作客户端的配置 - Thrift网关</title>
      <para> 对于每一个Thrift网关，增加下面的内容到 <code>hbase-site.xml</code> 文件中： <programlisting language="xml"><![CDATA[
<property>
  <name>hbase.thrift.keytab.file</name>
  <value>/etc/hbase/conf/hbase.keytab</value>
</property>
<property>
  <name>hbase.thrift.kerberos.principal</name>
  <value>$USER/_HOST@HADOOP.LOCALDOMAIN</value>
  <!-- TODO: This may need to be  HTTP/_HOST@<REALM> and _HOST may not work.
   You may have  to put the concrete full hostname.
   -->
</property>
    ]]></programlisting>
      </para>
      <para>
          替代相应的凭证和keytab为<replaceable>$USER</replaceable>和<replaceable>$KEYTAB</replaceable>。
           </para>
      <para>
          为了使用Thrift API主体与HBase交互，添加<code>hbase.thrift.kerberos.principal</code>到 <code>_acl_</code>表也是必要的。
          例如，对于给定的Thrift API主体，<code>thrift_server</code>，管理访问权限，使用下面的命令就可以了：
      </para>
      <programlisting language="sql"><![CDATA[
grant 'thrift_server', 'RWCA'
    ]]></programlisting>
      <para>更多关于ACLs的信息，请查阅 <link
          linkend="hbase.accesscontrol.configuration">访问控制</link> 部分。 </para>

      <para>
          Thrift网关将使用提供的凭据与HBase进行身份验证。无身份验证将由Thrift网关自身执行。通过Thrift网关的所有客户端访问将使用Thrift网关的凭证，并有其特权。
      </para>
    </section>
    <section xml:id="security.gateway.thrift">
      <title>配置Thrift网管进行验证的客户端代表</title>
      <para>
          <xref linkend="security.client.thrift"/> 介绍如何认证一个固定用户使用Thrift客户端与HBase的连接。作为一种替代方法，你可以配置Thrift网关进行HBase客户端的身份验证，
          ，并使用代理的用户访问HBase。<link xlink:href="https://issues.apache.org/jira/browse/HBASE-11349"
              >HBASE-11349</link>是针对Thrift 1的实现，<link
              xlink:href="https://issues.apache.org/jira/browse/HBASE-11474">HBASE-11474</link>是针对Thrift 2的实现。
         </para>
      <note>
        <title>与Thrift框架传输的限制</title>
        <para>
            如果你使用框架式的传输，你还不能利用这个功能的优势，因为SASL在​​这个时候不能与Thrift的框架传输一起工作。
            </para>
      </note>
      <para>要启用它，请执行以下操作。</para>
      <procedure>
        <step>
          <para>按照在
              <xref linkend="security.client.thrift"/>中描述的过程，确定Thrift运行在安全模式。</para>
        </step>
        <step>
          <para>按照<xref
                  linkend="security.rest.gateway"/>中的描述，确定HBase的配置允许代理用户。</para>
        </step>
        <step>
          <para>
              在集群中的每一个运行Thrift网管的节点的<filename>hbase-site.xml</filename>文件，设置属性<code>hbase.thrift.security.qop</code>
              为下面三个值中的某一个：
              </para>
          <itemizedlist>
            <listitem>
              <para><literal>auth-conf</literal> - 身份验证，完整性和保密性检查</para>
            </listitem>
            <listitem>
              <para><literal>auth-int</literal> - 身份验证和完整性检查</para>
            </listitem>
            <listitem>
              <para><literal>auth</literal> - 只检查身份验证</para>
            </listitem>
          </itemizedlist>
        </step>
        <step>
          <para>
              重新启动Thrift网关程序，以使更改生效。如果一个节点运行Thrift，在<command>jps</command>命令的输出将列出一个<code>ThriftServer</code>进程。
              要停止一个节点上的Thrift，运行命令<command>bin/hbase-daemon.sh stop thrift</command>。要在节点上启动Thrift，运行命令<command>bin/hbase-daemon.sh start thrift</command>。
          </para>
        </step>
      </procedure>
    </section>
    
    <section>
      <title>安全操作客户端的配置 - REST网关</title>
      <para>
          添加如下内容到每一个REST网关的<code>hbase-site.xml</code>文件中：
          </para>
      <programlisting language="xml"><![CDATA[
<property>
  <name>hbase.rest.keytab.file</name>
  <value>$KEYTAB</value>
</property>
<property>
  <name>hbase.rest.kerberos.principal</name>
  <value>$USER/_HOST@HADOOP.LOCALDOMAIN</value>
</property>
    ]]></programlisting>
      <para>
          替代相应的凭证和keytab为<replaceable>$USER</replaceable>和<replaceable>$KEYTAB</replaceable>。
           </para>
      <para>
          REST网关将使用提供的凭据与HBase进行身份验证。无身份验证将由REST网关自身执行。通过REST网关的所有客户端访问将使用REST网关的凭证，并有其特权。
      </para>
      <para>
          为了使用REST API主体与HBase交互，添加<code>hbase.rest.kerberos.principal</code>到 <code>_acl_</code>表也是必要的。
          例如，对于给定的REST API主体，<code>rest_server</code>，管理访问权限，使用下面的命令就可以了：
      </para>
      <programlisting language="sql"><![CDATA[
grant 'rest_server', 'RWCA'
    ]]></programlisting>
      <para>更多关于ACLs的信息, 请查阅 <link
          linkend="hbase.accesscontrol.configuration">Access Control</link> 部分。 </para>
      <para>
          客户端与HBase集群通过REST网关的验证通过SPEGNO HTTP认证方式进行也是可能的。这是未来的工作。
      </para>
    </section>

    <section xml:id="security.rest.gateway">
      <title>REST网关模拟配置</title>
      <para>
          默认情况下，REST网关不支持模拟。它访问HBase的客户代表作为在上一节中所述的配置用户。对于HBase的服务器，所有的请求来自REST网关用户。实际用户是未知的。
          你可以开启模拟支持。在模拟中，REST网关用户是一个代理用户。 HBase的服务器知道每个请求的actual/real用户。因此，它可以应用适当的授权。
      </para>
      <para>
          要打开REST网关模拟，我们需要配置HBase的服务器（masters和region servers）给所有的代理用户;为了启用模拟而配置REST网关。
           </para>
      <para>
          要允许代理用户，为每个HBase服务器的 <code>hbase-site.xml</code> 文件添加一下内容：
           </para>
      <programlisting language="xml"><![CDATA[
<property>
  <name>hadoop.security.authorization</name>
  <value>true</value>
</property>
<property>
  <name>hadoop.proxyuser.$USER.groups</name>
  <value>$GROUPS</value>
</property>
<property>
  <name>hadoop.proxyuser.$USER.hosts</name>
  <value>$GROUPS</value>
</property>
    ]]></programlisting>
      <para>
          替代REST网关代理用户为$USER，和允许的组列表为$GROUPS。
          </para>
      <para>
          为了启用REST网关模拟，增加如下内容到每个REST网关的<code>hbase-site.xml</code>文件。
           </para>
      <programlisting language="xml"><![CDATA[
<property>
  <name>hbase.rest.authentication.type</name>
  <value>kerberos</value>
</property>
<property>
  <name>hbase.rest.authentication.kerberos.principal</name>
  <value>HTTP/_HOST@HADOOP.LOCALDOMAIN</value>
</property>
<property>
  <name>hbase.rest.authentication.kerberos.keytab</name>
  <value>$KEYTAB</value>
</property>
    ]]></programlisting>
      <para> 代替HTTP的keytab为 $KEYTAB。 </para>
    </section>

  </section>
  <!-- Secure Client Access to HBase -->

  <section
    xml:id="hbase.secure.simpleconfiguration">
    <title>简单的用户访问Apache HBase</title>
    <para>
      最新的Apache HBase (&gt;= 0.92)发行版支持可选择的客户端SASL认证
      <footnote>
      <para>可以参考Matteo Bertozzi's的文章 <link
              xlink:href="http://www.cloudera.com/blog/2012/09/understanding-user-authentication-and-authorization-in-apache-hbase/">Understanding
          User Authentication and Authorization in Apache HBase</link>。
       </para>
      </footnote>.</para>
    <para>下面描述如何设置Apache HBase和客户端，以使得可以进行安全的HBase资源连接。</para>

    <section>
      <title>简单VS安全访问</title>
      <para>
          以下部分显示了如何设置简单的用户访问。简单的用户访问没有操作HBase的安全方法。此方法用于防止用户的错误。它可以被用来在开发系统上模仿访问控制，而不必设置Kerberos。
           </para>
      <para>
          这个方法不被用来阻止恶意或者骇客攻击。为了使HBase的安全能阻止这些攻击，你需要配置HBase为安全模式。参考章节<link
              linkend="hbase.accesscontrol.configuration">Secure Client Access to HBase</link> 并且完成里面描述的所有步骤。
           </para>

      <section>
        <title>先决条件</title>
        <para> 无 </para>

        <section>
          <title>简单用户访问操作的服务器端配置</title>
          <para>
              增加下面的内容到集群中的每一个服务器上的 <code>hbase-site.xml</code> 文件中：
               </para>
          <programlisting language="xml"><![CDATA[
<property>
  <name>hbase.security.authentication</name>
  <value>simple</value>
</property>
<property>
  <name>hbase.security.authorization</name>
  <value>true</value>
</property>
<property>
  <name>hbase.coprocessor.master.classes</name>
  <value>org.apache.hadoop.hbase.security.access.AccessController</value>
</property>
<property>
  <name>hbase.coprocessor.region.classes</name>
  <value>org.apache.hadoop.hbase.security.access.AccessController</value>
</property>
    ]]></programlisting>
          <para>
              对于0.94版本，增加下面的内容到集群中的每一个服务器上的 <code>hbase-site.xml</code> 文件中：
              </para>
          <programlisting language="xml"><![CDATA[
<property>
  <name>hbase.rpc.engine</name>
  <value>org.apache.hadoop.hbase.ipc.SecureRpcEngine</value>
</property>
<property>
  <name>hbase.coprocessor.master.classes</name>
  <value>org.apache.hadoop.hbase.security.access.AccessController</value>
</property>
<property>
  <name>hbase.coprocessor.region.classes</name>
  <value>org.apache.hadoop.hbase.security.access.AccessController</value>
</property> 
    ]]></programlisting>
          <para>
              关闭HBase服务，然后重新启动以使得所有的配置更改生效。
               </para>
        </section>

        <section>
          <title>简单用户访问操作的客户器端配置</title>
          <para>
              增加下面的内容到每一个客户端的 <code>hbase-site.xml</code> 文件中：
              </para>
          <programlisting language="xml"><![CDATA[
<property>
  <name>hbase.security.authentication</name>
  <value>simple</value>
</property>
    ]]></programlisting>
          <para>
              对于0.94版本，增加下面的内容到集群中的每一个服务器上的 <code>hbase-site.xml</code> 文件中：
               </para>
          <programlisting language="xml"><![CDATA[
<property>
  <name>hbase.rpc.engine</name>
  <value>org.apache.hadoop.hbase.ipc.SecureRpcEngine</value>
</property>
    ]]></programlisting>
          <para>
              注意，如果在客户端和服务器端站点文件的<code>hbase.security.authentication</code>不匹配，则客户端将无法与集群通信。
               </para>
        </section>

        <section>
          <title>简单用户访问操作的客户器端配置 - Thrift网关</title>
          <para>
              Thrift网关用户需要访问。例如，未定Thrift API用户， <code>thrift_server</code>，可以通过下面的命令进行授权：
              </para>
          <programlisting language="sql"><![CDATA[
grant 'thrift_server', 'RWCA'
    ]]></programlisting>
          <para>
              更多关于ACLs的信息，请查阅 <link
              linkend="hbase.accesscontrol.configuration">Access Control</link> 部分。 </para>

          <para>
              Thrift网关将使用提供的凭据与HBase进行身份验证。无身份验证将由Thrift网关自身执行。通过Thrift网关的所有客户端访问将使用Thrift网关的凭证，并有其特权。
             </para>
        </section>

        <section>
          <title>简单用户访问操作的客户器端配置 - REST网关</title>

          <para>
              REST网关将使用提供的凭据与HBase进行身份验证。无身份验证将由REST网关自身执行。通过REST网关的所有客户端访问将使用REST网关的凭证，并有其特权。
          </para>
          <para>
              REST网关用户需要访问。例如，未定REST API用户， <code>rest_server</code>，可以通过下面的命令进行授权：
               </para>
          <programlisting language="sql"><![CDATA[
grant 'rest_server', 'RWCA'
    ]]></programlisting>
          <para>更多关于ACLs的信息，请查阅 <link
                  linkend="hbase.accesscontrol.configuration">Access Control</link> 部分。 </para>
          <para> 客户端与HBase集群通过REST网关的验证通过SPEGNO HTTP认证方式进行也是可能的。这是未来的工作。 </para>
        </section>
      </section>
    </section>

  </section>
  <!-- Simple User Access to Apache HBase -->

  <section
    xml:id="hbase.tags">
    <title>标签</title>
    <para>
        每一个单元格（cell）都有一个与它联系的元数据。给每一个单元格的数据部分添加元数据很困难。
         </para>
    <para>
        0.98版本的HBase的解决了这个问题，通过提供单元格的格式对应的标签。一些使用该标签的例子都是可见的标签，单元格级别的的ACLs，等等。
    </para>
    <para> 0.98版的HFile V3 文件格式支持标签，并且这个特性可以通过在配置中进行如下设置打开： </para>
    <programlisting language="xml"><![CDATA[
<property>
  <name>hfile.format.version</name>
  <value>3</value>
</property>
    ]]></programlisting>
    <para>
        每一个单元格可以有0或多个标签。每一个标签有一个类型，并且被实际上存储为字节数组。类型 <command>0-31</command> 是被系统保留的标签。例如，'1'被
        ACL保留而'2'被用作可见性标签。
         </para>
    <para>
        正如行键(rowkeys),列族（column families），列限定符（qualifiers）和值可以使用不同的编码算法来编码一样，标签也可以被编码。标签编码可以对每个列族开启。默认总是开启的。
        为了开启HFile标签编码，可以使用：
         </para>
    <programlisting language="java"><![CDATA[
HColumnDescriptor#setCompressTags(boolean compressTags)
    ]]></programlisting>
    <para>
        注意只有当DataBlockEncoder启用了针对列族的编码时，标签编码才会发生。
         </para>
    <para>
        当我们使用字典压缩的WAL项在WAL目前的标签也可以用词典进行压缩。每一个标签被使用的WAL词典单独压缩。要开启标签压缩WAL字典使物业
        就像我们使用字典压缩WAL实体一样，在WAL中的标签也可以使用字典压缩。每一个标签使用WAL字典被独立压缩。为了开启WAL的标签压缩功能，需要设置如下属性：
         </para>
    <programlisting language="xml"><![CDATA[
<property>
  <name>hbase.regionserver.wal.tags.enablecompression</name>
  <value>true</value>
</property>
    ]]></programlisting>
    <para>
        为了给Puts期间的每一个单元格增加标签，提供了如下api：
         </para>
    <programlisting language="java"><![CDATA[
Put#add(byte[] family, byte [] qualifier, byte [] value, Tag[] tag)
Put#add(byte[] family, byte[] qualifier, long ts, byte[] value, Tag[] tag)
    ]]></programlisting>

    <para>
        一些在开发的使用标签的特性时单元格级别的ACLs和可见性标签。这些特性使用标签框架并且允许用户在单元格级别获取更好的安全特性。
         </para>
    <para> 更多的细节，请查阅</para>
    <para>
      <link
        linkend="hbase.accesscontrol.configuration">Access Control</link>
      <link
        linkend="hbase.visibility.labels">Visibility labels</link>
    </para>
  </section>

  <section
    xml:id="hbase.accesscontrol.configuration">
    <title>访问控制</title>
    <para>
        更新的Apache HBase发行版（&gt;= 0.92）支持可选的基于列族和/或表级别的资源保护的访问控制列表 (ACL-)。
         </para>
    <para>
        下面使用一个给用户授权和回收表级别权限的例子，描述如何设置访问控制的安全HBase。
         </para>

    <section>
      <title>先决条件</title>
      <para>
          你必须配置HBase为安全或者简单用户访问操作。参考<link
              linkend="hbase.accesscontrol.configuration">安全的客户端访问HBase</link>或者<link
              linkend="hbase.secure.simpleconfiguration">简单的客户端访问HBase</link> 章节，并且完成这里面所有的操作步骤。
           </para>
      <para>
          对于安全访问，你必须也配置Zookeeper的安全操作。改变ACLs并使用Zookeeper同步到整个集群。安全认证Zookeeper必须启用，否则通过直接客户端访问
          Zookeeper就可以颠覆HBase访问控制。参考安全的Zookeeper配置章节并且完成里面描述的所有步骤。
           </para>
    </section>

    <section>
      <title>简介</title>
      <para>
          当安全的RPC和访问控制启用，客户端访问HBase需要被认证并且用户数据是私有的，除非访问被显式的授权。访问数据可以被授予针对一个表或者一个列族。
          </para>
      <para>
          然而，为了简单性，下面的选项已经被排除在初始的实现之外：
           </para>
      <orderedlist>
        <listitem>
          <para>
              行级别或者每个值（单元格）：在HFile V3中使用标签
              </para>
        </listitem>
        <listitem>
          <para>
              HDFS文件的所有权：HBase没有被设计用于文件的权限，这可能与HBase系统主要的权限不同。增加HDFS文件所有权将需要修改核心代码。
              另外，虽然HDFS文件所有权将使申请配额变得容易，并且有可能使得批量导入更简单，但目前并不清楚，它会被提供一个更安全的设置。
              </para>
        </listitem>
        <listitem>
          <para>
              HBase管理“角色”的权限的集合：我们不会在HBase开始时在内部模式化“角色”。我们允许组名被授予权限，通过组成员身份，这使得角色的外部模式化。通过Hadoop的组映射服务，组创建和操纵在HBase的外部。
              </para>
        </listitem>
      </orderedlist>
      <para>
          在关系数据库中，访问控制机制很成熟且规范公平。 HBase在这方面的实现和目前的惯用做法近似，但HBase的功能集合相比比关系型数据库更简单，特别是在客户端操作中。
          我们不区分插入（新纪录）和更新（已存在记录）之间的区别。例如，这两个操作都使用Put完成。因此，权限操作被浓缩到四个：读(READ)，写(WRITE)，创建(CREATE)和管理(ADMIN)。
           </para>
      <table>
        <title>操作和权限的映射关系</title>
        <tgroup
          cols="2"
          align="left"
          colsep="1"
          rowsep="1">
          <colspec
            colname="c1"
            align="center" />
          <colspec
            colname="c2"
            align="left" />
          <thead>
            <row>
              <entry>权限</entry>
              <entry>操作</entry>
            </row>
          </thead>
          <tbody>
            <!-- READ -->
            <row>
              <entry>Read</entry>
              <entry>Get</entry>
            </row>
            <row>
              <entry />
              <entry>Exists</entry>
            </row>
            <row>
              <entry />
              <entry>Scan</entry>
            </row>
            <!-- WRITE -->
            <row>
              <entry>Write</entry>
              <entry>Put</entry>
            </row>
            <row>
              <entry />
              <entry>Delete</entry>
            </row>
            <row>
              <entry />
              <entry>Lock/UnlockRow</entry>
            </row>
            <row>
              <entry />
              <entry>IncrementColumnValue</entry>
            </row>
            <row>
              <entry />
              <entry>CheckAndDelete/Put</entry>
            </row>
            <!-- CREATE -->
            <row>
              <entry>Create</entry>
              <entry>Create</entry>
            </row>
            <row>
              <entry />
              <entry>Alter</entry>
            </row>
            <row>
              <entry />
              <entry>Drop</entry>
            </row>
            <row>
              <entry />
              <entry>Bulk Load</entry>
            </row>
            <!-- ADMIN -->
            <row>
              <entry>Admin</entry>
              <entry>Enable/Disable</entry>
            </row>
            <row>
              <entry />
              <entry>Snapshot/Restore/Clone</entry>
            </row>
            <row>
              <entry />
              <entry>Split</entry>
            </row>
            <row>
              <entry />
              <entry>Flush</entry>
            </row>
            <row>
              <entry />
              <entry>Compact</entry>
            </row>
            <row>
              <entry />
              <entry>Major Compact</entry>
            </row>
            <row>
              <entry />
              <entry>Grant</entry>
            </row>
            <row>
              <entry />
              <entry>Revoke</entry>
            </row>
            <row>
              <entry />
              <entry>Shutdown</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>
          权限可以针对下面的任意范围授予，但是CREATE和ADMIN权限的授予的范围仅限于表。
           </para>

      <itemizedlist>
        <listitem>
          <para>表(Table)</para>
          <para>
            <itemizedlist>
              <listitem>
                <para>读(Read): 用户可以从表中的任何列族读取数据</para>
              </listitem>
              <listitem>
                <para>写(Write): 用户可以向表中的任何列族写入数据</para>
              </listitem>
              <listitem>
                <para>创建(Create): 用户可以更改表的属性;增加(add)，更改(alter)，或者移除(drop)列族;也可以移除(drop)表。</para>
              </listitem>
              <listitem>
                <para>管理(Admin): 用户可以更改表的属性;增加(add)，更改(alter)，或者移除(drop)列族;也可以启用(enable)，禁用(disable)，或者移除(drop)表。
                    用户还可以触发region的(重新)分配或移动。
                    </para>
              </listitem>
            </itemizedlist>
          </para>
        </listitem>
        <listitem>
          <para>列族(Column Family)</para>
          <para>
            <itemizedlist>
              <listitem>
                <para>读(Read): 用户可以从列族中读取数据</para>
              </listitem>
              <listitem>
                <para>写(Write): 用户可以向列族中写入数据</para>
              </listitem>
            </itemizedlist>
          </para>
        </listitem>
      </itemizedlist>

      <para> 也有一个隐式的针对全局范围的超级用户。 </para>
      <para>
          超级用户在HBase的配置文件中指定，在HBase中的地位等同于UNIX及其衍生版中的'root'用户。通常主要用于HBase自身进程的身份验证。
          尽管HBase的未来版本中可能在访问控制中支持多个超级用户，超级用户的权限总是主要用于运行HMaster的进程。
          只有超级用户被允许创建表，切换均衡器(balancer)的开或关状态，或者采取有全局影响的其他行为。此外，超级用户被隐式的授予了访问所有资源的权限。
      </para>
      <para>
          表中有一个新的元数据属性：拥有者(OWNER)，即拥有该表的用户主体。默认情况下被设置成创建表的那个用户，尽管它可能在创建表时或在更改(alter)操作过程中通过设置、更改表来改变用户主体所有者属性。 在给定的时间，只有一个用户能拥有一个表。一个表的拥有者将有针对该表的所有权限。
      </para>
    </section>
    <section>
      <title>访问控制表格</title>
      <para>
          下面的表格显示了在HBase的执行操作所需的最小权限集。使用表格前，请仔细阅读有关它的解释信息。
      </para>
      <variablelist>
        <title>解读ACL矩阵表</title>
        <para>下列约定用于ACL矩阵表：</para>
        <varlistentry>
          <term>范围(Scopes)</term>
          <listitem>
            <para>
                权限进行评估从最大范围开始直到最小范围。一个范围对应数据模型中的一个级别。从最大到最小的范围如下:
            </para>
            <itemizedlist>
              <listitem><para>全局(Global)</para></listitem>
              <listitem><para>命名空间(Namespace) (NS)</para></listitem>
              <listitem><para>表(Table)</para></listitem>
              <listitem><para>列限定符(Column Qualifier) (CF)</para></listitem>
              <listitem><para>列族(Column Family) (CQ)</para></listitem>
              <listitem><para>单元格(Cell)</para></listitem>
            </itemizedlist>
            <para>
                例如，在表级别授予的权限比列族，列限定符或者单元格级别的权限更高。在全局范围内授予的权限可以主宰一切：用户可以在任何地方执行操作。
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>权限(Permissions)</term>
          <listitem>
            <para>可能的权限如下：</para>
            <itemizedlist>
              <listitem><para>超级用户 - 一个属于组"supergroup"的特殊用户不受权限限定</para></listitem>
              <listitem><para>管理(Admin) (A)</para></listitem>
              <listitem><para>创建(Create) (C)</para></listitem>
              <listitem><para>写(Write) (W)</para></listitem>
              <listitem><para>读(Read) (R)</para></listitem>
              <listitem><para>执行(Execute) (X)</para></listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>在大多数情况下，权限以预期方式工作，要注意以下几点：</para>
      <itemizedlist>
        <listitem>
          <para>
              有写入权限，并不意味着有读取权限。这是可能的，并且有时需要让一个用户能够将数据写入但写入数据的该用户不能读取。这样的一个例子是日志写入进程。</para>
        </listitem>
        <listitem>
          <para>管理(Admin)是创建(Create)的一个超集，因此具有管理权限的用户不需要创建权限就可以执行相应的操作，如创建表。</para>
        </listitem>
        <listitem>
          <para><systemitem>hbase:meta</systemitem>表对每一个用户都是可读的，无论用户的其他权限或限制。这是HBase正常工作一个需要。</para>
        </listitem>
        <listitem>
          <para>有创建或管理权限的用户被授予了对region元数据的写入权限，因此他们被允许的表操作都可以执行完成。即使在技术上被分别授予的权限之间也可以进行任意组合。</para>
        </listitem>
        <listitem>
          <para>如果用户不同时具有写入和读取权限<code>CheckAndPut</code> 和 <code>CheckAndDelete</code>操作将失败。</para>
        </listitem>
        <listitem>
          <para><code>Increment</code>和<code>Append</code>操作不需要读取访问。</para>
        </listitem>
      </itemizedlist>

      <para>
          下面的表是通过提供每个操作提供的接口来排序的。如果表中的接口过时，检查权限正确性的单元测试代码可以在<filename>hbase-server/src/test/java/org/apache/hadoop/hbase/security/access/TestAccessController.java</filename>中找到，访问控制检查的代码在<filename>hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessController.java</filename>。
          </para>
    
      <table
        frame="all">
        <title>ACL矩阵</title>
        <tgroup
          cols="4">
          <thead>
            <row>
              <entry>接口(Interface)</entry>
              <entry>操作(Operation)</entry>
              <entry>最小范围(Minimum Scope)</entry>
              <entry>最小权限(Minimum Permission)</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry
                morerows="27">
                <!-- incrememt this if you add another "master" operation -->
                <para>Master</para>
              </entry>
              <entry>
                <para>createTable</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>modifyTable</para>
              </entry>
              <entry>
                <para>Table</para>
              </entry>
              <entry>
                <para>A|CW</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>deleteTable</para>
              </entry>
              <entry>
                <para>Table</para>
              </entry>
              <entry>
                <para>A|CW</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>truncateTable</para>
              </entry>
              <entry>
                <para>Table</para>
              </entry>
              <entry>
                <para>A|CW</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>addColumn</para>
              </entry>
              <entry>
                <para>Table</para>
              </entry>
              <entry>
                <para>A|CW</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>modifyColumn</para>
              </entry>
              <entry>
                <para>Table</para>
              </entry>
              <entry>
                <para>A|CW</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>deleteColumn</para>
              </entry>
              <entry>
                <para>Table</para>
              </entry>
              <entry>
                <para>A|CW</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>disableTable</para>
              </entry>
              <entry>
                <para>Table</para>
              </entry>
              <entry>
                <para>A|CW</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>disableAclTable</para>
              </entry>
              <entry>
                <para>None</para>
              </entry>
              <entry>
                <para>Not allowed</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>enableTable</para>
              </entry>
              <entry>
                <para>Table</para>
              </entry>
              <entry>
                <para>A|CW</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>move</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>assign</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>unassign</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>regionOffline</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>balance</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>balanceSwitch</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>shutdown</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>stopMaster</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>snapshot</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>clone</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>restore</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>deleteSnapshot</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>createNamespace</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>deleteNamespace</para>
              </entry>
              <entry>
                <para>Namespace</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>modifyNamespace</para>
              </entry>
              <entry>
                <para>Namespace</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>flushTable</para>
              </entry>
              <entry>
                <para>Table</para>
              </entry>
              <entry>
                <para>A|CW</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>getTableDescriptors</para>
              </entry>
              <entry>
                <para>Global|Table</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>mergeRegions</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry
                morerows="25">Region</entry>
              <!-- Incrememt this if you add any more Region
                operations -->
              <entry>preOpen</entry>
              <entry>Global</entry>
              <entry>A</entry>
            </row>
            <row>
              <entry>
                <para>openRegion</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>preClose</entry>
              <entry>Global</entry>
              <entry>A</entry>
            </row>
            <row>
              <entry>
                <para>closeRegion</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>preStopRegionServer</entry>
              <entry>Global</entry>
              <entry>A</entry>
            </row>
            <row>
              <entry>
                <para>stopRegionServer</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>mergeRegions</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>append</entry>
              <entry>Table</entry>
              <entry>W</entry>
            </row>
            <row>
              <entry>delete</entry>
              <entry>Table|CF|CQ</entry>
              <entry>W</entry>
            </row>
            <row>
              <entry>exists</entry>
              <entry>Table|CF|CQ</entry>
              <entry>R</entry>
            </row>
            <row>
              <entry>get</entry>
              <entry>Table|CF|CQ</entry>
              <entry>R</entry>
            </row>
            <row>
              <entry>getClosestRowBefore</entry>
              <entry>Table|CF|CQ</entry>
              <entry>R</entry>
            </row>
            <row>
              <entry>increment</entry>
              <entry>Table|CF|CQ</entry>
              <entry>W</entry>
            </row>
            <row>
              <entry>put</entry>
              <entry>Table|CF|CQ</entry>
              <entry>W</entry>
            </row>
            <row>
              <entry>
                <para>flush</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A|CW</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>split</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>compact</para>
              </entry>
              <entry>
                <para>Global</para>
              </entry>
              <entry>
                <para>A|CW</para>
              </entry>
            </row>
            <row>
              <entry>bulkLoadHFile</entry>
              <entry>Table</entry>
              <entry>W</entry>
            </row>
            <row>
              <entry>prepareBulkLoad</entry>
              <entry>Table</entry>
              <entry>CW</entry>
            </row>
            <row>
              <entry>cleanupBulkLoad</entry>
              <entry>Table</entry>
              <entry>W</entry>
            </row>
            <row>
              <entry>checkAndDelete</entry>
              <entry>Table|CF|CQ</entry>
              <entry>RW</entry>
            </row>
            <row>
              <entry>checkAndPut</entry>
              <entry>Table|CF|CQ</entry>
              <entry>RW</entry>
            </row>
            <row>
              <entry>incrementColumnValue</entry>
              <entry>Table|CF|CQ</entry>
              <entry>RW</entry>
            </row>
            <row>
              <entry>ScannerClose</entry>
              <entry>Table</entry>
              <entry>R</entry>
            </row>
            <row>
              <entry>ScannerNext</entry>
              <entry>Table</entry>
              <entry>R</entry>
            </row>
            <row>
              <entry>ScannerOpen</entry>
              <entry>Table|CQ|CF</entry>
              <entry>R</entry>
            </row>
            <row>
              <entry>
                <para>Endpoint</para>
              </entry>
              <entry>
                <para>invoke</para>
              </entry>
              <entry>Endpoint</entry>
              <entry>
                <para>X</para>
              </entry>
            </row>
            <row>
              <entry
                morerows="3">
                <para>AccessController</para>
              </entry>
              <entry>
                <para>grant</para>
              </entry>
              <entry>Global|Table|NS</entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>revoke</para>
              </entry>
              <entry>Global|Table|NS</entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>userPermissions</para>
              </entry>
              <entry>
                <para>Global|Table|NS</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>checkPermissions</para>
              </entry>
              <entry>
                <para>Global|Table|NS</para>
              </entry>
              <entry>
                <para>A</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>服务器端访问控制配置</title>
      <para>
          在集群配置中启用访问控制协处理器(coprocessor)并且重新启动HBase集群。重启可以逐台进行。完成所有Master和RegionServer进程的重启前先设置ACLs。
           </para>
      <para>
          为了启用访问控制器，修改集群中的所有机器的<code>hbase-site.xml</code>文件，添加如下内容：
           </para>
      <programlisting language="xml"><![CDATA[
<property>
  <name>hbase.coprocessor.master.classes</name>
  <value>org.apache.hadoop.hbase.security.access.AccessController</value>
</property>
<property>
<name>hbase.coprocessor.region.classes</name>
  <value>org.apache.hadoop.hbase.security.token.TokenProvider,
  org.apache.hadoop.hbase.security.access.AccessController</value>
</property>
    ]]></programlisting>
    </section>

    <section>
      <title>使用标签的单元格级别访问控制</title>
      <para>
          HBase 0.98之前的HBase将访问控制级别严格设定到表和列族级别。幸亏在0.98中引入了标签特性，访问控制也可以针对单元格级别了。访问控制协处理器将帮助完成单元格级别的访问控制。
          想要配置它，请参考 <link
          linkend="hbase.accesscontrol.configuration">Access Control</link> 部分。 </para>
      <para>
          ACLs可以通过对每一个操作使用APIs来指定：
           </para>
      <programlisting language="java"><![CDATA[
Mutation.setACL(String user, Permission perms)
Mutation.setACL(Map<String, Permission> perms)
    ]]></programlisting>
      <para>
          例如，为了给用户‘user1’提供一个读权限，可以：
          </para>
      <programlisting language="java"><![CDATA[
put.setACL(“user1”, new Permission(Permission.Action.READ))
    ]]></programlisting>
      <para>
          通过ACL应用到表和CF级别比单元格的ACL级别更高。为了采用单元格级别的ACL，可以使用如下API：
           </para>
      <programlisting language="java"><![CDATA[
Mutation.setACLStrategy(boolean cellFirstStrategy)
    ]]></programlisting>
      <para>
          注意，为了使用这个特性，HFile V3格式应该被设置：
          </para>
      <programlisting language="xml"><![CDATA[
<property>
  <name>hfile.format.version</name>
  <value>3</value>
</property>
     ]]></programlisting>
      <para>
          需要注意的是使用ACL删除没有任何影响。为了简单起见，当前Put的ACLs设置将不会改变在统一行的老版本的Put的ACLs设置的含义。
           </para>
    </section>
    <section>
      <title>Shell对访问控制的增强</title>
      <para>
          HBase shell命令已经被扩展，提供了一些简单的用于修改和更新用户权限的命令。下面的命令已经被增加到访问控制列表中了：
           </para>


      <example>
        <title>授予(Grant)</title>
        <programlisting language="sql"><![CDATA[
grant <user|@group> <permissions> [ <table> [ <column family> [ <column qualifier> ] ] ]
        ]]></programlisting>
      </example>

      <para>
        <code>&lt;user|@group&gt;</code> 是用户或组（以字符'@'开始），组通过Hadoop组映射服务来创建和操作。 </para>
      <para>
        <code>&lt;permissions&gt;</code> 是i"RWCA": READ('R'),
        WRITE('W'), CREATE('C'), ADMIN('A')中的一个。 </para>
      <para>
          注意：授予和回收一个资源的权限都通过使用命令<code>grant</code>来完成。命令<code>revoke</code>也被shell提供，但是这是为了快速撤销所有用户对给定资源的权限。
          </para>
      <example>
        <title>回收(Revoke)</title>

        <programlisting language="sql"><![CDATA[
revoke <user|@group> [ <table> [ <column family> [ <column qualifier> ] ] ]
    ]]></programlisting>
      </example>
      <example>
        <title>更改(Alter)</title>

        <para>  <code>alter</code> 命令已经被扩展到允许进行拥有者分配：</para>
        <programlisting language="sql"><![CDATA[
alter 'tablename', {OWNER => 'username|@group'}
]]></programlisting>
      </example>

      <example>
        <title>用户权限</title>

        <para> <code>user_permission</code> 命令显示对于一个给定的表当前用户所有的访问权限：</para>
        <programlisting><![CDATA[
user_permission <table>
    ]]></programlisting>
      </example>
    </section>

  </section>
  <!-- Access Control -->

  <section
    xml:id="hbase.secure.bulkload">
    <title>Secure Bulk Load</title>
    <para> Bulk loading in secure mode is a bit more involved than normal setup, since the client
      has to transfer the ownership of the files generated from the mapreduce job to HBase. Secure
      bulk loading is implemented by a coprocessor, named <link
        xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/security/access/SecureBulkLoadEndpoint.html">SecureBulkLoadEndpoint</link>.
      SecureBulkLoadEndpoint uses a staging directory <code>"hbase.bulkload.staging.dir"</code>,
      which defaults to <code>/tmp/hbase-staging/</code>. The algorithm is as follows. </para>
    <itemizedlist>
      <listitem>
        <para>Create an hbase owned staging directory which is world traversable (<code>-rwx--x--x,
            711</code>) <code>/tmp/hbase-staging</code>. </para>
      </listitem>
      <listitem>
        <para>A user writes out data to his secure output directory: /user/foo/data </para>
      </listitem>
      <listitem>
        <para>A call is made to hbase to create a secret staging directory which is globally
          readable/writable (<code>-rwxrwxrwx, 777</code>):
          /tmp/hbase-staging/averylongandrandomdirectoryname</para>
      </listitem>
      <listitem>
        <para>The user makes the data world readable and writable, then moves it into the random
          staging directory, then calls bulkLoadHFiles()</para>
      </listitem>
    </itemizedlist>
    <para> Like delegation tokens the strength of the security lies in the length and randomness of
      the secret directory. </para>

    <para> You have to enable the secure bulk load to work properly. You can modify the
        <code>hbase-site.xml</code> file on every server machine in the cluster and add the
      SecureBulkLoadEndpoint class to the list of regionserver coprocessors: </para>
    <programlisting language="xml"><![CDATA[
<property>
  <name>hbase.bulkload.staging.dir</name>
  <value>/tmp/hbase-staging</value>
</property>
<property>
  <name>hbase.coprocessor.region.classes</name>
  <value>org.apache.hadoop.hbase.security.token.TokenProvider,
  org.apache.hadoop.hbase.security.access.AccessController,org.apache.hadoop.hbase.security.access.SecureBulkLoadEndpoint</value>
</property>
    ]]></programlisting>
  </section>
  <!-- Secure Bulk Load -->

  <section
    xml:id="hbase.visibility.labels">
    <title>Visibility Labels</title>
    <para> This feature provides cell level security with labeled visibility for the cells. Cells
      can be associated with a visibility expression. The visibility expression can contain labels
      joined with logical expressions &#39;&amp;&#39;, &#39;|&#39; and &#39;!&#39;. Also using
      &#39;(&#39;, &#39;)&#39; one can specify the precedence order. For example, consider the label
      set { confidential, secret, topsecret, probationary }, where the first three are sensitivity
      classifications and the last describes if an employee is probationary or not. If a cell is
      stored with this visibility expression: ( secret | topsecret ) &amp; !probationary </para>
    <para> Then any user associated with the secret or topsecret label will be able to view the
      cell, as long as the user is not also associated with the probationary label. Furthermore, any
      user only associated with the confidential label, whether probationary or not, will not see
      the cell or even know of its existence. </para>
    <para> Visibility expressions like the above can be added when storing or mutating a cell using
      the API, </para>
    <programlisting language="java">Mutation#setCellVisibility(new CellVisibility(String labelExpession));</programlisting>
    <para> Where the labelExpression could be &#39;( secret | topsecret ) &amp; !probationary&#39; </para>
    <para> We build the user&#39;s label set in the RPC context when a request is first received by
      the HBase RegionServer. How users are associated with labels is pluggable. The default plugin
      passes through labels specified in Authorizations added to the Get or Scan and checks those
      against the calling user&#39;s authenticated labels list. When client passes some labels for
      which the user is not authenticated, this default algorithm will drop those. One can pass a
      subset of user authenticated labels via the Scan/Get authorizations. </para>
    <para><code>Get#setAuthorizations(new Authorizations(String,...));</code></para>
    <para><code>Scan#setAuthorizations(new Authorizations(String,...));</code></para>

    <section
      xml:id="hbase.visibility.label.administration">
      <title>Visibility Label Administration</title>
      <para> There are new client side Java APIs and shell commands for performing visibility labels
        administrative actions. Only the HBase super user is authorized to perform these operations. </para>

      <section
        xml:id="hbase.visibility.label.administration.add.label">
        <title>Adding Labels</title>
        <para>A set of labels can be added to the system either by using the Java API</para>
        <para><code>VisibilityClient#addLabels(Configuration conf, final String[]
          labels)</code></para>
        <para>Or by using the shell command</para>
        <para><code>add_labels [label1, label2]</code></para>
        <para> Valid label can include alphanumeric characters and characters &#39;-&#39;,
          &#39;_&#39;, &#39;:&#39;, &#39;.&#39; and &#39;/&#39; </para>
      </section>

      <section
        xml:id="hbase.visibility.label.administration.add.label2">
        <title>User Label Association</title>
        <para>A set of labels can be associated with a user by using the API</para>
        <para><code>VisibilityClient#setAuths(Configuration conf, final String[] auths, final String
            user)</code></para>
        <para>Or by using the shell command</para>
        <para><code>set_auths user,[label1, label2].</code></para>
        <para>Labels can be disassociated from a user using API</para>
        <para><code>VisibilityClient#clearAuths(Configuration conf, final String[] auths, final
            String user)</code></para>
        <para>Or by using shell command</para>
        <para><code>clear_auths user,[label1, label2]</code></para>
        <para> One can use the API <code>VisibilityClient#getAuths(Configuration conf, final String
            user)</code> or <code>get_auths</code> shell command to get the list of labels
          associated for a given user. The labels and user auths information will be stored in the
          system table &#34;labels&#34;. </para>
      </section>
    </section>

    <section
      xml:id="hbase.visibility.label.configuration">
      <title>Server Side Configuration</title>
      <para> HBase stores cell level labels as cell tags. HFile version 3 adds the cell tags
        support. Be sure to use HFile version 3 by setting this property in every server site
        configuration file: </para>
      <programlisting language="xml"><![CDATA[
		  <property>
		    <name>hfile.format.version</name>
			<value>3</value>
		  </property>
		]]></programlisting>
      <para> You will also need to make sure the VisibilityController coprocessor is active on every
        table to protect by adding it to the list of system coprocessors in the server site
        configuration files: </para>
      <programlisting language="xml"><![CDATA[
<property>
  <name>hbase.coprocessor.master.classes</name>
<value>org.apache.hadoop.hbase.security.visibility.VisibilityController</value>
</property>
<property>
  <name>hbase.coprocessor.region.classes</name>
<value>org.apache.hadoop.hbase.security.visibility.VisibilityController</value>
</property>
		]]></programlisting>
      <para> As said above, finding out labels authenticated for a given get/scan request is a
        pluggable algorithm. A custom implementation can be plugged in using the property
          <code>hbase.regionserver.scan.visibility.label.generator.class</code>. The default
        implementation class is
          <code>org.apache.hadoop.hbase.security.visibility.DefaultScanLabelGenerator</code>. One
        can configure a set of ScanLabelGenerators to be used by the system. For this, a comma
        separated set of implementation class names to be configured. </para>
      <note>
        <title>Visibility Labels and Replication</title>
        <para>By default, visibility labels are lost on replication. To change this behavior, see
          <xref linkend="cluster.replication.preserving.tags" />.</para>
      </note>
    </section>
  </section>

  <section
    xml:id="hbase.encryption.server">
    <title>Transparent Server Side Encryption</title>
    <para> This feature provides transparent encryption for protecting HFile and WAL data at rest,
      using a two-tier key architecture for flexible and non-intrusive key rotation. </para>
    <para> First, the administrator provisions a cluster master key, stored into a key provider
      accessable to every trusted HBase process: the Master, the RegionServers, and clients (e.g.
      the shell) on administrative workstations. The default key provider integrates with the Java
      KeyStore API and any key management system with support for it. How HBase retrieves key
      material is configurable via the site file. The master key may be stored on the cluster
      servers, protected by a secure KeyStore file, or on an external keyserver, or in a hardware
      security module. This master key is resolved as needed by HBase processes through the
      configured key provider. </para>
    <para> Then, encryption keys can be specified in schema on a per column family basis, by
      creating or modifying a column descriptor to include two additional attributes: the name of
      the encryption algorithm to use (currently only "AES" is supported), and, optionally, a data
      key wrapped (encrypted) with the cluster master key. Per CF keys facilitates low impact
      incremental key rotation and reduces the scope of any external leak of key material. The
      wrapped data key is stored in the CF schema metadata, and in each HFile for the CF, encrypted
      with the cluster master key. Once the CF is configured for encryption, any new HFiles will be
      written encrypted. To insure encryption of all HFiles, trigger a major compaction after first
      enabling this feature. The key for decryption, encrypted with the cluster master key, is
      stored in the HFiles in a new meta block. At file open time the data key will be extracted
      from the HFile, decrypted with the cluster master key, and used for decryption of the
      remainder of the HFile. The HFile will be unreadable if the master key is not available.
      Should remote users somehow acquire access to the HFile data because of some lapse in HDFS
      permissions or from inappropriately discarded media, there will be no means to decrypt either
      the data key or the file data. </para>
    <para> Specifying a data key in the CF schema is optional. If one is not present, a random data
      key will be created for each HFile. </para>
    <para> A new configuration option for encrypting the WAL is also introduced. Even though WALs
      are transient, it is necessary to encrypt the WALEdits to avoid circumventing HFile
      protections for encrypted column families. </para>
    <section
      xml:id="hbase.encryption.server.configuration">
      <title>Configuration</title>
      <para> Create a secret key of appropriate length for AES. </para>
      <screen language="bourne"><![CDATA[
$ keytool -keystore /path/to/hbase/conf/hbase.jks \
  -storetype jceks -storepass <password> \
  -genseckey -keyalg AES -keysize 128 \
  -alias <alias>
	]]></screen>
      <para> where &lt;password&gt; is the password for the KeyStore file and &lt;alias&gt;is the
        user name of the HBase service account, typically "hbase". Simply press RETURN to store the
        key with the same password as the store. The resulting file should be distributed to all
        nodes running HBase daemons, with file ownership and permissions set to be readable only by
        the HBase service account. </para>
      <para> Configure HBase daemons to use a key provider backed by the KeyStore files for
        retrieving the cluster master key as needed. </para>
      <programlisting language="xml"><![CDATA[
<property>
    <name>hbase.crypto.keyprovider</name>
    <value>org.apache.hadoop.hbase.io.crypto.KeyStoreKeyProvider</value>
</property>
<property>
    <name>hbase.crypto.keyprovider.parameters</name>
    <value>jceks:///path/to/hbase/conf/hbase.jks?password=<password></value>
</property>
        ]]></programlisting>
      <para> By default the HBase service account name will be used to resolve the cluster master
        key, but you can store it with any arbitrary alias and configure HBase appropriately: </para>
      <programlisting language="xml"><![CDATA[
<property>
    <name>hbase.crypto.master.key.name</name>
    <value>hbase</value>
</property>
        ]]></programlisting>
      <para> Because the password to the key store is sensitive information, the HBase site XML file
        should also have its permissions set to be readable only by the HBase service account. </para>
      <para> Transparent encryption is a feature of HFile version 3. Be sure to use HFile version 3
        by setting this property in every server site configuration file: </para>
      <programlisting language="xml"><![CDATA[
<property>
    <name>hfile.format.version</name>
    <value>3</value>
</property>
        ]]></programlisting>
      <para> Finally, configure the secure WAL in every server site configuration file: </para>
      <programlisting language="xml"><![CDATA[
<property>
    <name>hbase.regionserver.hlog.reader.impl</name>
    <value>org.apache.hadoop.hbase.regionserver.wal.SecureProtobufLogReader</value>
</property>
<property>
    <name>hbase.regionserver.hlog.writer.impl</name>
    <value>org.apache.hadoop.hbase.regionserver.wal.SecureProtobufLogWriter</value>
</property>
<property>
    <name>hbase.regionserver.wal.encryption</name>
    <value>true</value>
</property>
        ]]></programlisting>
    </section>
    <section
      xml:id="hbase.encryption.server.schema">
      <title>Setting Encryption on a CF</title>
      <para> To enable encryption on a CF, use <code>HBaseAdmin#modifyColumn</code> or the HBase
        shell to modify the column descriptor. The attribute 'ENCRYPTION' specifies the encryption
        algorithm to use. Currently only "AES" is supported. If creating a new table, simply set
        this attribute; no subsequent table modification will be necessary. </para>
      <para> If setting a specific data key, the attribute 'ENCRYPTION_KEY' should contain the data
        key wrapped by the cluster master key. The static methods <code>wrapKey</code> and
          <code>unwrapKey</code> in <code>org.apache.hadoop.hbase.security.EncryptionUtil</code> can
        be used in conjunction with <code>HColumnDescriptor#setEncryptionKey</code> for this
        purpose. Because this must be done programatically, setting a data key with the shell is not
        supported. </para>
      <para> To disable encryption on a CF, simply remove the 'ENCRYPTION' (and 'ENCRYPTION_KEY', if
        it was set) attributes from the column schema, using <code>HBaseAdmin#modifyColumn</code> or
        the HBase shell. All new HFiles for the CF will be written without encryption. Trigger a
        major compaction to rewrite all files. </para>
    </section>
    <section
      xml:id="hbase.encryption.server.data_key_rotation">
      <title>Data Key Rotation</title>
      <para> Data key rotation is made simple by this design. First, change the CF key in the column
        descriptor. Then, trigger major compaction. Once compaction has completed, all files will be
        (re)encrypted with the new key material. While this process is ongoing, HFiles encrypted
        with old key material will still be readable. </para>
    </section>
    <section
      xml:id="hbase.encryption.server.master_key_rotation">
      <title>Master Key Rotation</title>
      <para> Master key rotation can be achieved by updating the KeyStore to contain a new master
        key, as described above, with also the old master key added to the KeyStore under a
        different alias. Then, configure fallback to the old master key in the HBase site file: </para>
      <programlisting language="xml"><![CDATA[
<property>
    <name>hbase.crypto.master.alternate.key.name</name>
    <value>hbase.old</value>
</property>
        ]]></programlisting>
      <para> This will require a rolling restart of the HBase daemons to take effect. As with data
        key rotation, trigger a major compaction and wait for it to complete. Once compaction has
        completed, all files will be (re)encrypted with data keys wrapped by the new cluster master
        key. The old master key, and its associated site file configuration, can then be removed,
        and all trace of the old master key will be gone after the next rolling restart. A second
        rolling restart is not immediately necessary. </para>
    </section>
  </section>

</chapter>
